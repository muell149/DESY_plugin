// Generated at Tue Jan 21 10:57:11 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/TopAnalysis/HiggsUtils/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_65 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_318 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_247 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1310 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_94 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_163 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_286 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_268 = ::Reflex::TypeBuilder(Reflex::Literal("HiggsGenEvent"));
  ::Reflex::Type type_923 = ::Reflex::TypeBuilder(Reflex::Literal("JetProperties"));
  ::Reflex::Type type_277 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_3289 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCore"));
  ::Reflex::Type type_413 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3287 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2530 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_4462 = ::Reflex::TypeBuilder(Reflex::Literal("reco::GenParticle"));
  ::Reflex::Type type_1577 = ::Reflex::TypeBuilder(Reflex::Literal("GenZDecayProperties"));
  ::Reflex::Type type_3323 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDProductGetter"));
  ::Reflex::Type type_2526 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2529 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<JetProperties>"));
  ::Reflex::Type type_2527 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3335 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<JetProperties>"));
  ::Reflex::Type type_3336 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<HiggsGenEvent>"));
  ::Reflex::Type type_3305 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<JetProperties>"));
  ::Reflex::Type type_3306 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<HiggsGenEvent>"));
  ::Reflex::Type type_3219 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<JetProperties>"));
  ::Reflex::Type type_3220 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<HiggsGenEvent>"));
  ::Reflex::Type type_2307 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<JetProperties>"));
  ::Reflex::Type type_2308 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<HiggsGenEvent>"));
  ::Reflex::Type type_2760 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<JetProperties>"));
  ::Reflex::Type type_2534 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::GenParticle>"));
  ::Reflex::Type type_3256 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<JetProperties>"));
  ::Reflex::Type type_3257 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<HiggsGenEvent>"));
  ::Reflex::Type type_2528 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<GenZDecayProperties>"));
  ::Reflex::Type type_3334 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<GenZDecayProperties>"));
  ::Reflex::Type type_3276 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<JetProperties>"));
  ::Reflex::Type type_3277 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<HiggsGenEvent>"));
  ::Reflex::Type type_3304 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<GenZDecayProperties>"));
  ::Reflex::Type type_3217 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<GenZDecayProperties>"));
  ::Reflex::Type type_2305 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<GenZDecayProperties>"));
  ::Reflex::Type type_2759 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<GenZDecayProperties>"));
  ::Reflex::Type type_3225 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<JetProperties>"));
  ::Reflex::Type type_3226 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<HiggsGenEvent>"));
  ::Reflex::Type type_3255 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<GenZDecayProperties>"));
  ::Reflex::Type type_2532 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const reco::GenParticle*>"));
  ::Reflex::Type type_3275 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<GenZDecayProperties>"));
  ::Reflex::Type type_3218 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<JetProperties> >"));
  ::Reflex::Type type_3223 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<GenZDecayProperties>"));
  ::Reflex::Type type_2306 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<JetProperties> >"));
  ::Reflex::Type type_3307 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::GenParticle> >"));
  ::Reflex::Type type_3216 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<GenZDecayProperties> >"));
  ::Reflex::Type type_2304 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<GenZDecayProperties> >"));
  ::Reflex::Type type_3224 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<JetProperties> >"));
  ::Reflex::Type type_3318 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_3222 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<GenZDecayProperties> >"));
  ::Reflex::Type type_4264 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >"));
  ::Reflex::Type type_2071 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<JetProperties,std::allocator<JetProperties> >"));
  ::Reflex::Type type_4508 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >"));
  ::Reflex::Type type_2531 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >"));
  ::Reflex::Type type_2070 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<GenZDecayProperties,std::allocator<GenZDecayProperties> >"));
  ::Reflex::Type type_4509 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const JetProperties*,std::vector<JetProperties> >"));
  ::Reflex::Type type_4506 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >"));
  ::Reflex::Type type_4507 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const GenZDecayProperties*,std::vector<GenZDecayProperties> >"));
  ::Reflex::Type type_2874 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> > >"));
  ::Reflex::Type type_2873 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const JetProperties*,std::vector<JetProperties> > >"));
  ::Reflex::Type type_2872 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> > >"));
  ::Reflex::Type type_2871 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const GenZDecayProperties*,std::vector<GenZDecayProperties> > >"));
  ::Reflex::Type type_4463 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GenParticleRefProd"), type_3307);
  ::Reflex::Type type_12132 = ::Reflex::ReferenceBuilder(type_268);
  ::Reflex::Type type_268c = ::Reflex::ConstBuilder(type_268);
  ::Reflex::Type type_12133 = ::Reflex::ReferenceBuilder(type_268c);
  ::Reflex::Type type_12134 = ::Reflex::ReferenceBuilder(type_4463);
  ::Reflex::Type type_4466 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GenParticleCollection"), type_2534);
  ::Reflex::Type type_4466c = ::Reflex::ConstBuilder(type_4466);
  ::Reflex::Type type_12135 = ::Reflex::ReferenceBuilder(type_4466c);
  ::Reflex::Type type_4462c = ::Reflex::ConstBuilder(type_4462);
  ::Reflex::Type type_8354 = ::Reflex::PointerBuilder(type_4462c);
  ::Reflex::Type type_4265 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::PtEtaPhiMLorentzVectorD"), type_4264);
  ::Reflex::Type type_8101 = ::Reflex::ReferenceBuilder(type_923);
  ::Reflex::Type type_923c = ::Reflex::ConstBuilder(type_923);
  ::Reflex::Type type_8103 = ::Reflex::ReferenceBuilder(type_923c);
  ::Reflex::Type type_94c = ::Reflex::ConstBuilder(type_94);
  ::Reflex::Type type_16241 = ::Reflex::ReferenceBuilder(type_94c);
  ::Reflex::Type type_65c = ::Reflex::ConstBuilder(type_65);
  ::Reflex::Type type_5500 = ::Reflex::ReferenceBuilder(type_65c);
  ::Reflex::Type type_4265c = ::Reflex::ConstBuilder(type_4265);
  ::Reflex::Type type_16242 = ::Reflex::ReferenceBuilder(type_4265c);
  ::Reflex::Type type_2531c = ::Reflex::ConstBuilder(type_2531);
  ::Reflex::Type type_16243 = ::Reflex::ReferenceBuilder(type_2531c);
  ::Reflex::Type type_2530c = ::Reflex::ConstBuilder(type_2530);
  ::Reflex::Type type_16244 = ::Reflex::ReferenceBuilder(type_2530c);
  ::Reflex::Type type_8036 = ::Reflex::ReferenceBuilder(type_1577);
  ::Reflex::Type type_1577c = ::Reflex::ConstBuilder(type_1577);
  ::Reflex::Type type_8038 = ::Reflex::ReferenceBuilder(type_1577c);
  ::Reflex::Type type_8032 = ::Reflex::PointerBuilder(type_1577);
  ::Reflex::Type type_8034 = ::Reflex::PointerBuilder(type_1577c);
  ::Reflex::Type type_2745 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_277);
  ::Reflex::Type type_2637 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_247);
  ::Reflex::Type type_2759c = ::Reflex::ConstBuilder(type_2759);
  ::Reflex::Type type_19504 = ::Reflex::ReferenceBuilder(type_2759c);
  ::Reflex::Type type_2528c = ::Reflex::ConstBuilder(type_2528);
  ::Reflex::Type type_20278 = ::Reflex::ReferenceBuilder(type_2528c);
  ::Reflex::Type type_20279 = ::Reflex::ReferenceBuilder(type_2528);
  ::Reflex::Type type_8097 = ::Reflex::PointerBuilder(type_923);
  ::Reflex::Type type_8099 = ::Reflex::PointerBuilder(type_923c);
  ::Reflex::Type type_2760c = ::Reflex::ConstBuilder(type_2760);
  ::Reflex::Type type_19516 = ::Reflex::ReferenceBuilder(type_2760c);
  ::Reflex::Type type_2529c = ::Reflex::ConstBuilder(type_2529);
  ::Reflex::Type type_20281 = ::Reflex::ReferenceBuilder(type_2529c);
  ::Reflex::Type type_20282 = ::Reflex::ReferenceBuilder(type_2529);
  ::Reflex::Type type_20839 = ::Reflex::PointerBuilder(type_2528c);
  ::Reflex::Type type_413c = ::Reflex::ConstBuilder(type_413);
  ::Reflex::Type type_3194 = ::Reflex::ReferenceBuilder(type_413c);
  ::Reflex::Type type_20840 = ::Reflex::PointerBuilder(type_2528);
  ::Reflex::Type type_3222c = ::Reflex::ConstBuilder(type_3222);
  ::Reflex::Type type_20841 = ::Reflex::PointerBuilder(type_3222c);
  ::Reflex::Type type_3287c = ::Reflex::ConstBuilder(type_3287);
  ::Reflex::Type type_12053 = ::Reflex::ReferenceBuilder(type_3287c);
  ::Reflex::Type type_20274 = ::Reflex::ReferenceBuilder(type_2526);
  ::Reflex::Type type_20842 = ::Reflex::ReferenceBuilder(type_3318);
  ::Reflex::Type type_318c = ::Reflex::ConstBuilder(type_318);
  ::Reflex::Type type_3083 = ::Reflex::PointerBuilder(type_318c);
  ::Reflex::Type type_5511 = ::Reflex::ReferenceBuilder(type_3083);
  ::Reflex::Type type_2527c = ::Reflex::ConstBuilder(type_2527);
  ::Reflex::Type type_20275 = ::Reflex::ReferenceBuilder(type_2527c);
  ::Reflex::Type type_3223c = ::Reflex::ConstBuilder(type_3223);
  ::Reflex::Type type_20845 = ::Reflex::PointerBuilder(type_3223c);
  ::Reflex::Type type_20848 = ::Reflex::PointerBuilder(type_2529c);
  ::Reflex::Type type_20849 = ::Reflex::PointerBuilder(type_2529);
  ::Reflex::Type type_3224c = ::Reflex::ConstBuilder(type_3224);
  ::Reflex::Type type_20850 = ::Reflex::PointerBuilder(type_3224c);
  ::Reflex::Type type_3225c = ::Reflex::ConstBuilder(type_3225);
  ::Reflex::Type type_20853 = ::Reflex::PointerBuilder(type_3225c);
  ::Reflex::Type type_20856 = ::Reflex::PointerBuilder(type_268c);
  ::Reflex::Type type_20857 = ::Reflex::PointerBuilder(type_268);
  ::Reflex::Type type_3226c = ::Reflex::ConstBuilder(type_3226);
  ::Reflex::Type type_20858 = ::Reflex::PointerBuilder(type_3226c);
  ::Reflex::Type type_20953 = ::Reflex::ReferenceBuilder(type_3304);
  ::Reflex::Type type_3304c = ::Reflex::ConstBuilder(type_3304);
  ::Reflex::Type type_20954 = ::Reflex::ReferenceBuilder(type_3304c);
  ::Reflex::Type type_3334c = ::Reflex::ConstBuilder(type_3334);
  ::Reflex::Type type_20955 = ::Reflex::ReferenceBuilder(type_3334c);
  ::Reflex::Type type_3275c = ::Reflex::ConstBuilder(type_3275);
  ::Reflex::Type type_20956 = ::Reflex::ReferenceBuilder(type_3275c);
  ::Reflex::Type type_3255c = ::Reflex::ConstBuilder(type_3255);
  ::Reflex::Type type_20957 = ::Reflex::ReferenceBuilder(type_3255c);
  ::Reflex::Type type_3323c = ::Reflex::ConstBuilder(type_3323);
  ::Reflex::Type type_12900 = ::Reflex::PointerBuilder(type_3323c);
  ::Reflex::Type type_3289c = ::Reflex::ConstBuilder(type_3289);
  ::Reflex::Type type_12416 = ::Reflex::ReferenceBuilder(type_3289c);
  ::Reflex::Type type_20958 = ::Reflex::ReferenceBuilder(type_3305);
  ::Reflex::Type type_3305c = ::Reflex::ConstBuilder(type_3305);
  ::Reflex::Type type_20959 = ::Reflex::ReferenceBuilder(type_3305c);
  ::Reflex::Type type_3335c = ::Reflex::ConstBuilder(type_3335);
  ::Reflex::Type type_20960 = ::Reflex::ReferenceBuilder(type_3335c);
  ::Reflex::Type type_3276c = ::Reflex::ConstBuilder(type_3276);
  ::Reflex::Type type_20961 = ::Reflex::ReferenceBuilder(type_3276c);
  ::Reflex::Type type_3256c = ::Reflex::ConstBuilder(type_3256);
  ::Reflex::Type type_20962 = ::Reflex::ReferenceBuilder(type_3256c);
  ::Reflex::Type type_20963 = ::Reflex::ReferenceBuilder(type_3306);
  ::Reflex::Type type_3306c = ::Reflex::ConstBuilder(type_3306);
  ::Reflex::Type type_20964 = ::Reflex::ReferenceBuilder(type_3306c);
  ::Reflex::Type type_3336c = ::Reflex::ConstBuilder(type_3336);
  ::Reflex::Type type_20965 = ::Reflex::ReferenceBuilder(type_3336c);
  ::Reflex::Type type_3277c = ::Reflex::ConstBuilder(type_3277);
  ::Reflex::Type type_20966 = ::Reflex::ReferenceBuilder(type_3277c);
  ::Reflex::Type type_3257c = ::Reflex::ConstBuilder(type_3257);
  ::Reflex::Type type_20967 = ::Reflex::ReferenceBuilder(type_3257c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __HiggsGenEvent
#undef __HiggsGenEvent
#endif
class __HiggsGenEvent {
  public:
  __HiggsGenEvent();
  virtual ~__HiggsGenEvent() throw();
  ::reco::GenParticleRefProd parts_;
};
#ifdef __JetProperties
#undef __JetProperties
#endif
class __JetProperties {
  public:
  __JetProperties();
  double jetChargeGlobalPtWeighted_;
  double jetChargeRelativePtWeighted_;
  int jetAssociatedPartonPdgId_;
  ::math::PtEtaPhiMLorentzVectorD jetAssociatedParton_;
  ::std::vector<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > > jetTrack_;
  ::std::vector<int> jetTrackCharge_;
};
#ifdef __GenZDecayProperties
#undef __GenZDecayProperties
#endif
class __GenZDecayProperties {
  public:
  __GenZDecayProperties();
  virtual ~__GenZDecayProperties() throw();
  void* z_;
  void* meDaughterParticle_;
  void* meDaughterAntiParticle_;
  void* stableLepton_;
  void* stableAntiLepton_;
  int decayMode_;
};
#ifdef __std__vector_GenZDecayProperties_
#undef __std__vector_GenZDecayProperties_
#endif
class __std__vector_GenZDecayProperties_ : protected ::std::_Vector_base<GenZDecayProperties,std::allocator<GenZDecayProperties> > {
  public:
  __std__vector_GenZDecayProperties_();
};
#ifdef __std__vector_JetProperties_
#undef __std__vector_JetProperties_
#endif
class __std__vector_JetProperties_ : protected ::std::_Vector_base<JetProperties,std::allocator<JetProperties> > {
  public:
  __std__vector_JetProperties_();
};
#ifdef __edm__Wrapper_std__vector_GenZDecayProperties_s_
#undef __edm__Wrapper_std__vector_GenZDecayProperties_s_
#endif
class __edm__Wrapper_std__vector_GenZDecayProperties_s_ {
  public:
  __edm__Wrapper_std__vector_GenZDecayProperties_s_();
  bool present;
  ::std::vector<GenZDecayProperties> obj;
};
#ifdef __edm__Wrapper_GenZDecayProperties_
#undef __edm__Wrapper_GenZDecayProperties_
#endif
class __edm__Wrapper_GenZDecayProperties_ {
  public:
  __edm__Wrapper_GenZDecayProperties_();
  bool present;
  ::GenZDecayProperties obj;
};
#ifdef __edm__Wrapper_std__vector_JetProperties_s_
#undef __edm__Wrapper_std__vector_JetProperties_s_
#endif
class __edm__Wrapper_std__vector_JetProperties_s_ {
  public:
  __edm__Wrapper_std__vector_JetProperties_s_();
  bool present;
  ::std::vector<JetProperties> obj;
};
#ifdef __edm__Wrapper_JetProperties_
#undef __edm__Wrapper_JetProperties_
#endif
class __edm__Wrapper_JetProperties_ {
  public:
  __edm__Wrapper_JetProperties_();
  bool present;
  ::JetProperties obj;
};
#ifdef __edm__Wrapper_HiggsGenEvent_
#undef __edm__Wrapper_HiggsGenEvent_
#endif
class __edm__Wrapper_HiggsGenEvent_ {
  public:
  __edm__Wrapper_HiggsGenEvent_();
  bool present;
  ::HiggsGenEvent obj;
};
#ifdef __edm__RefProd_GenZDecayProperties_
#undef __edm__RefProd_GenZDecayProperties_
#endif
class __edm__RefProd_GenZDecayProperties_ {
  public:
  __edm__RefProd_GenZDecayProperties_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_JetProperties_
#undef __edm__RefProd_JetProperties_
#endif
class __edm__RefProd_JetProperties_ {
  public:
  __edm__RefProd_JetProperties_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_HiggsGenEvent_
#undef __edm__RefProd_HiggsGenEvent_
#endif
class __edm__RefProd_HiggsGenEvent_ {
  public:
  __edm__RefProd_HiggsGenEvent_();
  ::edm::RefCore product_;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class HiggsGenEvent -------------------------------
static  void operator_3163( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HiggsGenEvent*)o)->operator=)(*(const ::HiggsGenEvent*)arg[0]);
  else   (((::HiggsGenEvent*)o)->operator=)(*(const ::HiggsGenEvent*)arg[0]);
}

static void constructor_3164( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HiggsGenEvent(*(const ::HiggsGenEvent*)arg[0]);
  else ::new(mem) ::HiggsGenEvent(*(const ::HiggsGenEvent*)arg[0]);
}

static void constructor_3165( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HiggsGenEvent();
  else ::new(mem) ::HiggsGenEvent();
}

static void constructor_3166( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HiggsGenEvent(*(::reco::GenParticleRefProd*)arg[0]);
  else ::new(mem) ::HiggsGenEvent(*(::reco::GenParticleRefProd*)arg[0]);
}

static void destructor_3167(void*, void * o, const std::vector<void*>&, void *) {
(((::HiggsGenEvent*)o)->::HiggsGenEvent::~HiggsGenEvent)();
}
static  void method_3168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HiggsGenEvent*)o)->particles)();
  else   (((const ::HiggsGenEvent*)o)->particles)();
}

static  void method_3169( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (int)((((const ::HiggsGenEvent*)o)->numberOfBQuarks)());
    else     (((const ::HiggsGenEvent*)o)->numberOfBQuarks)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (int)((((const ::HiggsGenEvent*)o)->numberOfBQuarks)(*(bool*)arg[0]));
    else     (((const ::HiggsGenEvent*)o)->numberOfBQuarks)(*(bool*)arg[0]);
  }
}

static  void method_3170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<const reco::GenParticle*>)((((const ::HiggsGenEvent*)o)->higgsSisters)());
  else   (((const ::HiggsGenEvent*)o)->higgsSisters)();
}

static  void method_3171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HiggsGenEvent*)o)->candidate)(*(int*)arg[0]));
    else     (((const ::HiggsGenEvent*)o)->candidate)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HiggsGenEvent*)o)->candidate)(*(int*)arg[0],
      *(unsigned int*)arg[1]));
    else     (((const ::HiggsGenEvent*)o)->candidate)(*(int*)arg[0],
      *(unsigned int*)arg[1]);
  }
}

static  void method_3172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HiggsGenEvent*)o)->tauMinus)());
  else   (((const ::HiggsGenEvent*)o)->tauMinus)();
}

static  void method_3173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HiggsGenEvent*)o)->tauPlus)());
  else   (((const ::HiggsGenEvent*)o)->tauPlus)();
}

static  void method_3174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HiggsGenEvent*)o)->wMinus)());
  else   (((const ::HiggsGenEvent*)o)->wMinus)();
}

static  void method_3175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HiggsGenEvent*)o)->wPlus)());
  else   (((const ::HiggsGenEvent*)o)->wPlus)();
}

static  void method_3176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HiggsGenEvent*)o)->b)());
  else   (((const ::HiggsGenEvent*)o)->b)();
}

static  void method_3177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HiggsGenEvent*)o)->bBar)());
  else   (((const ::HiggsGenEvent*)o)->bBar)();
}

static  void method_3178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HiggsGenEvent*)o)->higgs)());
  else   (((const ::HiggsGenEvent*)o)->higgs)();
}

static  void method_3179( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::HiggsGenEvent*)o)->print)();
}

static void method_newdel_268( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HiggsGenEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HiggsGenEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HiggsGenEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HiggsGenEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HiggsGenEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HiggsGenEvent -------------------------------
void __HiggsGenEvent_db_datamem(Reflex::Class*);
void __HiggsGenEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HiggsGenEvent_datamem_bld(&__HiggsGenEvent_db_datamem);
Reflex::GenreflexMemberBuilder __HiggsGenEvent_funcmem_bld(&__HiggsGenEvent_db_funcmem);
void __HiggsGenEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HiggsGenEvent"), typeid(::HiggsGenEvent), sizeof(::HiggsGenEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12132, type_12133), Reflex::Literal("operator="), operator_3163, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12133), Reflex::Literal("HiggsGenEvent"), constructor_3164, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HiggsGenEvent"), constructor_3165, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12134), Reflex::Literal("HiggsGenEvent"), constructor_3166, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HiggsGenEvent"), destructor_3167, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_268, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HiggsGenEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HiggsGenEvent_funcmem_bld);
}

//------Delayed data member builder for class HiggsGenEvent -------------------
void __HiggsGenEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4463, Reflex::Literal("parts_"), OffsetOf(__shadow__::__HiggsGenEvent, parts_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HiggsGenEvent -------------------
void __HiggsGenEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12135), Reflex::Literal("particles"), method_3168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65, type_1310), Reflex::Literal("numberOfBQuarks"), method_3169, 0, "fromHiggs=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2532), Reflex::Literal("higgsSisters"), method_3170, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354, type_65, type_286), Reflex::Literal("candidate"), method_3171, 0, "id;parentId=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354), Reflex::Literal("tauMinus"), method_3172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354), Reflex::Literal("tauPlus"), method_3173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354), Reflex::Literal("wMinus"), method_3174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354), Reflex::Literal("wPlus"), method_3175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354), Reflex::Literal("b"), method_3176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354), Reflex::Literal("bBar"), method_3177, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354), Reflex::Literal("higgs"), method_3178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318), Reflex::Literal("print"), method_3179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class JetProperties -------------------------------
static void destructor_4209(void*, void * o, const std::vector<void*>&, void *) {
(((::JetProperties*)o)->::JetProperties::~JetProperties)();
}
static  void operator_4210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::JetProperties*)o)->operator=)(*(const ::JetProperties*)arg[0]);
  else   (((::JetProperties*)o)->operator=)(*(const ::JetProperties*)arg[0]);
}

static void constructor_4211( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JetProperties();
  else ::new(mem) ::JetProperties();
}

static void constructor_4212( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JetProperties(*(const double*)arg[0],
      *(const double*)arg[1],
      *(const int*)arg[2],
      *(const ::math::PtEtaPhiMLorentzVectorD*)arg[3],
      *(const ::std::vector<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)arg[4],
      *(const ::std::vector<int>*)arg[5]);
  else ::new(mem) ::JetProperties(*(const double*)arg[0],
      *(const double*)arg[1],
      *(const int*)arg[2],
      *(const ::math::PtEtaPhiMLorentzVectorD*)arg[3],
      *(const ::std::vector<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >*)arg[4],
      *(const ::std::vector<int>*)arg[5]);
}

static void constructor_4213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JetProperties(*(const ::JetProperties*)arg[0]);
  else ::new(mem) ::JetProperties(*(const ::JetProperties*)arg[0]);
}

static  void method_4214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::JetProperties*)o)->jetChargeGlobalPtWeighted)());
  else   (((const ::JetProperties*)o)->jetChargeGlobalPtWeighted)();
}

static  void method_4215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::JetProperties*)o)->jetChargeRelativePtWeighted)());
  else   (((const ::JetProperties*)o)->jetChargeRelativePtWeighted)();
}

static  void method_4216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::JetProperties*)o)->jetAssociatedPartonPdgId)());
  else   (((const ::JetProperties*)o)->jetAssociatedPartonPdgId)();
}

static  void method_4217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (math::PtEtaPhiMLorentzVectorD)((((const ::JetProperties*)o)->jetAssociatedParton)());
  else   (((const ::JetProperties*)o)->jetAssociatedParton)();
}

static  void method_4218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> > >)((((const ::JetProperties*)o)->jetTrack)());
  else   (((const ::JetProperties*)o)->jetTrack)();
}

static  void method_4219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<int>)((((const ::JetProperties*)o)->jetTrackCharge)());
  else   (((const ::JetProperties*)o)->jetTrackCharge)();
}

static void method_newdel_923( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::JetProperties >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::JetProperties >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::JetProperties >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::JetProperties >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::JetProperties >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class JetProperties -------------------------------
void __JetProperties_db_datamem(Reflex::Class*);
void __JetProperties_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __JetProperties_datamem_bld(&__JetProperties_db_datamem);
Reflex::GenreflexMemberBuilder __JetProperties_funcmem_bld(&__JetProperties_db_funcmem);
void __JetProperties_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("JetProperties"), typeid(::JetProperties), sizeof(::JetProperties), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~JetProperties"), destructor_4209, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8101, type_8103), Reflex::Literal("operator="), operator_4210, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("JetProperties"), constructor_4211, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16241, type_16241, type_5500, type_16242, type_16243, type_16244), Reflex::Literal("JetProperties"), constructor_4212, 0, "jetChargeGlobalPtWeighted;jetChargeRelativePtWeighted;jetAssociatedPartonPdgId;jetAssociatedParton;jetTrack;jetTrackCharge", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8103), Reflex::Literal("JetProperties"), constructor_4213, 0, "jetProperties", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_923, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__JetProperties_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__JetProperties_funcmem_bld);
}

//------Delayed data member builder for class JetProperties -------------------
void __JetProperties_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_94, Reflex::Literal("jetChargeGlobalPtWeighted_"), OffsetOf(__shadow__::__JetProperties, jetChargeGlobalPtWeighted_), ::Reflex::PRIVATE)
  .AddDataMember(type_94, Reflex::Literal("jetChargeRelativePtWeighted_"), OffsetOf(__shadow__::__JetProperties, jetChargeRelativePtWeighted_), ::Reflex::PRIVATE)
  .AddDataMember(type_65, Reflex::Literal("jetAssociatedPartonPdgId_"), OffsetOf(__shadow__::__JetProperties, jetAssociatedPartonPdgId_), ::Reflex::PRIVATE)
  .AddDataMember(type_4265, Reflex::Literal("jetAssociatedParton_"), OffsetOf(__shadow__::__JetProperties, jetAssociatedParton_), ::Reflex::PRIVATE)
  .AddDataMember(type_2531, Reflex::Literal("jetTrack_"), OffsetOf(__shadow__::__JetProperties, jetTrack_), ::Reflex::PRIVATE)
  .AddDataMember(type_2530, Reflex::Literal("jetTrackCharge_"), OffsetOf(__shadow__::__JetProperties, jetTrackCharge_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class JetProperties -------------------
void __JetProperties_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_94), Reflex::Literal("jetChargeGlobalPtWeighted"), method_4214, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_94), Reflex::Literal("jetChargeRelativePtWeighted"), method_4215, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65), Reflex::Literal("jetAssociatedPartonPdgId"), method_4216, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4265), Reflex::Literal("jetAssociatedParton"), method_4217, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2531), Reflex::Literal("jetTrack"), method_4218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2530), Reflex::Literal("jetTrackCharge"), method_4219, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class GenZDecayProperties -------------------------------
static  void operator_4447( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenZDecayProperties*)o)->operator=)(*(const ::GenZDecayProperties*)arg[0]);
  else   (((::GenZDecayProperties*)o)->operator=)(*(const ::GenZDecayProperties*)arg[0]);
}

static void constructor_4448( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenZDecayProperties(*(const ::GenZDecayProperties*)arg[0]);
  else ::new(mem) ::GenZDecayProperties(*(const ::GenZDecayProperties*)arg[0]);
}

static void constructor_4449( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenZDecayProperties();
  else ::new(mem) ::GenZDecayProperties();
}

static void constructor_4450( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenZDecayProperties((const ::reco::GenParticle*)arg[0],
      (const ::reco::GenParticle*)arg[1],
      (const ::reco::GenParticle*)arg[2],
      (const ::reco::GenParticle*)arg[3],
      (const ::reco::GenParticle*)arg[4],
      *(const int*)arg[5]);
  else ::new(mem) ::GenZDecayProperties((const ::reco::GenParticle*)arg[0],
      (const ::reco::GenParticle*)arg[1],
      (const ::reco::GenParticle*)arg[2],
      (const ::reco::GenParticle*)arg[3],
      (const ::reco::GenParticle*)arg[4],
      *(const int*)arg[5]);
}

static void destructor_4451(void*, void * o, const std::vector<void*>&, void *) {
(((::GenZDecayProperties*)o)->::GenZDecayProperties::~GenZDecayProperties)();
}
static  void method_4452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GenZDecayProperties*)o)->z)());
  else   (((const ::GenZDecayProperties*)o)->z)();
}

static  void method_4453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GenZDecayProperties*)o)->meDaughterParticle)());
  else   (((const ::GenZDecayProperties*)o)->meDaughterParticle)();
}

static  void method_4454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GenZDecayProperties*)o)->meDaughterAntiParticle)());
  else   (((const ::GenZDecayProperties*)o)->meDaughterAntiParticle)();
}

static  void method_4455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GenZDecayProperties*)o)->stableLepton)());
  else   (((const ::GenZDecayProperties*)o)->stableLepton)();
}

static  void method_4456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::GenZDecayProperties*)o)->stableAntiLepton)());
  else   (((const ::GenZDecayProperties*)o)->stableAntiLepton)();
}

static  void method_4457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::GenZDecayProperties*)o)->decayMode)());
  else   (((const ::GenZDecayProperties*)o)->decayMode)();
}

static  void method_4458( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::GenZDecayProperties*)o)->print)();
}

static void method_newdel_1577( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenZDecayProperties >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenZDecayProperties >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenZDecayProperties >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenZDecayProperties >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenZDecayProperties >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GenZDecayProperties -------------------------------
void __GenZDecayProperties_db_datamem(Reflex::Class*);
void __GenZDecayProperties_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenZDecayProperties_datamem_bld(&__GenZDecayProperties_db_datamem);
Reflex::GenreflexMemberBuilder __GenZDecayProperties_funcmem_bld(&__GenZDecayProperties_db_funcmem);
void __GenZDecayProperties_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenZDecayProperties"), typeid(::GenZDecayProperties), sizeof(::GenZDecayProperties), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8036, type_8038), Reflex::Literal("operator="), operator_4447, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8038), Reflex::Literal("GenZDecayProperties"), constructor_4448, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenZDecayProperties"), constructor_4449, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8354, type_8354, type_8354, type_8354, type_8354, type_65c), Reflex::Literal("GenZDecayProperties"), constructor_4450, 0, "z;meDaughterParticle;meDaughterAntiParticle;stableLepton;stableAntiLepton;decayMode", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenZDecayProperties"), destructor_4451, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1577, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenZDecayProperties_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenZDecayProperties_funcmem_bld);
}

//------Delayed data member builder for class GenZDecayProperties -------------------
void __GenZDecayProperties_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8354, Reflex::Literal("z_"), OffsetOf(__shadow__::__GenZDecayProperties, z_), ::Reflex::PRIVATE)
  .AddDataMember(type_8354, Reflex::Literal("meDaughterParticle_"), OffsetOf(__shadow__::__GenZDecayProperties, meDaughterParticle_), ::Reflex::PRIVATE)
  .AddDataMember(type_8354, Reflex::Literal("meDaughterAntiParticle_"), OffsetOf(__shadow__::__GenZDecayProperties, meDaughterAntiParticle_), ::Reflex::PRIVATE)
  .AddDataMember(type_8354, Reflex::Literal("stableLepton_"), OffsetOf(__shadow__::__GenZDecayProperties, stableLepton_), ::Reflex::PRIVATE)
  .AddDataMember(type_8354, Reflex::Literal("stableAntiLepton_"), OffsetOf(__shadow__::__GenZDecayProperties, stableAntiLepton_), ::Reflex::PRIVATE)
  .AddDataMember(type_65, Reflex::Literal("decayMode_"), OffsetOf(__shadow__::__GenZDecayProperties, decayMode_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GenZDecayProperties -------------------
void __GenZDecayProperties_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354), Reflex::Literal("z"), method_4452, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354), Reflex::Literal("meDaughterParticle"), method_4453, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354), Reflex::Literal("meDaughterAntiParticle"), method_4454, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354), Reflex::Literal("stableLepton"), method_4455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8354), Reflex::Literal("stableAntiLepton"), method_4456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_65), Reflex::Literal("decayMode"), method_4457, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318), Reflex::Literal("print"), method_4458, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<GenZDecayProperties,std::allocator<GenZDecayProperties> > -------------------------------
static void constructor_8047( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenZDecayProperties>();
  else ::new(mem) ::std::vector<GenZDecayProperties>();
}

static void constructor_8048( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenZDecayProperties>(*(const ::std::allocator<GenZDecayProperties>*)arg[0]);
  else ::new(mem) ::std::vector<GenZDecayProperties>(*(const ::std::allocator<GenZDecayProperties>*)arg[0]);
}

static void constructor_8049( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenZDecayProperties>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<GenZDecayProperties>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenZDecayProperties>(*(::std::size_t*)arg[0],
      *(const ::GenZDecayProperties*)arg[1]);
  else ::new(mem) ::std::vector<GenZDecayProperties>(*(::std::size_t*)arg[0],
      *(const ::GenZDecayProperties*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenZDecayProperties>(*(::std::size_t*)arg[0],
      *(const ::GenZDecayProperties*)arg[1],
      *(const ::std::allocator<GenZDecayProperties>*)arg[2]);
  else ::new(mem) ::std::vector<GenZDecayProperties>(*(::std::size_t*)arg[0],
      *(const ::GenZDecayProperties*)arg[1],
      *(const ::std::allocator<GenZDecayProperties>*)arg[2]);
  }
}

static void constructor_8050( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenZDecayProperties>(*(const ::std::vector<GenZDecayProperties>*)arg[0]);
  else ::new(mem) ::std::vector<GenZDecayProperties>(*(const ::std::vector<GenZDecayProperties>*)arg[0]);
}

static void destructor_8051(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<GenZDecayProperties>*)o)->::std::vector<GenZDecayProperties>::~vector)();
}
static  void operator_8052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenZDecayProperties>*)o)->operator=)(*(const ::std::vector<GenZDecayProperties>*)arg[0]);
  else   (((::std::vector<GenZDecayProperties>*)o)->operator=)(*(const ::std::vector<GenZDecayProperties>*)arg[0]);
}

static  void method_8053( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenZDecayProperties>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::GenZDecayProperties*)arg[1]);
}

static  void method_8054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >)((((::std::vector<GenZDecayProperties>*)o)->begin)());
  else   (((::std::vector<GenZDecayProperties>*)o)->begin)();
}

static  void method_8055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const GenZDecayProperties*,std::vector<GenZDecayProperties> >)((((const ::std::vector<GenZDecayProperties>*)o)->begin)());
  else   (((const ::std::vector<GenZDecayProperties>*)o)->begin)();
}

static  void method_8056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >)((((::std::vector<GenZDecayProperties>*)o)->end)());
  else   (((::std::vector<GenZDecayProperties>*)o)->end)();
}

static  void method_8057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const GenZDecayProperties*,std::vector<GenZDecayProperties> >)((((const ::std::vector<GenZDecayProperties>*)o)->end)());
  else   (((const ::std::vector<GenZDecayProperties>*)o)->end)();
}

static  void method_8062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GenZDecayProperties>*)o)->size)());
  else   (((const ::std::vector<GenZDecayProperties>*)o)->size)();
}

static  void method_8063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GenZDecayProperties>*)o)->max_size)());
  else   (((const ::std::vector<GenZDecayProperties>*)o)->max_size)();
}

static  void method_8064( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<GenZDecayProperties>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<GenZDecayProperties>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::GenZDecayProperties*)arg[1]);
  }
}

static  void method_8065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GenZDecayProperties>*)o)->capacity)());
  else   (((const ::std::vector<GenZDecayProperties>*)o)->capacity)();
}

static  void method_8066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<GenZDecayProperties>*)o)->empty)());
  else   (((const ::std::vector<GenZDecayProperties>*)o)->empty)();
}

static  void method_8067( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenZDecayProperties>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenZDecayProperties>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<GenZDecayProperties>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenZDecayProperties>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<GenZDecayProperties>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenZDecayProperties>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<GenZDecayProperties>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenZDecayProperties>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<GenZDecayProperties>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenZDecayProperties>*)o)->front)();
  else   (((::std::vector<GenZDecayProperties>*)o)->front)();
}

static  void method_8074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenZDecayProperties>*)o)->front)();
  else   (((const ::std::vector<GenZDecayProperties>*)o)->front)();
}

static  void method_8075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenZDecayProperties>*)o)->back)();
  else   (((::std::vector<GenZDecayProperties>*)o)->back)();
}

static  void method_8076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenZDecayProperties>*)o)->back)();
  else   (((const ::std::vector<GenZDecayProperties>*)o)->back)();
}

static  void method_8077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<GenZDecayProperties>*)o)->data)());
  else   (((::std::vector<GenZDecayProperties>*)o)->data)();
}

static  void method_8078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<GenZDecayProperties>*)o)->data)());
  else   (((const ::std::vector<GenZDecayProperties>*)o)->data)();
}

static  void method_8079( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenZDecayProperties>*)o)->push_back)(*(const ::GenZDecayProperties*)arg[0]);
}

static  void method_8080( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<GenZDecayProperties>*)o)->pop_back)();
}

static  void method_8081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >)((((::std::vector<GenZDecayProperties>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >*)arg[0],
    *(const ::GenZDecayProperties*)arg[1]));
  else   (((::std::vector<GenZDecayProperties>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >*)arg[0],
    *(const ::GenZDecayProperties*)arg[1]);
}

static  void method_8082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenZDecayProperties>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::GenZDecayProperties*)arg[2]);
}

static  void method_8083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >)((((::std::vector<GenZDecayProperties>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >*)arg[0]));
  else   (((::std::vector<GenZDecayProperties>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >*)arg[0]);
}

static  void method_8084( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >)((((::std::vector<GenZDecayProperties>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >*)arg[1]));
  else   (((::std::vector<GenZDecayProperties>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<GenZDecayProperties*,std::vector<GenZDecayProperties> >*)arg[1]);
}

static  void method_8085( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenZDecayProperties>*)o)->swap)(*(::std::vector<GenZDecayProperties>*)arg[0]);
}

static  void method_8086( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<GenZDecayProperties>*)o)->clear)();
}

static void method_newdel_2528( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<GenZDecayProperties> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<GenZDecayProperties> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<GenZDecayProperties> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<GenZDecayProperties> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<GenZDecayProperties> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<GenZDecayProperties,std::allocator<GenZDecayProperties> >")), ::Reflex::BaseOffset< ::std::vector<GenZDecayProperties>,::std::_Vector_base<GenZDecayProperties,std::allocator<GenZDecayProperties> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<GenZDecayProperties> >::Generate();
  else ::Reflex::Proxy< ::std::vector<GenZDecayProperties> >::Generate();
}

//------Dictionary for class vector<GenZDecayProperties,std::allocator<GenZDecayProperties> > -------------------------------
void __std__vector_GenZDecayProperties__db_datamem(Reflex::Class*);
void __std__vector_GenZDecayProperties__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_GenZDecayProperties__datamem_bld(&__std__vector_GenZDecayProperties__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_GenZDecayProperties__funcmem_bld(&__std__vector_GenZDecayProperties__db_funcmem);
void __std__vector_GenZDecayProperties__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<GenZDecayProperties>"), typeid(::std::vector<GenZDecayProperties>), sizeof(::std::vector<GenZDecayProperties>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2070, ::Reflex::BaseOffset< ::std::vector<GenZDecayProperties>, ::std::_Vector_base<GenZDecayProperties,std::allocator<GenZDecayProperties> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1577, Reflex::Literal("std::vector<GenZDecayProperties>::_Alloc_value_type"))
  .AddTypedef(type_2070, Reflex::Literal("std::vector<GenZDecayProperties>::_Base"))
  .AddTypedef(type_2759, Reflex::Literal("std::vector<GenZDecayProperties>::_Tp_alloc_type"))
  .AddTypedef(type_1577, Reflex::Literal("std::vector<GenZDecayProperties>::value_type"))
  .AddTypedef(type_8032, Reflex::Literal("std::vector<GenZDecayProperties>::pointer"))
  .AddTypedef(type_8034, Reflex::Literal("std::vector<GenZDecayProperties>::const_pointer"))
  .AddTypedef(type_8036, Reflex::Literal("std::vector<GenZDecayProperties>::reference"))
  .AddTypedef(type_8038, Reflex::Literal("std::vector<GenZDecayProperties>::const_reference"))
  .AddTypedef(type_4506, Reflex::Literal("std::vector<GenZDecayProperties>::iterator"))
  .AddTypedef(type_4507, Reflex::Literal("std::vector<GenZDecayProperties>::const_iterator"))
  .AddTypedef(type_2871, Reflex::Literal("std::vector<GenZDecayProperties>::const_reverse_iterator"))
  .AddTypedef(type_2872, Reflex::Literal("std::vector<GenZDecayProperties>::reverse_iterator"))
  .AddTypedef(type_2745, Reflex::Literal("std::vector<GenZDecayProperties>::size_type"))
  .AddTypedef(type_2637, Reflex::Literal("std::vector<GenZDecayProperties>::difference_type"))
  .AddTypedef(type_2759, Reflex::Literal("std::vector<GenZDecayProperties>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8047, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19504), Reflex::Literal("vector"), constructor_8048, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2745, type_8038, type_19504), Reflex::Literal("vector"), constructor_8049, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20278), Reflex::Literal("vector"), constructor_8050, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8051, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2528, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_GenZDecayProperties__funcmem_bld);
}

//------Delayed data member builder for class vector<GenZDecayProperties,std::allocator<GenZDecayProperties> > -------------------
void __std__vector_GenZDecayProperties__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<GenZDecayProperties,std::allocator<GenZDecayProperties> > -------------------
void __std__vector_GenZDecayProperties__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20279, type_20278), Reflex::Literal("operator="), operator_8052, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_2745, type_8038), Reflex::Literal("assign"), method_8053, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4506), Reflex::Literal("begin"), method_8054, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4507), Reflex::Literal("begin"), method_8055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4506), Reflex::Literal("end"), method_8056, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4507), Reflex::Literal("end"), method_8057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2745), Reflex::Literal("size"), method_8062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2745), Reflex::Literal("max_size"), method_8063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_2745, type_1577), Reflex::Literal("resize"), method_8064, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2745), Reflex::Literal("capacity"), method_8065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("empty"), method_8066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_2745), Reflex::Literal("reserve"), method_8067, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8036, type_2745), Reflex::Literal("operator[]"), operator_8068, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8038, type_2745), Reflex::Literal("operator[]"), operator_8069, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8036, type_2745), Reflex::Literal("at"), method_8071, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8038, type_2745), Reflex::Literal("at"), method_8072, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8036), Reflex::Literal("front"), method_8073, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8038), Reflex::Literal("front"), method_8074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8036), Reflex::Literal("back"), method_8075, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8038), Reflex::Literal("back"), method_8076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8032), Reflex::Literal("data"), method_8077, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8034), Reflex::Literal("data"), method_8078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_8038), Reflex::Literal("push_back"), method_8079, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318), Reflex::Literal("pop_back"), method_8080, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4506, type_4506, type_8038), Reflex::Literal("insert"), method_8081, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_4506, type_2745, type_8038), Reflex::Literal("insert"), method_8082, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4506, type_4506), Reflex::Literal("erase"), method_8083, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4506, type_4506, type_4506), Reflex::Literal("erase"), method_8084, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_20279), Reflex::Literal("swap"), method_8085, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318), Reflex::Literal("clear"), method_8086, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<JetProperties,std::allocator<JetProperties> > -------------------------------
static void constructor_8112( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JetProperties>();
  else ::new(mem) ::std::vector<JetProperties>();
}

static void constructor_8113( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JetProperties>(*(const ::std::allocator<JetProperties>*)arg[0]);
  else ::new(mem) ::std::vector<JetProperties>(*(const ::std::allocator<JetProperties>*)arg[0]);
}

static void constructor_8114( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JetProperties>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<JetProperties>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JetProperties>(*(::std::size_t*)arg[0],
      *(const ::JetProperties*)arg[1]);
  else ::new(mem) ::std::vector<JetProperties>(*(::std::size_t*)arg[0],
      *(const ::JetProperties*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JetProperties>(*(::std::size_t*)arg[0],
      *(const ::JetProperties*)arg[1],
      *(const ::std::allocator<JetProperties>*)arg[2]);
  else ::new(mem) ::std::vector<JetProperties>(*(::std::size_t*)arg[0],
      *(const ::JetProperties*)arg[1],
      *(const ::std::allocator<JetProperties>*)arg[2]);
  }
}

static void constructor_8115( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JetProperties>(*(const ::std::vector<JetProperties>*)arg[0]);
  else ::new(mem) ::std::vector<JetProperties>(*(const ::std::vector<JetProperties>*)arg[0]);
}

static void destructor_8116(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<JetProperties>*)o)->::std::vector<JetProperties>::~vector)();
}
static  void operator_8117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JetProperties>*)o)->operator=)(*(const ::std::vector<JetProperties>*)arg[0]);
  else   (((::std::vector<JetProperties>*)o)->operator=)(*(const ::std::vector<JetProperties>*)arg[0]);
}

static  void method_8118( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JetProperties>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::JetProperties*)arg[1]);
}

static  void method_8119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >)((((::std::vector<JetProperties>*)o)->begin)());
  else   (((::std::vector<JetProperties>*)o)->begin)();
}

static  void method_8120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const JetProperties*,std::vector<JetProperties> >)((((const ::std::vector<JetProperties>*)o)->begin)());
  else   (((const ::std::vector<JetProperties>*)o)->begin)();
}

static  void method_8121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >)((((::std::vector<JetProperties>*)o)->end)());
  else   (((::std::vector<JetProperties>*)o)->end)();
}

static  void method_8122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const JetProperties*,std::vector<JetProperties> >)((((const ::std::vector<JetProperties>*)o)->end)());
  else   (((const ::std::vector<JetProperties>*)o)->end)();
}

static  void method_8127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<JetProperties>*)o)->size)());
  else   (((const ::std::vector<JetProperties>*)o)->size)();
}

static  void method_8128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<JetProperties>*)o)->max_size)());
  else   (((const ::std::vector<JetProperties>*)o)->max_size)();
}

static  void method_8129( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<JetProperties>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<JetProperties>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::JetProperties*)arg[1]);
  }
}

static  void method_8130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<JetProperties>*)o)->capacity)());
  else   (((const ::std::vector<JetProperties>*)o)->capacity)();
}

static  void method_8131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<JetProperties>*)o)->empty)());
  else   (((const ::std::vector<JetProperties>*)o)->empty)();
}

static  void method_8132( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JetProperties>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JetProperties>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<JetProperties>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<JetProperties>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<JetProperties>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JetProperties>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<JetProperties>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<JetProperties>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<JetProperties>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JetProperties>*)o)->front)();
  else   (((::std::vector<JetProperties>*)o)->front)();
}

static  void method_8139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<JetProperties>*)o)->front)();
  else   (((const ::std::vector<JetProperties>*)o)->front)();
}

static  void method_8140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JetProperties>*)o)->back)();
  else   (((::std::vector<JetProperties>*)o)->back)();
}

static  void method_8141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<JetProperties>*)o)->back)();
  else   (((const ::std::vector<JetProperties>*)o)->back)();
}

static  void method_8142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<JetProperties>*)o)->data)());
  else   (((::std::vector<JetProperties>*)o)->data)();
}

static  void method_8143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<JetProperties>*)o)->data)());
  else   (((const ::std::vector<JetProperties>*)o)->data)();
}

static  void method_8144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JetProperties>*)o)->push_back)(*(const ::JetProperties*)arg[0]);
}

static  void method_8145( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<JetProperties>*)o)->pop_back)();
}

static  void method_8146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >)((((::std::vector<JetProperties>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >*)arg[0],
    *(const ::JetProperties*)arg[1]));
  else   (((::std::vector<JetProperties>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >*)arg[0],
    *(const ::JetProperties*)arg[1]);
}

static  void method_8147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JetProperties>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::JetProperties*)arg[2]);
}

static  void method_8148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >)((((::std::vector<JetProperties>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >*)arg[0]));
  else   (((::std::vector<JetProperties>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >*)arg[0]);
}

static  void method_8149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >)((((::std::vector<JetProperties>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >*)arg[1]));
  else   (((::std::vector<JetProperties>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<JetProperties*,std::vector<JetProperties> >*)arg[1]);
}

static  void method_8150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JetProperties>*)o)->swap)(*(::std::vector<JetProperties>*)arg[0]);
}

static  void method_8151( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<JetProperties>*)o)->clear)();
}

static void method_newdel_2529( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<JetProperties> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<JetProperties> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<JetProperties> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<JetProperties> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<JetProperties> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<JetProperties,std::allocator<JetProperties> >")), ::Reflex::BaseOffset< ::std::vector<JetProperties>,::std::_Vector_base<JetProperties,std::allocator<JetProperties> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<JetProperties> >::Generate();
  else ::Reflex::Proxy< ::std::vector<JetProperties> >::Generate();
}

//------Dictionary for class vector<JetProperties,std::allocator<JetProperties> > -------------------------------
void __std__vector_JetProperties__db_datamem(Reflex::Class*);
void __std__vector_JetProperties__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_JetProperties__datamem_bld(&__std__vector_JetProperties__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_JetProperties__funcmem_bld(&__std__vector_JetProperties__db_funcmem);
void __std__vector_JetProperties__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<JetProperties>"), typeid(::std::vector<JetProperties>), sizeof(::std::vector<JetProperties>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2071, ::Reflex::BaseOffset< ::std::vector<JetProperties>, ::std::_Vector_base<JetProperties,std::allocator<JetProperties> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_923, Reflex::Literal("std::vector<JetProperties>::_Alloc_value_type"))
  .AddTypedef(type_2071, Reflex::Literal("std::vector<JetProperties>::_Base"))
  .AddTypedef(type_2760, Reflex::Literal("std::vector<JetProperties>::_Tp_alloc_type"))
  .AddTypedef(type_923, Reflex::Literal("std::vector<JetProperties>::value_type"))
  .AddTypedef(type_8097, Reflex::Literal("std::vector<JetProperties>::pointer"))
  .AddTypedef(type_8099, Reflex::Literal("std::vector<JetProperties>::const_pointer"))
  .AddTypedef(type_8101, Reflex::Literal("std::vector<JetProperties>::reference"))
  .AddTypedef(type_8103, Reflex::Literal("std::vector<JetProperties>::const_reference"))
  .AddTypedef(type_4508, Reflex::Literal("std::vector<JetProperties>::iterator"))
  .AddTypedef(type_4509, Reflex::Literal("std::vector<JetProperties>::const_iterator"))
  .AddTypedef(type_2873, Reflex::Literal("std::vector<JetProperties>::const_reverse_iterator"))
  .AddTypedef(type_2874, Reflex::Literal("std::vector<JetProperties>::reverse_iterator"))
  .AddTypedef(type_2745, Reflex::Literal("std::vector<JetProperties>::size_type"))
  .AddTypedef(type_2637, Reflex::Literal("std::vector<JetProperties>::difference_type"))
  .AddTypedef(type_2760, Reflex::Literal("std::vector<JetProperties>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8112, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19516), Reflex::Literal("vector"), constructor_8113, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2745, type_8103, type_19516), Reflex::Literal("vector"), constructor_8114, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20281), Reflex::Literal("vector"), constructor_8115, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8116, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2529, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_JetProperties__funcmem_bld);
}

//------Delayed data member builder for class vector<JetProperties,std::allocator<JetProperties> > -------------------
void __std__vector_JetProperties__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<JetProperties,std::allocator<JetProperties> > -------------------
void __std__vector_JetProperties__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20282, type_20281), Reflex::Literal("operator="), operator_8117, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_2745, type_8103), Reflex::Literal("assign"), method_8118, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4508), Reflex::Literal("begin"), method_8119, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4509), Reflex::Literal("begin"), method_8120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4508), Reflex::Literal("end"), method_8121, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4509), Reflex::Literal("end"), method_8122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2745), Reflex::Literal("size"), method_8127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2745), Reflex::Literal("max_size"), method_8128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_2745, type_923), Reflex::Literal("resize"), method_8129, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2745), Reflex::Literal("capacity"), method_8130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("empty"), method_8131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_2745), Reflex::Literal("reserve"), method_8132, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8101, type_2745), Reflex::Literal("operator[]"), operator_8133, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8103, type_2745), Reflex::Literal("operator[]"), operator_8134, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8101, type_2745), Reflex::Literal("at"), method_8136, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8103, type_2745), Reflex::Literal("at"), method_8137, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8101), Reflex::Literal("front"), method_8138, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8103), Reflex::Literal("front"), method_8139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8101), Reflex::Literal("back"), method_8140, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8103), Reflex::Literal("back"), method_8141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8097), Reflex::Literal("data"), method_8142, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8099), Reflex::Literal("data"), method_8143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_8103), Reflex::Literal("push_back"), method_8144, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318), Reflex::Literal("pop_back"), method_8145, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4508, type_4508, type_8103), Reflex::Literal("insert"), method_8146, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_4508, type_2745, type_8103), Reflex::Literal("insert"), method_8147, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4508, type_4508), Reflex::Literal("erase"), method_8148, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4508, type_4508, type_4508), Reflex::Literal("erase"), method_8149, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_20282), Reflex::Literal("swap"), method_8150, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318), Reflex::Literal("clear"), method_8151, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<std::vector<GenZDecayProperties, std::allocator<GenZDecayProperties> > > -------------------------------
static void constructor_12271( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<GenZDecayProperties> >();
  else ::new(mem) ::edm::Wrapper<std::vector<GenZDecayProperties> >();
}

static void constructor_12272( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<GenZDecayProperties> >(*(::std::auto_ptr<std::vector<GenZDecayProperties> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<GenZDecayProperties> >(*(::std::auto_ptr<std::vector<GenZDecayProperties> >*)arg[0]);
}

static void destructor_12273(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->::edm::Wrapper<std::vector<GenZDecayProperties> >::~Wrapper)();
}
static  void method_12274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->product)();
}

static  void operator_12275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->operator->)();
}

static  void method_12276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->productTypeInfo)();
}

static  void method_12277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->typeInfo)();
}

static void constructor_12278( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<GenZDecayProperties> >((::std::vector<GenZDecayProperties>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<GenZDecayProperties> >((::std::vector<GenZDecayProperties>*)arg[0]);
}

static  void method_12279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->getInterface)();
}

static  void method_12280( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12281( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12282( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->dynamicTypeInfo)();
}

static  void method_12284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->isPresent)();
}

static  void method_12285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<GenZDecayProperties> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3216( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<GenZDecayProperties> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<GenZDecayProperties> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<GenZDecayProperties> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<GenZDecayProperties> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<GenZDecayProperties> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<GenZDecayProperties, std::allocator<GenZDecayProperties> > > -------------------------------
void __edm__Wrapper_std__vector_GenZDecayProperties_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_GenZDecayProperties_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_GenZDecayProperties_s__datamem_bld(&__edm__Wrapper_std__vector_GenZDecayProperties_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_GenZDecayProperties_s__funcmem_bld(&__edm__Wrapper_std__vector_GenZDecayProperties_s__db_funcmem);
void __edm__Wrapper_std__vector_GenZDecayProperties_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<GenZDecayProperties> >"), typeid(::edm::Wrapper<std::vector<GenZDecayProperties> >), sizeof(::edm::Wrapper<std::vector<GenZDecayProperties> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2528, Reflex::Literal("edm::Wrapper<std::vector<GenZDecayProperties> >::value_type"))
  .AddTypedef(type_2528, Reflex::Literal("edm::Wrapper<std::vector<GenZDecayProperties> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12271, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2304), Reflex::Literal("Wrapper"), constructor_12272, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12273, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20840), Reflex::Literal("Wrapper"), constructor_12278, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3216, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_GenZDecayProperties_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_GenZDecayProperties_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<GenZDecayProperties, std::allocator<GenZDecayProperties> > > -------------------
void __edm__Wrapper_std__vector_GenZDecayProperties_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1310, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_GenZDecayProperties_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2528, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_GenZDecayProperties_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<GenZDecayProperties, std::allocator<GenZDecayProperties> > > -------------------
void __edm__Wrapper_std__vector_GenZDecayProperties_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20839), Reflex::Literal("product"), method_12274, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20839), Reflex::Literal("operator->"), operator_12275, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("productTypeInfo"), method_12276, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("typeInfo"), method_12277, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20841), Reflex::Literal("getInterface"), method_12279, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_12053, type_20274, type_20842), Reflex::Literal("fillView"), method_12280, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_3194, type_277, type_5511), Reflex::Literal("setPtr"), method_12281, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_3194, type_20275, type_20274), Reflex::Literal("fillPtrVector"), method_12282, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("dynamicTypeInfo"), method_12283, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isPresent"), method_12284, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("dynamicTypeInfo_"), method_12285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<GenZDecayProperties> -------------------------------
static void constructor_12292( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenZDecayProperties>();
  else ::new(mem) ::edm::Wrapper<GenZDecayProperties>();
}

static void constructor_12293( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenZDecayProperties>(*(::std::auto_ptr<GenZDecayProperties>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<GenZDecayProperties>(*(::std::auto_ptr<GenZDecayProperties>*)arg[0]);
}

static void destructor_12294(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<GenZDecayProperties>*)o)->::edm::Wrapper<GenZDecayProperties>::~Wrapper)();
}
static  void method_12295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<GenZDecayProperties>*)o)->product)());
  else   (((const ::edm::Wrapper<GenZDecayProperties>*)o)->product)();
}

static  void operator_12296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<GenZDecayProperties>*)o)->operator->)());
  else   (((const ::edm::Wrapper<GenZDecayProperties>*)o)->operator->)();
}

static  void method_12297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<GenZDecayProperties>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<GenZDecayProperties>*)o)->productTypeInfo)();
}

static  void method_12298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<GenZDecayProperties>*)o)->typeInfo)();
  else   (((::edm::Wrapper<GenZDecayProperties>*)o)->typeInfo)();
}

static void constructor_12299( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<GenZDecayProperties>((::GenZDecayProperties*)arg[0]);
  else ::new(mem) ::edm::Wrapper<GenZDecayProperties>((::GenZDecayProperties*)arg[0]);
}

static  void method_12300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<GenZDecayProperties>*)o)->getInterface)());
  else   (((::edm::Wrapper<GenZDecayProperties>*)o)->getInterface)();
}

static  void method_12301( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenZDecayProperties>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12302( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenZDecayProperties>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12303( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<GenZDecayProperties>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<GenZDecayProperties>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<GenZDecayProperties>*)o)->dynamicTypeInfo)();
}

static  void method_12305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<GenZDecayProperties>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<GenZDecayProperties>*)o)->isPresent)();
}

static  void method_12306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<GenZDecayProperties>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<GenZDecayProperties>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3217( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenZDecayProperties> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenZDecayProperties> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenZDecayProperties> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenZDecayProperties> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<GenZDecayProperties> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<GenZDecayProperties> -------------------------------
void __edm__Wrapper_GenZDecayProperties__db_datamem(Reflex::Class*);
void __edm__Wrapper_GenZDecayProperties__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_GenZDecayProperties__datamem_bld(&__edm__Wrapper_GenZDecayProperties__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_GenZDecayProperties__funcmem_bld(&__edm__Wrapper_GenZDecayProperties__db_funcmem);
void __edm__Wrapper_GenZDecayProperties__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<GenZDecayProperties>"), typeid(::edm::Wrapper<GenZDecayProperties>), sizeof(::edm::Wrapper<GenZDecayProperties>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1577, Reflex::Literal("edm::Wrapper<GenZDecayProperties>::value_type"))
  .AddTypedef(type_1577, Reflex::Literal("edm::Wrapper<GenZDecayProperties>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12292, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2305), Reflex::Literal("Wrapper"), constructor_12293, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12294, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8032), Reflex::Literal("Wrapper"), constructor_12299, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3217, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_GenZDecayProperties__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_GenZDecayProperties__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<GenZDecayProperties> -------------------
void __edm__Wrapper_GenZDecayProperties__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1310, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_GenZDecayProperties_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1577, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_GenZDecayProperties_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<GenZDecayProperties> -------------------
void __edm__Wrapper_GenZDecayProperties__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8034), Reflex::Literal("product"), method_12295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8034), Reflex::Literal("operator->"), operator_12296, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("productTypeInfo"), method_12297, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("typeInfo"), method_12298, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20845), Reflex::Literal("getInterface"), method_12300, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_12053, type_20274, type_20842), Reflex::Literal("fillView"), method_12301, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_3194, type_277, type_5511), Reflex::Literal("setPtr"), method_12302, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_3194, type_20275, type_20274), Reflex::Literal("fillPtrVector"), method_12303, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("dynamicTypeInfo"), method_12304, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isPresent"), method_12305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("dynamicTypeInfo_"), method_12306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<JetProperties, std::allocator<JetProperties> > > -------------------------------
static void constructor_12313( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<JetProperties> >();
  else ::new(mem) ::edm::Wrapper<std::vector<JetProperties> >();
}

static void constructor_12314( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<JetProperties> >(*(::std::auto_ptr<std::vector<JetProperties> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<JetProperties> >(*(::std::auto_ptr<std::vector<JetProperties> >*)arg[0]);
}

static void destructor_12315(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<JetProperties> >*)o)->::edm::Wrapper<std::vector<JetProperties> >::~Wrapper)();
}
static  void method_12316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->product)();
}

static  void operator_12317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->operator->)();
}

static  void method_12318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<JetProperties> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<JetProperties> >*)o)->productTypeInfo)();
}

static  void method_12319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<JetProperties> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<JetProperties> >*)o)->typeInfo)();
}

static void constructor_12320( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<JetProperties> >((::std::vector<JetProperties>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<JetProperties> >((::std::vector<JetProperties>*)arg[0]);
}

static  void method_12321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<JetProperties> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<JetProperties> >*)o)->getInterface)();
}

static  void method_12322( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12323( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12324( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->dynamicTypeInfo)();
}

static  void method_12326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->isPresent)();
}

static  void method_12327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<JetProperties> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3218( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<JetProperties> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<JetProperties> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<JetProperties> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<JetProperties> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<JetProperties> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<JetProperties, std::allocator<JetProperties> > > -------------------------------
void __edm__Wrapper_std__vector_JetProperties_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_JetProperties_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_JetProperties_s__datamem_bld(&__edm__Wrapper_std__vector_JetProperties_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_JetProperties_s__funcmem_bld(&__edm__Wrapper_std__vector_JetProperties_s__db_funcmem);
void __edm__Wrapper_std__vector_JetProperties_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<JetProperties> >"), typeid(::edm::Wrapper<std::vector<JetProperties> >), sizeof(::edm::Wrapper<std::vector<JetProperties> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2529, Reflex::Literal("edm::Wrapper<std::vector<JetProperties> >::value_type"))
  .AddTypedef(type_2529, Reflex::Literal("edm::Wrapper<std::vector<JetProperties> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12313, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2306), Reflex::Literal("Wrapper"), constructor_12314, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12315, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20849), Reflex::Literal("Wrapper"), constructor_12320, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3218, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_JetProperties_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_JetProperties_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<JetProperties, std::allocator<JetProperties> > > -------------------
void __edm__Wrapper_std__vector_JetProperties_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1310, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_JetProperties_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2529, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_JetProperties_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<JetProperties, std::allocator<JetProperties> > > -------------------
void __edm__Wrapper_std__vector_JetProperties_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20848), Reflex::Literal("product"), method_12316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20848), Reflex::Literal("operator->"), operator_12317, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("productTypeInfo"), method_12318, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("typeInfo"), method_12319, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20850), Reflex::Literal("getInterface"), method_12321, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_12053, type_20274, type_20842), Reflex::Literal("fillView"), method_12322, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_3194, type_277, type_5511), Reflex::Literal("setPtr"), method_12323, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_3194, type_20275, type_20274), Reflex::Literal("fillPtrVector"), method_12324, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("dynamicTypeInfo"), method_12325, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isPresent"), method_12326, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("dynamicTypeInfo_"), method_12327, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<JetProperties> -------------------------------
static void constructor_12334( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<JetProperties>();
  else ::new(mem) ::edm::Wrapper<JetProperties>();
}

static void constructor_12335( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<JetProperties>(*(::std::auto_ptr<JetProperties>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<JetProperties>(*(::std::auto_ptr<JetProperties>*)arg[0]);
}

static void destructor_12336(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<JetProperties>*)o)->::edm::Wrapper<JetProperties>::~Wrapper)();
}
static  void method_12337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<JetProperties>*)o)->product)());
  else   (((const ::edm::Wrapper<JetProperties>*)o)->product)();
}

static  void operator_12338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<JetProperties>*)o)->operator->)());
  else   (((const ::edm::Wrapper<JetProperties>*)o)->operator->)();
}

static  void method_12339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<JetProperties>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<JetProperties>*)o)->productTypeInfo)();
}

static  void method_12340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<JetProperties>*)o)->typeInfo)();
  else   (((::edm::Wrapper<JetProperties>*)o)->typeInfo)();
}

static void constructor_12341( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<JetProperties>((::JetProperties*)arg[0]);
  else ::new(mem) ::edm::Wrapper<JetProperties>((::JetProperties*)arg[0]);
}

static  void method_12342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<JetProperties>*)o)->getInterface)());
  else   (((::edm::Wrapper<JetProperties>*)o)->getInterface)();
}

static  void method_12343( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<JetProperties>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12344( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<JetProperties>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12345( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<JetProperties>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<JetProperties>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<JetProperties>*)o)->dynamicTypeInfo)();
}

static  void method_12347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<JetProperties>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<JetProperties>*)o)->isPresent)();
}

static  void method_12348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<JetProperties>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<JetProperties>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3219( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<JetProperties> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<JetProperties> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<JetProperties> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<JetProperties> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<JetProperties> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<JetProperties> -------------------------------
void __edm__Wrapper_JetProperties__db_datamem(Reflex::Class*);
void __edm__Wrapper_JetProperties__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_JetProperties__datamem_bld(&__edm__Wrapper_JetProperties__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_JetProperties__funcmem_bld(&__edm__Wrapper_JetProperties__db_funcmem);
void __edm__Wrapper_JetProperties__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<JetProperties>"), typeid(::edm::Wrapper<JetProperties>), sizeof(::edm::Wrapper<JetProperties>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_923, Reflex::Literal("edm::Wrapper<JetProperties>::value_type"))
  .AddTypedef(type_923, Reflex::Literal("edm::Wrapper<JetProperties>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12334, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2307), Reflex::Literal("Wrapper"), constructor_12335, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12336, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8097), Reflex::Literal("Wrapper"), constructor_12341, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3219, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_JetProperties__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_JetProperties__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<JetProperties> -------------------
void __edm__Wrapper_JetProperties__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1310, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_JetProperties_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_923, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_JetProperties_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<JetProperties> -------------------
void __edm__Wrapper_JetProperties__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8099), Reflex::Literal("product"), method_12337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8099), Reflex::Literal("operator->"), operator_12338, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("productTypeInfo"), method_12339, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("typeInfo"), method_12340, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20853), Reflex::Literal("getInterface"), method_12342, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_12053, type_20274, type_20842), Reflex::Literal("fillView"), method_12343, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_3194, type_277, type_5511), Reflex::Literal("setPtr"), method_12344, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_3194, type_20275, type_20274), Reflex::Literal("fillPtrVector"), method_12345, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("dynamicTypeInfo"), method_12346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isPresent"), method_12347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("dynamicTypeInfo_"), method_12348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<HiggsGenEvent> -------------------------------
static void constructor_12355( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<HiggsGenEvent>();
  else ::new(mem) ::edm::Wrapper<HiggsGenEvent>();
}

static void constructor_12356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<HiggsGenEvent>(*(::std::auto_ptr<HiggsGenEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<HiggsGenEvent>(*(::std::auto_ptr<HiggsGenEvent>*)arg[0]);
}

static void destructor_12357(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<HiggsGenEvent>*)o)->::edm::Wrapper<HiggsGenEvent>::~Wrapper)();
}
static  void method_12358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<HiggsGenEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<HiggsGenEvent>*)o)->product)();
}

static  void operator_12359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<HiggsGenEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<HiggsGenEvent>*)o)->operator->)();
}

static  void method_12360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<HiggsGenEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<HiggsGenEvent>*)o)->productTypeInfo)();
}

static  void method_12361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<HiggsGenEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<HiggsGenEvent>*)o)->typeInfo)();
}

static void constructor_12362( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<HiggsGenEvent>((::HiggsGenEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<HiggsGenEvent>((::HiggsGenEvent*)arg[0]);
}

static  void method_12363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<HiggsGenEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<HiggsGenEvent>*)o)->getInterface)();
}

static  void method_12364( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<HiggsGenEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12365( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<HiggsGenEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12366( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<HiggsGenEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<HiggsGenEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<HiggsGenEvent>*)o)->dynamicTypeInfo)();
}

static  void method_12368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<HiggsGenEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<HiggsGenEvent>*)o)->isPresent)();
}

static  void method_12369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<HiggsGenEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<HiggsGenEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3220( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HiggsGenEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HiggsGenEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HiggsGenEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HiggsGenEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HiggsGenEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<HiggsGenEvent> -------------------------------
void __edm__Wrapper_HiggsGenEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_HiggsGenEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_HiggsGenEvent__datamem_bld(&__edm__Wrapper_HiggsGenEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_HiggsGenEvent__funcmem_bld(&__edm__Wrapper_HiggsGenEvent__db_funcmem);
void __edm__Wrapper_HiggsGenEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<HiggsGenEvent>"), typeid(::edm::Wrapper<HiggsGenEvent>), sizeof(::edm::Wrapper<HiggsGenEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_268, Reflex::Literal("edm::Wrapper<HiggsGenEvent>::value_type"))
  .AddTypedef(type_268, Reflex::Literal("edm::Wrapper<HiggsGenEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12355, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2308), Reflex::Literal("Wrapper"), constructor_12356, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12357, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20857), Reflex::Literal("Wrapper"), constructor_12362, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3220, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_HiggsGenEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_HiggsGenEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<HiggsGenEvent> -------------------
void __edm__Wrapper_HiggsGenEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1310, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_HiggsGenEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_268, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_HiggsGenEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<HiggsGenEvent> -------------------
void __edm__Wrapper_HiggsGenEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20856), Reflex::Literal("product"), method_12358, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20856), Reflex::Literal("operator->"), operator_12359, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("productTypeInfo"), method_12360, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("typeInfo"), method_12361, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20858), Reflex::Literal("getInterface"), method_12363, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_12053, type_20274, type_20842), Reflex::Literal("fillView"), method_12364, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_3194, type_277, type_5511), Reflex::Literal("setPtr"), method_12365, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_3194, type_20275, type_20274), Reflex::Literal("fillPtrVector"), method_12366, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("dynamicTypeInfo"), method_12367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isPresent"), method_12368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3194), Reflex::Literal("dynamicTypeInfo_"), method_12369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefProd<GenZDecayProperties> -------------------------------
static  void operator_12706( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<GenZDecayProperties>*)o)->operator=)(*(const ::edm::RefProd<GenZDecayProperties>*)arg[0]);
  else   (((::edm::RefProd<GenZDecayProperties>*)o)->operator=)(*(const ::edm::RefProd<GenZDecayProperties>*)arg[0]);
}

static void constructor_12707( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<GenZDecayProperties>(*(const ::edm::RefProd<GenZDecayProperties>*)arg[0]);
  else ::new(mem) ::edm::RefProd<GenZDecayProperties>(*(const ::edm::RefProd<GenZDecayProperties>*)arg[0]);
}

static void constructor_12708( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<GenZDecayProperties>();
  else ::new(mem) ::edm::RefProd<GenZDecayProperties>();
}

static void constructor_12709( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<GenZDecayProperties>(*(const ::edm::Handle<GenZDecayProperties>*)arg[0]);
  else ::new(mem) ::edm::RefProd<GenZDecayProperties>(*(const ::edm::Handle<GenZDecayProperties>*)arg[0]);
}

static void constructor_12710( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<GenZDecayProperties>(*(const ::edm::OrphanHandle<GenZDecayProperties>*)arg[0]);
  else ::new(mem) ::edm::RefProd<GenZDecayProperties>(*(const ::edm::OrphanHandle<GenZDecayProperties>*)arg[0]);
}

static void constructor_12711( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<GenZDecayProperties>((const ::GenZDecayProperties*)arg[0]);
  else ::new(mem) ::edm::RefProd<GenZDecayProperties>((const ::GenZDecayProperties*)arg[0]);
}

static void constructor_12712( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<GenZDecayProperties>(*(const ::edm::TestHandle<GenZDecayProperties>*)arg[0]);
  else ::new(mem) ::edm::RefProd<GenZDecayProperties>(*(const ::edm::TestHandle<GenZDecayProperties>*)arg[0]);
}

static void constructor_12713( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<GenZDecayProperties>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<GenZDecayProperties>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_12714(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<GenZDecayProperties>*)o)->::edm::RefProd<GenZDecayProperties>::~RefProd)();
}
static  void operator_12715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<GenZDecayProperties>*)o)->operator*)();
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->operator*)();
}

static  void operator_12716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<GenZDecayProperties>*)o)->operator->)());
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->operator->)();
}

static  void method_12717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<GenZDecayProperties>*)o)->get)());
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->get)();
}

static  void method_12718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<GenZDecayProperties>*)o)->product)());
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->product)();
}

static  void method_12719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<GenZDecayProperties>*)o)->refCore)();
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->refCore)();
}

static  void method_12720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<GenZDecayProperties>*)o)->isNull)());
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->isNull)();
}

static  void method_12721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<GenZDecayProperties>*)o)->isNonnull)());
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->isNonnull)();
}

static  void operator_12722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<GenZDecayProperties>*)o)->operator!)());
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->operator!)();
}

static  void method_12723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<GenZDecayProperties>*)o)->id)());
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->id)();
}

static  void method_12724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<GenZDecayProperties>*)o)->productGetter)());
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->productGetter)();
}

static  void method_12725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<GenZDecayProperties>*)o)->hasCache)());
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->hasCache)();
}

static  void method_12726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<GenZDecayProperties>*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->hasProductCache)();
}

static  void method_12727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<GenZDecayProperties>*)o)->isAvailable)());
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->isAvailable)();
}

static  void method_12728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<GenZDecayProperties>*)o)->isTransient)());
  else   (((const ::edm::RefProd<GenZDecayProperties>*)o)->isTransient)();
}

static  void method_12729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<GenZDecayProperties>*)o)->swap)(*(::edm::RefProd<GenZDecayProperties>*)arg[0]);
}

static  void method_12730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<GenZDecayProperties>*)o)->Class_Version)());
  else   (((::edm::RefProd<GenZDecayProperties>*)o)->Class_Version)();
}

static void method_newdel_3304( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<GenZDecayProperties> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<GenZDecayProperties> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<GenZDecayProperties> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<GenZDecayProperties> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<GenZDecayProperties> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<GenZDecayProperties> -------------------------------
void __edm__RefProd_GenZDecayProperties__db_datamem(Reflex::Class*);
void __edm__RefProd_GenZDecayProperties__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_GenZDecayProperties__datamem_bld(&__edm__RefProd_GenZDecayProperties__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_GenZDecayProperties__funcmem_bld(&__edm__RefProd_GenZDecayProperties__db_funcmem);
void __edm__RefProd_GenZDecayProperties__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<GenZDecayProperties>"), typeid(::edm::RefProd<GenZDecayProperties>), sizeof(::edm::RefProd<GenZDecayProperties>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<GenZDecayProperties>::Class_Version())
  .AddTypedef(type_1577, Reflex::Literal("edm::RefProd<GenZDecayProperties>::product_type"))
  .AddTypedef(type_1577, Reflex::Literal("edm::RefProd<GenZDecayProperties>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20953, type_20954), Reflex::Literal("operator="), operator_12706, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20954), Reflex::Literal("RefProd"), constructor_12707, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_12708, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20955), Reflex::Literal("RefProd"), constructor_12709, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20956), Reflex::Literal("RefProd"), constructor_12710, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8034), Reflex::Literal("RefProd"), constructor_12711, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20957), Reflex::Literal("RefProd"), constructor_12712, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12053, type_12900), Reflex::Literal("RefProd"), constructor_12713, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_12714, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3304, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_GenZDecayProperties__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_GenZDecayProperties__funcmem_bld);
}

//------Delayed data member builder for class RefProd<GenZDecayProperties> -------------------
void __edm__RefProd_GenZDecayProperties__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3289, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_GenZDecayProperties_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<GenZDecayProperties> -------------------
void __edm__RefProd_GenZDecayProperties__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8038), Reflex::Literal("operator*"), operator_12715, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8034), Reflex::Literal("operator->"), operator_12716, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8034), Reflex::Literal("get"), method_12717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8034), Reflex::Literal("product"), method_12718, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12416), Reflex::Literal("refCore"), method_12719, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isNull"), method_12720, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isNonnull"), method_12721, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("operator!"), operator_12722, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3287), Reflex::Literal("id"), method_12723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12900), Reflex::Literal("productGetter"), method_12724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("hasCache"), method_12725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("hasProductCache"), method_12726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isAvailable"), method_12727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isTransient"), method_12728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_20953), Reflex::Literal("swap"), method_12729, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_163), Reflex::Literal("Class_Version"), method_12730, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<JetProperties> -------------------------------
static  void operator_12735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<JetProperties>*)o)->operator=)(*(const ::edm::RefProd<JetProperties>*)arg[0]);
  else   (((::edm::RefProd<JetProperties>*)o)->operator=)(*(const ::edm::RefProd<JetProperties>*)arg[0]);
}

static void constructor_12736( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<JetProperties>(*(const ::edm::RefProd<JetProperties>*)arg[0]);
  else ::new(mem) ::edm::RefProd<JetProperties>(*(const ::edm::RefProd<JetProperties>*)arg[0]);
}

static void constructor_12737( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<JetProperties>();
  else ::new(mem) ::edm::RefProd<JetProperties>();
}

static void constructor_12738( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<JetProperties>(*(const ::edm::Handle<JetProperties>*)arg[0]);
  else ::new(mem) ::edm::RefProd<JetProperties>(*(const ::edm::Handle<JetProperties>*)arg[0]);
}

static void constructor_12739( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<JetProperties>(*(const ::edm::OrphanHandle<JetProperties>*)arg[0]);
  else ::new(mem) ::edm::RefProd<JetProperties>(*(const ::edm::OrphanHandle<JetProperties>*)arg[0]);
}

static void constructor_12740( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<JetProperties>((const ::JetProperties*)arg[0]);
  else ::new(mem) ::edm::RefProd<JetProperties>((const ::JetProperties*)arg[0]);
}

static void constructor_12741( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<JetProperties>(*(const ::edm::TestHandle<JetProperties>*)arg[0]);
  else ::new(mem) ::edm::RefProd<JetProperties>(*(const ::edm::TestHandle<JetProperties>*)arg[0]);
}

static void constructor_12742( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<JetProperties>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<JetProperties>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_12743(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<JetProperties>*)o)->::edm::RefProd<JetProperties>::~RefProd)();
}
static  void operator_12744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<JetProperties>*)o)->operator*)();
  else   (((const ::edm::RefProd<JetProperties>*)o)->operator*)();
}

static  void operator_12745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<JetProperties>*)o)->operator->)());
  else   (((const ::edm::RefProd<JetProperties>*)o)->operator->)();
}

static  void method_12746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<JetProperties>*)o)->get)());
  else   (((const ::edm::RefProd<JetProperties>*)o)->get)();
}

static  void method_12747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<JetProperties>*)o)->product)());
  else   (((const ::edm::RefProd<JetProperties>*)o)->product)();
}

static  void method_12748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<JetProperties>*)o)->refCore)();
  else   (((const ::edm::RefProd<JetProperties>*)o)->refCore)();
}

static  void method_12749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<JetProperties>*)o)->isNull)());
  else   (((const ::edm::RefProd<JetProperties>*)o)->isNull)();
}

static  void method_12750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<JetProperties>*)o)->isNonnull)());
  else   (((const ::edm::RefProd<JetProperties>*)o)->isNonnull)();
}

static  void operator_12751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<JetProperties>*)o)->operator!)());
  else   (((const ::edm::RefProd<JetProperties>*)o)->operator!)();
}

static  void method_12752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<JetProperties>*)o)->id)());
  else   (((const ::edm::RefProd<JetProperties>*)o)->id)();
}

static  void method_12753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<JetProperties>*)o)->productGetter)());
  else   (((const ::edm::RefProd<JetProperties>*)o)->productGetter)();
}

static  void method_12754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<JetProperties>*)o)->hasCache)());
  else   (((const ::edm::RefProd<JetProperties>*)o)->hasCache)();
}

static  void method_12755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<JetProperties>*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<JetProperties>*)o)->hasProductCache)();
}

static  void method_12756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<JetProperties>*)o)->isAvailable)());
  else   (((const ::edm::RefProd<JetProperties>*)o)->isAvailable)();
}

static  void method_12757( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<JetProperties>*)o)->isTransient)());
  else   (((const ::edm::RefProd<JetProperties>*)o)->isTransient)();
}

static  void method_12758( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<JetProperties>*)o)->swap)(*(::edm::RefProd<JetProperties>*)arg[0]);
}

static  void method_12759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<JetProperties>*)o)->Class_Version)());
  else   (((::edm::RefProd<JetProperties>*)o)->Class_Version)();
}

static void method_newdel_3305( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<JetProperties> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<JetProperties> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<JetProperties> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<JetProperties> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<JetProperties> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<JetProperties> -------------------------------
void __edm__RefProd_JetProperties__db_datamem(Reflex::Class*);
void __edm__RefProd_JetProperties__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_JetProperties__datamem_bld(&__edm__RefProd_JetProperties__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_JetProperties__funcmem_bld(&__edm__RefProd_JetProperties__db_funcmem);
void __edm__RefProd_JetProperties__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<JetProperties>"), typeid(::edm::RefProd<JetProperties>), sizeof(::edm::RefProd<JetProperties>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<JetProperties>::Class_Version())
  .AddTypedef(type_923, Reflex::Literal("edm::RefProd<JetProperties>::product_type"))
  .AddTypedef(type_923, Reflex::Literal("edm::RefProd<JetProperties>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20958, type_20959), Reflex::Literal("operator="), operator_12735, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20959), Reflex::Literal("RefProd"), constructor_12736, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_12737, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20960), Reflex::Literal("RefProd"), constructor_12738, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20961), Reflex::Literal("RefProd"), constructor_12739, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8099), Reflex::Literal("RefProd"), constructor_12740, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20962), Reflex::Literal("RefProd"), constructor_12741, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12053, type_12900), Reflex::Literal("RefProd"), constructor_12742, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_12743, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3305, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_JetProperties__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_JetProperties__funcmem_bld);
}

//------Delayed data member builder for class RefProd<JetProperties> -------------------
void __edm__RefProd_JetProperties__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3289, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_JetProperties_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<JetProperties> -------------------
void __edm__RefProd_JetProperties__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8103), Reflex::Literal("operator*"), operator_12744, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8099), Reflex::Literal("operator->"), operator_12745, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8099), Reflex::Literal("get"), method_12746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8099), Reflex::Literal("product"), method_12747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12416), Reflex::Literal("refCore"), method_12748, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isNull"), method_12749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isNonnull"), method_12750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("operator!"), operator_12751, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3287), Reflex::Literal("id"), method_12752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12900), Reflex::Literal("productGetter"), method_12753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("hasCache"), method_12754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("hasProductCache"), method_12755, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isAvailable"), method_12756, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isTransient"), method_12757, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_20958), Reflex::Literal("swap"), method_12758, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_163), Reflex::Literal("Class_Version"), method_12759, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<HiggsGenEvent> -------------------------------
static  void operator_12764( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<HiggsGenEvent>*)o)->operator=)(*(const ::edm::RefProd<HiggsGenEvent>*)arg[0]);
  else   (((::edm::RefProd<HiggsGenEvent>*)o)->operator=)(*(const ::edm::RefProd<HiggsGenEvent>*)arg[0]);
}

static void constructor_12765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<HiggsGenEvent>(*(const ::edm::RefProd<HiggsGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<HiggsGenEvent>(*(const ::edm::RefProd<HiggsGenEvent>*)arg[0]);
}

static void constructor_12766( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<HiggsGenEvent>();
  else ::new(mem) ::edm::RefProd<HiggsGenEvent>();
}

static void constructor_12767( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<HiggsGenEvent>(*(const ::edm::Handle<HiggsGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<HiggsGenEvent>(*(const ::edm::Handle<HiggsGenEvent>*)arg[0]);
}

static void constructor_12768( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<HiggsGenEvent>(*(const ::edm::OrphanHandle<HiggsGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<HiggsGenEvent>(*(const ::edm::OrphanHandle<HiggsGenEvent>*)arg[0]);
}

static void constructor_12769( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<HiggsGenEvent>((const ::HiggsGenEvent*)arg[0]);
  else ::new(mem) ::edm::RefProd<HiggsGenEvent>((const ::HiggsGenEvent*)arg[0]);
}

static void constructor_12770( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<HiggsGenEvent>(*(const ::edm::TestHandle<HiggsGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<HiggsGenEvent>(*(const ::edm::TestHandle<HiggsGenEvent>*)arg[0]);
}

static void constructor_12771( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<HiggsGenEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<HiggsGenEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_12772(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<HiggsGenEvent>*)o)->::edm::RefProd<HiggsGenEvent>::~RefProd)();
}
static  void operator_12773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<HiggsGenEvent>*)o)->operator*)();
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->operator*)();
}

static  void operator_12774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<HiggsGenEvent>*)o)->operator->)());
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->operator->)();
}

static  void method_12775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<HiggsGenEvent>*)o)->get)());
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->get)();
}

static  void method_12776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<HiggsGenEvent>*)o)->product)());
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->product)();
}

static  void method_12777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<HiggsGenEvent>*)o)->refCore)();
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->refCore)();
}

static  void method_12778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<HiggsGenEvent>*)o)->isNull)());
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->isNull)();
}

static  void method_12779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<HiggsGenEvent>*)o)->isNonnull)());
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->isNonnull)();
}

static  void operator_12780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<HiggsGenEvent>*)o)->operator!)());
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->operator!)();
}

static  void method_12781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<HiggsGenEvent>*)o)->id)());
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->id)();
}

static  void method_12782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<HiggsGenEvent>*)o)->productGetter)());
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->productGetter)();
}

static  void method_12783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<HiggsGenEvent>*)o)->hasCache)());
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->hasCache)();
}

static  void method_12784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<HiggsGenEvent>*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->hasProductCache)();
}

static  void method_12785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<HiggsGenEvent>*)o)->isAvailable)());
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->isAvailable)();
}

static  void method_12786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<HiggsGenEvent>*)o)->isTransient)());
  else   (((const ::edm::RefProd<HiggsGenEvent>*)o)->isTransient)();
}

static  void method_12787( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<HiggsGenEvent>*)o)->swap)(*(::edm::RefProd<HiggsGenEvent>*)arg[0]);
}

static  void method_12788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<HiggsGenEvent>*)o)->Class_Version)());
  else   (((::edm::RefProd<HiggsGenEvent>*)o)->Class_Version)();
}

static void method_newdel_3306( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<HiggsGenEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<HiggsGenEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<HiggsGenEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<HiggsGenEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<HiggsGenEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<HiggsGenEvent> -------------------------------
void __edm__RefProd_HiggsGenEvent__db_datamem(Reflex::Class*);
void __edm__RefProd_HiggsGenEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_HiggsGenEvent__datamem_bld(&__edm__RefProd_HiggsGenEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_HiggsGenEvent__funcmem_bld(&__edm__RefProd_HiggsGenEvent__db_funcmem);
void __edm__RefProd_HiggsGenEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<HiggsGenEvent>"), typeid(::edm::RefProd<HiggsGenEvent>), sizeof(::edm::RefProd<HiggsGenEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<HiggsGenEvent>::Class_Version())
  .AddTypedef(type_268, Reflex::Literal("edm::RefProd<HiggsGenEvent>::product_type"))
  .AddTypedef(type_268, Reflex::Literal("edm::RefProd<HiggsGenEvent>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20963, type_20964), Reflex::Literal("operator="), operator_12764, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20964), Reflex::Literal("RefProd"), constructor_12765, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_12766, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20965), Reflex::Literal("RefProd"), constructor_12767, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20966), Reflex::Literal("RefProd"), constructor_12768, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20856), Reflex::Literal("RefProd"), constructor_12769, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20967), Reflex::Literal("RefProd"), constructor_12770, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12053, type_12900), Reflex::Literal("RefProd"), constructor_12771, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_12772, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3306, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_HiggsGenEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_HiggsGenEvent__funcmem_bld);
}

//------Delayed data member builder for class RefProd<HiggsGenEvent> -------------------
void __edm__RefProd_HiggsGenEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3289, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_HiggsGenEvent_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<HiggsGenEvent> -------------------
void __edm__RefProd_HiggsGenEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12133), Reflex::Literal("operator*"), operator_12773, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20856), Reflex::Literal("operator->"), operator_12774, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20856), Reflex::Literal("get"), method_12775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20856), Reflex::Literal("product"), method_12776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12416), Reflex::Literal("refCore"), method_12777, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isNull"), method_12778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isNonnull"), method_12779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("operator!"), operator_12780, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3287), Reflex::Literal("id"), method_12781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12900), Reflex::Literal("productGetter"), method_12782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("hasCache"), method_12783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("hasProductCache"), method_12784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isAvailable"), method_12785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("isTransient"), method_12786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_318, type_20963), Reflex::Literal("swap"), method_12787, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_163), Reflex::Literal("Class_Version"), method_12788, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __HiggsGenEvent_dict(); 
      __JetProperties_dict(); 
      __GenZDecayProperties_dict(); 
      __std__vector_GenZDecayProperties__dict(); 
      __std__vector_JetProperties__dict(); 
      __edm__Wrapper_std__vector_GenZDecayProperties_s__dict(); 
      __edm__Wrapper_GenZDecayProperties__dict(); 
      __edm__Wrapper_std__vector_JetProperties_s__dict(); 
      __edm__Wrapper_JetProperties__dict(); 
      __edm__Wrapper_HiggsGenEvent__dict(); 
      __edm__RefProd_GenZDecayProperties__dict(); 
      __edm__RefProd_JetProperties__dict(); 
      __edm__RefProd_HiggsGenEvent__dict(); 
    }
    ~Dictionaries() {
      type_268.Unload(); // class HiggsGenEvent 
      type_923.Unload(); // class JetProperties 
      type_1577.Unload(); // class GenZDecayProperties 
      type_2528.Unload(); // class std::vector<GenZDecayProperties> 
      type_2529.Unload(); // class std::vector<JetProperties> 
      type_3216.Unload(); // class edm::Wrapper<std::vector<GenZDecayProperties> > 
      type_3217.Unload(); // class edm::Wrapper<GenZDecayProperties> 
      type_3218.Unload(); // class edm::Wrapper<std::vector<JetProperties> > 
      type_3219.Unload(); // class edm::Wrapper<JetProperties> 
      type_3220.Unload(); // class edm::Wrapper<HiggsGenEvent> 
      type_3304.Unload(); // class edm::RefProd<GenZDecayProperties> 
      type_3305.Unload(); // class edm::RefProd<JetProperties> 
      type_3306.Unload(); // class edm::RefProd<HiggsGenEvent> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
