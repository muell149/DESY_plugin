// Generated at Tue Jan 21 11:00:24 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/TopAnalysis/TopUtils/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("edm::reftobase") );
  ::Reflex::Type type_72 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_336 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_89 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_943 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_1401 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1637 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_10549 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Jet"));
  ::Reflex::Type type_10537 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Muon"));
  ::Reflex::Type type_378 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_369 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_6373 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCore"));
  ::Reflex::Type type_516 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_6619 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_3223 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_235 = ::Reflex::TypeBuilder(Reflex::Literal("ResolutionVariables"));
  ::Reflex::Type type_6395 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>"));
  ::Reflex::Type type_6491 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDProductGetter"));
  ::Reflex::Type type_3218 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_6452 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<pat::Jet>"));
  ::Reflex::Type type_6453 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<pat::Muon>"));
  ::Reflex::Type type_3219 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_6315 = ::Reflex::TypeBuilder(Reflex::Literal("edm::View<reco::Candidate>"));
  ::Reflex::Type type_3222 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<int> >"));
  ::Reflex::Type type_6197 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBaseVector<pat::Jet>"));
  ::Reflex::Type type_6198 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBaseVector<pat::Muon>"));
  ::Reflex::Type type_3610 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<int> >"));
  ::Reflex::Type type_34047 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<pat::Jet>"));
  ::Reflex::Type type_34048 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<pat::Muon>"));
  ::Reflex::Type type_6578 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<edm::View<reco::Candidate> >"));
  ::Reflex::Type type_6399 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<edm::View<reco::Candidate> >"));
  ::Reflex::Type type_34057 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<pat::Jet>"));
  ::Reflex::Type type_34058 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<pat::Muon>"));
  ::Reflex::Type type_6250 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<edm::View<reco::Candidate> >"));
  ::Reflex::Type type_6486 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Association<edm::View<reco::Candidate> >"));
  ::Reflex::Type type_6136 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefToBaseVector<pat::Jet> >"));
  ::Reflex::Type type_6138 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::vector<int> > >"));
  ::Reflex::Type type_2931 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefToBaseVector<pat::Jet> >"));
  ::Reflex::Type type_2933 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<std::vector<int> > >"));
  ::Reflex::Type type_6323 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<edm::View<reco::Candidate> >"));
  ::Reflex::Type type_6137 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefToBaseVector<pat::Muon> >"));
  ::Reflex::Type type_2932 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefToBaseVector<pat::Muon> >"));
  ::Reflex::Type type_2930 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_3220 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<edm::ProductID,unsigned int> >"));
  ::Reflex::Type type_5216 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_6143 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefToBaseVector<pat::Jet> >"));
  ::Reflex::Type type_6145 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<std::vector<int> > >"));
  ::Reflex::Type type_6144 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefToBaseVector<pat::Muon> >"));
  ::Reflex::Type type_34174 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<pat::Jet>::const_iterator"));
  ::Reflex::Type type_34204 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<pat::Muon>::const_iterator"));
  ::Reflex::Type type_6135 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >"));
  ::Reflex::Type type_2929 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::Association<edm::View<reco::Candidate> > >"));
  ::Reflex::Type type_6142 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::Association<edm::View<reco::Candidate> > >"));
  ::Reflex::Type type_2547 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > >"));
  ::Reflex::Type type_9806 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >"));
  ::Reflex::Type type_9807 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > >"));
  ::Reflex::Type type_3991 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > > >"));
  ::Reflex::Type type_3990 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > > >"));
  ::Reflex::Type type_6492 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<edm::View<reco::Candidate>,reco::Candidate,edm::refhelper::FindUsingAdvance<edm::View<reco::Candidate>,reco::Candidate> >"));
  ::Reflex::Type type_1108 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Float_t"), type_943);
  ::Reflex::Type type_442 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Int_t"), type_72);
  ::Reflex::Type type_29372 = ::Reflex::ReferenceBuilder(type_235);
  ::Reflex::Type type_235c = ::Reflex::ConstBuilder(type_235);
  ::Reflex::Type type_29373 = ::Reflex::ReferenceBuilder(type_235c);
  ::Reflex::Type type_16931 = ::Reflex::PointerBuilder(type_3223);
  ::Reflex::Type type_3223c = ::Reflex::ConstBuilder(type_3223);
  ::Reflex::Type type_16933 = ::Reflex::PointerBuilder(type_3223c);
  ::Reflex::Type type_16935 = ::Reflex::ReferenceBuilder(type_3223);
  ::Reflex::Type type_16937 = ::Reflex::ReferenceBuilder(type_3223c);
  ::Reflex::Type type_3594 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_369);
  ::Reflex::Type type_3452 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_336);
  ::Reflex::Type type_3610c = ::Reflex::ConstBuilder(type_3610);
  ::Reflex::Type type_46370 = ::Reflex::ReferenceBuilder(type_3610c);
  ::Reflex::Type type_3222c = ::Reflex::ConstBuilder(type_3222);
  ::Reflex::Type type_48478 = ::Reflex::ReferenceBuilder(type_3222c);
  ::Reflex::Type type_48479 = ::Reflex::ReferenceBuilder(type_3222);
  ::Reflex::Type type_6486c = ::Reflex::ConstBuilder(type_6486);
  ::Reflex::Type type_55666 = ::Reflex::ReferenceBuilder(type_6486c);
  ::Reflex::Type type_2177 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_369);
  ::Reflex::Type type_55667 = ::Reflex::ReferenceBuilder(type_6486);
  ::Reflex::Type type_6399c = ::Reflex::ConstBuilder(type_6399);
  ::Reflex::Type type_55619 = ::Reflex::ReferenceBuilder(type_6399c);
  ::Reflex::Type type_3220c = ::Reflex::ConstBuilder(type_3220);
  ::Reflex::Type type_48471 = ::Reflex::ReferenceBuilder(type_3220c);
  ::Reflex::Type type_55333 = ::Reflex::PointerBuilder(type_6486c);
  ::Reflex::Type type_516c = ::Reflex::ConstBuilder(type_516);
  ::Reflex::Type type_9227 = ::Reflex::ReferenceBuilder(type_516c);
  ::Reflex::Type type_55334 = ::Reflex::PointerBuilder(type_6486);
  ::Reflex::Type type_6142c = ::Reflex::ConstBuilder(type_6142);
  ::Reflex::Type type_55335 = ::Reflex::PointerBuilder(type_6142c);
  ::Reflex::Type type_6619c = ::Reflex::ConstBuilder(type_6619);
  ::Reflex::Type type_29200 = ::Reflex::ReferenceBuilder(type_6619c);
  ::Reflex::Type type_29276 = ::Reflex::ReferenceBuilder(type_3218);
  ::Reflex::Type type_49747 = ::Reflex::ReferenceBuilder(type_5216);
  ::Reflex::Type type_1401c = ::Reflex::ConstBuilder(type_1401);
  ::Reflex::Type type_4784 = ::Reflex::PointerBuilder(type_1401c);
  ::Reflex::Type type_13610 = ::Reflex::ReferenceBuilder(type_4784);
  ::Reflex::Type type_3219c = ::Reflex::ConstBuilder(type_3219);
  ::Reflex::Type type_37151 = ::Reflex::ReferenceBuilder(type_3219c);
  ::Reflex::Type type_55505 = ::Reflex::PointerBuilder(type_34057);
  ::Reflex::Type type_6197c = ::Reflex::ConstBuilder(type_6197);
  ::Reflex::Type type_55506 = ::Reflex::ReferenceBuilder(type_6197c);
  ::Reflex::Type type_55507 = ::Reflex::ReferenceBuilder(type_6197);
  ::Reflex::Type type_6491c = ::Reflex::ConstBuilder(type_6491);
  ::Reflex::Type type_29272 = ::Reflex::PointerBuilder(type_6491c);
  ::Reflex::Type type_6452c = ::Reflex::ConstBuilder(type_6452);
  ::Reflex::Type type_55508 = ::Reflex::ReferenceBuilder(type_6452c);
  ::Reflex::Type type_55338 = ::Reflex::PointerBuilder(type_6197c);
  ::Reflex::Type type_55339 = ::Reflex::PointerBuilder(type_6197);
  ::Reflex::Type type_6143c = ::Reflex::ConstBuilder(type_6143);
  ::Reflex::Type type_55340 = ::Reflex::PointerBuilder(type_6143c);
  ::Reflex::Type type_55509 = ::Reflex::PointerBuilder(type_34058);
  ::Reflex::Type type_6198c = ::Reflex::ConstBuilder(type_6198);
  ::Reflex::Type type_55510 = ::Reflex::ReferenceBuilder(type_6198c);
  ::Reflex::Type type_55511 = ::Reflex::ReferenceBuilder(type_6198);
  ::Reflex::Type type_6453c = ::Reflex::ConstBuilder(type_6453);
  ::Reflex::Type type_55512 = ::Reflex::ReferenceBuilder(type_6453c);
  ::Reflex::Type type_55343 = ::Reflex::PointerBuilder(type_6198c);
  ::Reflex::Type type_55344 = ::Reflex::PointerBuilder(type_6198);
  ::Reflex::Type type_6144c = ::Reflex::ConstBuilder(type_6144);
  ::Reflex::Type type_55345 = ::Reflex::PointerBuilder(type_6144c);
  ::Reflex::Type type_55348 = ::Reflex::PointerBuilder(type_3222c);
  ::Reflex::Type type_55349 = ::Reflex::PointerBuilder(type_3222);
  ::Reflex::Type type_6145c = ::Reflex::ConstBuilder(type_6145);
  ::Reflex::Type type_55350 = ::Reflex::PointerBuilder(type_6145c);
  ::Reflex::Type type_55618 = ::Reflex::ReferenceBuilder(type_6399);
  ::Reflex::Type type_6578c = ::Reflex::ConstBuilder(type_6578);
  ::Reflex::Type type_55620 = ::Reflex::ReferenceBuilder(type_6578c);
  ::Reflex::Type type_6323c = ::Reflex::ConstBuilder(type_6323);
  ::Reflex::Type type_55621 = ::Reflex::ReferenceBuilder(type_6323c);
  ::Reflex::Type type_6315c = ::Reflex::ConstBuilder(type_6315);
  ::Reflex::Type type_55622 = ::Reflex::PointerBuilder(type_6315c);
  ::Reflex::Type type_6250c = ::Reflex::ConstBuilder(type_6250);
  ::Reflex::Type type_55623 = ::Reflex::ReferenceBuilder(type_6250c);
  ::Reflex::Type type_55547 = ::Reflex::ReferenceBuilder(type_6315c);
  ::Reflex::Type type_6373c = ::Reflex::ConstBuilder(type_6373);
  ::Reflex::Type type_29335 = ::Reflex::ReferenceBuilder(type_6373c);
  ::Reflex::Type type_61516 = ::Reflex::ReferenceBuilder(type_34057);
  ::Reflex::Type type_34057c = ::Reflex::ConstBuilder(type_34057);
  ::Reflex::Type type_61517 = ::Reflex::ReferenceBuilder(type_34057c);
  ::Reflex::Type type_34047c = ::Reflex::ConstBuilder(type_34047);
  ::Reflex::Type type_61519 = ::Reflex::PointerBuilder(type_34047c);
  ::Reflex::Type type_61520 = ::Reflex::ReferenceBuilder(type_34058);
  ::Reflex::Type type_34058c = ::Reflex::ConstBuilder(type_34058);
  ::Reflex::Type type_61521 = ::Reflex::ReferenceBuilder(type_34058c);
  ::Reflex::Type type_34048c = ::Reflex::ConstBuilder(type_34048);
  ::Reflex::Type type_61523 = ::Reflex::PointerBuilder(type_34048c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __ResolutionVariables
#undef __ResolutionVariables
#endif
struct __ResolutionVariables {
  public:
  __ResolutionVariables();
  ::Float_t Gen_energy;
  ::Float_t Gen_et;
  ::Float_t Gen_pt;
  ::Float_t Gen_eta;
  ::Float_t Gen_phi;
  ::Float_t Reco_energy;
  ::Float_t Reco_et;
  ::Float_t Reco_pt;
  ::Float_t Reco_eta;
  ::Float_t Reco_phi;
  ::Float_t pt_reco_over_gen;
  ::Float_t Reco_emFraction;
  ::Float_t Gen_sumEt;
  ::Float_t Reco_sumEt;
  ::Float_t DeltaPhi;
  ::Float_t DeltaR;
  ::Float_t nextDeltaR;
  ::Float_t pTinnerTracker;
  ::Float_t PUweight;
  ::Float_t PUweightUp;
  ::Float_t PUweightDown;
  ::Int_t Particle_ID;
  ::Int_t whichMuon;
};
#ifdef __std__vector_std__vector_int_s_
#undef __std__vector_std__vector_int_s_
#endif
class __std__vector_std__vector_int_s_ : protected ::std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > > {
  public:
  __std__vector_std__vector_int_s_();
};
#ifdef __edm__Association_edm__View_reco__Candidate_s_
#undef __edm__Association_edm__View_reco__Candidate_s_
#endif
class __edm__Association_edm__View_reco__Candidate_s_ : private ::edm::ValueMap<int> {
  public:
  __edm__Association_edm__View_reco__Candidate_s_();
  ::edm::RefProd<edm::View<reco::Candidate> > ref_;
};
#ifdef __edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s_
#undef __edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s_
#endif
class __edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s_ {
  public:
  __edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s_();
  bool present;
  ::edm::Association<edm::View<reco::Candidate> > obj;
};
#ifdef __edm__RefToBaseVector_pat__Jet_
#undef __edm__RefToBaseVector_pat__Jet_
#endif
class __edm__RefToBaseVector_pat__Jet_ {
  public:
  __edm__RefToBaseVector_pat__Jet_();
  void* holder_;
};
#ifdef __edm__Wrapper_edm__RefToBaseVector_pat__Jet_s_
#undef __edm__Wrapper_edm__RefToBaseVector_pat__Jet_s_
#endif
class __edm__Wrapper_edm__RefToBaseVector_pat__Jet_s_ {
  public:
  __edm__Wrapper_edm__RefToBaseVector_pat__Jet_s_();
  bool present;
  ::edm::RefToBaseVector<pat::Jet> obj;
};
#ifdef __edm__RefToBaseVector_pat__Muon_
#undef __edm__RefToBaseVector_pat__Muon_
#endif
class __edm__RefToBaseVector_pat__Muon_ {
  public:
  __edm__RefToBaseVector_pat__Muon_();
  void* holder_;
};
#ifdef __edm__Wrapper_edm__RefToBaseVector_pat__Muon_s_
#undef __edm__Wrapper_edm__RefToBaseVector_pat__Muon_s_
#endif
class __edm__Wrapper_edm__RefToBaseVector_pat__Muon_s_ {
  public:
  __edm__Wrapper_edm__RefToBaseVector_pat__Muon_s_();
  bool present;
  ::edm::RefToBaseVector<pat::Muon> obj;
};
#ifdef __edm__Wrapper_std__vector_std__vector_int_s_s_
#undef __edm__Wrapper_std__vector_std__vector_int_s_s_
#endif
class __edm__Wrapper_std__vector_std__vector_int_s_s_ {
  public:
  __edm__Wrapper_std__vector_std__vector_int_s_s_();
  bool present;
  ::std::vector<std::vector<int> > obj;
};
#ifdef __edm__RefProd_edm__View_reco__Candidate_s_
#undef __edm__RefProd_edm__View_reco__Candidate_s_
#endif
class __edm__RefProd_edm__View_reco__Candidate_s_ {
  public:
  __edm__RefProd_edm__View_reco__Candidate_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__reftobase__BaseVectorHolder_pat__Jet_
#undef __edm__reftobase__BaseVectorHolder_pat__Jet_
#endif
class __edm__reftobase__BaseVectorHolder_pat__Jet_ {
  public:
  __edm__reftobase__BaseVectorHolder_pat__Jet_();
  virtual ~__edm__reftobase__BaseVectorHolder_pat__Jet_() throw();
};
#ifdef __edm__reftobase__BaseVectorHolder_pat__Muon_
#undef __edm__reftobase__BaseVectorHolder_pat__Muon_
#endif
class __edm__reftobase__BaseVectorHolder_pat__Muon_ {
  public:
  __edm__reftobase__BaseVectorHolder_pat__Muon_();
  virtual ~__edm__reftobase__BaseVectorHolder_pat__Muon_() throw();
};
}


#endif // __CINT__
namespace {
//------Stub functions for class ResolutionVariables -------------------------------
static void destructor_4947(void*, void * o, const std::vector<void*>&, void *) {
(((::ResolutionVariables*)o)->::ResolutionVariables::~ResolutionVariables)();
}
static  void operator_4948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ResolutionVariables*)o)->operator=)(*(const ::ResolutionVariables*)arg[0]);
  else   (((::ResolutionVariables*)o)->operator=)(*(const ::ResolutionVariables*)arg[0]);
}

static void constructor_4949( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ResolutionVariables(*(const ::ResolutionVariables*)arg[0]);
  else ::new(mem) ::ResolutionVariables(*(const ::ResolutionVariables*)arg[0]);
}

static void constructor_4950( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ResolutionVariables();
  else ::new(mem) ::ResolutionVariables();
}

static  void method_4951( void*, void* o, const std::vector<void*>&, void*)
{
  (((::ResolutionVariables*)o)->clear)();
}

static  void method_4952( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ResolutionVariables*)o)->fillVariables)(*(::Float_t*)arg[0],
    *(::Float_t*)arg[1],
    *(::Float_t*)arg[2],
    *(::Float_t*)arg[3],
    *(::Float_t*)arg[4],
    *(::Float_t*)arg[5],
    *(::Float_t*)arg[6],
    *(::Float_t*)arg[7],
    *(::Float_t*)arg[8],
    *(::Float_t*)arg[9],
    *(::Float_t*)arg[10],
    *(::Int_t*)arg[11],
    *(::Float_t*)arg[12],
    *(::Float_t*)arg[13],
    *(::Float_t*)arg[14],
    *(::Float_t*)arg[15],
    *(::Float_t*)arg[16],
    *(::Float_t*)arg[17],
    *(::Int_t*)arg[18],
    *(::Float_t*)arg[19],
    *(::Float_t*)arg[20],
    *(::Float_t*)arg[21],
    *(::Float_t*)arg[22]);
}

static void method_newdel_235( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::ResolutionVariables >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::ResolutionVariables >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::ResolutionVariables >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::ResolutionVariables >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::ResolutionVariables >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ResolutionVariables -------------------------------
void __ResolutionVariables_db_datamem(Reflex::Class*);
void __ResolutionVariables_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ResolutionVariables_datamem_bld(&__ResolutionVariables_db_datamem);
Reflex::GenreflexMemberBuilder __ResolutionVariables_funcmem_bld(&__ResolutionVariables_db_funcmem);
void __ResolutionVariables_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ResolutionVariables"), typeid(::ResolutionVariables), sizeof(::ResolutionVariables), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ResolutionVariables"), destructor_4947, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29372, type_29373), Reflex::Literal("operator="), operator_4948, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29373), Reflex::Literal("ResolutionVariables"), constructor_4949, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ResolutionVariables"), constructor_4950, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_235, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__ResolutionVariables_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__ResolutionVariables_funcmem_bld);
}

//------Delayed data member builder for class ResolutionVariables -------------------
void __ResolutionVariables_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1108, Reflex::Literal("Gen_energy"), OffsetOf(__shadow__::__ResolutionVariables, Gen_energy), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("Gen_et"), OffsetOf(__shadow__::__ResolutionVariables, Gen_et), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("Gen_pt"), OffsetOf(__shadow__::__ResolutionVariables, Gen_pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("Gen_eta"), OffsetOf(__shadow__::__ResolutionVariables, Gen_eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("Gen_phi"), OffsetOf(__shadow__::__ResolutionVariables, Gen_phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("Reco_energy"), OffsetOf(__shadow__::__ResolutionVariables, Reco_energy), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("Reco_et"), OffsetOf(__shadow__::__ResolutionVariables, Reco_et), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("Reco_pt"), OffsetOf(__shadow__::__ResolutionVariables, Reco_pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("Reco_eta"), OffsetOf(__shadow__::__ResolutionVariables, Reco_eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("Reco_phi"), OffsetOf(__shadow__::__ResolutionVariables, Reco_phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("pt_reco_over_gen"), OffsetOf(__shadow__::__ResolutionVariables, pt_reco_over_gen), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("Reco_emFraction"), OffsetOf(__shadow__::__ResolutionVariables, Reco_emFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("Gen_sumEt"), OffsetOf(__shadow__::__ResolutionVariables, Gen_sumEt), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("Reco_sumEt"), OffsetOf(__shadow__::__ResolutionVariables, Reco_sumEt), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("DeltaPhi"), OffsetOf(__shadow__::__ResolutionVariables, DeltaPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("DeltaR"), OffsetOf(__shadow__::__ResolutionVariables, DeltaR), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("nextDeltaR"), OffsetOf(__shadow__::__ResolutionVariables, nextDeltaR), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("pTinnerTracker"), OffsetOf(__shadow__::__ResolutionVariables, pTinnerTracker), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("PUweight"), OffsetOf(__shadow__::__ResolutionVariables, PUweight), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("PUweightUp"), OffsetOf(__shadow__::__ResolutionVariables, PUweightUp), ::Reflex::PUBLIC)
  .AddDataMember(type_1108, Reflex::Literal("PUweightDown"), OffsetOf(__shadow__::__ResolutionVariables, PUweightDown), ::Reflex::PUBLIC)
  .AddDataMember(type_442, Reflex::Literal("Particle_ID"), OffsetOf(__shadow__::__ResolutionVariables, Particle_ID), ::Reflex::PUBLIC)
  .AddDataMember(type_442, Reflex::Literal("whichMuon"), OffsetOf(__shadow__::__ResolutionVariables, whichMuon), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class ResolutionVariables -------------------
void __ResolutionVariables_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401), Reflex::Literal("clear"), method_4951, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_1108, type_1108, type_1108, type_1108, type_1108, type_1108, type_1108, type_1108, type_1108, type_1108, type_1108, type_442, type_1108, type_1108, type_1108, type_1108, type_1108, type_1108, type_442, type_1108, type_1108, type_1108, type_1108), Reflex::Literal("fillVariables"), method_4952, 0, "energy_GenJets;et_GenJets;pt_GenJets;eta_GenJets;phi_GenJets;energy_RecoJets;et_RecoJets;pt_RecoJets;eta_RecoJets;phi_RecoJets;pt_ratio;parton_flavour;emFraction_RecoJet;sumEt_Gen;sumEt_Reco;PhiDelta;RDelta;nextRDelta;whichmuon;ptinnerTracker;PUWeight;PUWeightUp;PUWeightDown", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------------------
static void constructor_16946( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >();
  else ::new(mem) ::std::vector<std::vector<int> >();
}

static void constructor_16947( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::allocator<std::vector<int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::allocator<std::vector<int> >*)arg[0]);
}

static void constructor_16948( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1],
      *(const ::std::allocator<std::vector<int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1],
      *(const ::std::allocator<std::vector<int> >*)arg[2]);
  }
}

static void constructor_16949( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::vector<std::vector<int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::vector<std::vector<int> >*)arg[0]);
}

static void destructor_16950(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<int> >*)o)->::std::vector<std::vector<int> >::~vector)();
}
static  void operator_16951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->operator=)(*(const ::std::vector<std::vector<int> >*)arg[0]);
  else   (((::std::vector<std::vector<int> >*)o)->operator=)(*(const ::std::vector<std::vector<int> >*)arg[0]);
}

static  void method_16952( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<int>*)arg[1]);
}

static  void method_16953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->begin)());
  else   (((::std::vector<std::vector<int> >*)o)->begin)();
}

static  void method_16954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > >)((((const ::std::vector<std::vector<int> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<int> >*)o)->begin)();
}

static  void method_16955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->end)());
  else   (((::std::vector<std::vector<int> >*)o)->end)();
}

static  void method_16956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > >)((((const ::std::vector<std::vector<int> >*)o)->end)());
  else   (((const ::std::vector<std::vector<int> >*)o)->end)();
}

static  void method_16961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<int> >*)o)->size)());
  else   (((const ::std::vector<std::vector<int> >*)o)->size)();
}

static  void method_16962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<int> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<int> >*)o)->max_size)();
}

static  void method_16963( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<int>*)arg[1]);
  }
}

static  void method_16964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<int> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<int> >*)o)->capacity)();
}

static  void method_16965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<int> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<int> >*)o)->empty)();
}

static  void method_16966( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_16967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_16968( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_16970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_16971( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_16972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->front)();
  else   (((::std::vector<std::vector<int> >*)o)->front)();
}

static  void method_16973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->front)();
  else   (((const ::std::vector<std::vector<int> >*)o)->front)();
}

static  void method_16974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->back)();
  else   (((::std::vector<std::vector<int> >*)o)->back)();
}

static  void method_16975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->back)();
  else   (((const ::std::vector<std::vector<int> >*)o)->back)();
}

static  void method_16976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<int> >*)o)->data)());
  else   (((::std::vector<std::vector<int> >*)o)->data)();
}

static  void method_16977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<int> >*)o)->data)());
  else   (((const ::std::vector<std::vector<int> >*)o)->data)();
}

static  void method_16978( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->push_back)(*(const ::std::vector<int>*)arg[0]);
}

static  void method_16979( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<int> >*)o)->pop_back)();
}

static  void method_16980( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(const ::std::vector<int>*)arg[1]));
  else   (((::std::vector<std::vector<int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(const ::std::vector<int>*)arg[1]);
}

static  void method_16981( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<int>*)arg[2]);
}

static  void method_16982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0]));
  else   (((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0]);
}

static  void method_16983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[1]));
  else   (((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[1]);
}

static  void method_16984( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->swap)(*(::std::vector<std::vector<int> >*)arg[0]);
}

static  void method_16985( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<int> >*)o)->clear)();
}

static void method_newdel_3222( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<int> >,::std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<int> > >::Generate();
}

//------Dictionary for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------------------
void __std__vector_std__vector_int_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_int_s__datamem_bld(&__std__vector_std__vector_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_int_s__funcmem_bld(&__std__vector_std__vector_int_s__db_funcmem);
void __std__vector_std__vector_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<int> >"), typeid(::std::vector<std::vector<int> >), sizeof(::std::vector<std::vector<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2547, ::Reflex::BaseOffset< ::std::vector<std::vector<int> >, ::std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3223, Reflex::Literal("std::vector<std::vector<int> >::_Alloc_value_type"))
  .AddTypedef(type_2547, Reflex::Literal("std::vector<std::vector<int> >::_Base"))
  .AddTypedef(type_3610, Reflex::Literal("std::vector<std::vector<int> >::_Tp_alloc_type"))
  .AddTypedef(type_3223, Reflex::Literal("std::vector<std::vector<int> >::value_type"))
  .AddTypedef(type_16931, Reflex::Literal("std::vector<std::vector<int> >::pointer"))
  .AddTypedef(type_16933, Reflex::Literal("std::vector<std::vector<int> >::const_pointer"))
  .AddTypedef(type_16935, Reflex::Literal("std::vector<std::vector<int> >::reference"))
  .AddTypedef(type_16937, Reflex::Literal("std::vector<std::vector<int> >::const_reference"))
  .AddTypedef(type_9806, Reflex::Literal("std::vector<std::vector<int> >::iterator"))
  .AddTypedef(type_9807, Reflex::Literal("std::vector<std::vector<int> >::const_iterator"))
  .AddTypedef(type_3990, Reflex::Literal("std::vector<std::vector<int> >::const_reverse_iterator"))
  .AddTypedef(type_3991, Reflex::Literal("std::vector<std::vector<int> >::reverse_iterator"))
  .AddTypedef(type_3594, Reflex::Literal("std::vector<std::vector<int> >::size_type"))
  .AddTypedef(type_3452, Reflex::Literal("std::vector<std::vector<int> >::difference_type"))
  .AddTypedef(type_3610, Reflex::Literal("std::vector<std::vector<int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_16946, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_46370), Reflex::Literal("vector"), constructor_16947, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3594, type_16937, type_46370), Reflex::Literal("vector"), constructor_16948, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_48478), Reflex::Literal("vector"), constructor_16949, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_16950, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3222, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_int_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------
void __std__vector_std__vector_int_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------
void __std__vector_std__vector_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_48479, type_48478), Reflex::Literal("operator="), operator_16951, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_3594, type_16937), Reflex::Literal("assign"), method_16952, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9806), Reflex::Literal("begin"), method_16953, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9807), Reflex::Literal("begin"), method_16954, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9806), Reflex::Literal("end"), method_16955, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9807), Reflex::Literal("end"), method_16956, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3594), Reflex::Literal("size"), method_16961, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3594), Reflex::Literal("max_size"), method_16962, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_3594, type_3223), Reflex::Literal("resize"), method_16963, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3594), Reflex::Literal("capacity"), method_16964, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("empty"), method_16965, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_3594), Reflex::Literal("reserve"), method_16966, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16935, type_3594), Reflex::Literal("operator[]"), operator_16967, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16937, type_3594), Reflex::Literal("operator[]"), operator_16968, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16935, type_3594), Reflex::Literal("at"), method_16970, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16937, type_3594), Reflex::Literal("at"), method_16971, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16935), Reflex::Literal("front"), method_16972, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16937), Reflex::Literal("front"), method_16973, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16935), Reflex::Literal("back"), method_16974, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16937), Reflex::Literal("back"), method_16975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16931), Reflex::Literal("data"), method_16976, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16933), Reflex::Literal("data"), method_16977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_16937), Reflex::Literal("push_back"), method_16978, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401), Reflex::Literal("pop_back"), method_16979, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9806, type_9806, type_16937), Reflex::Literal("insert"), method_16980, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_9806, type_3594, type_16937), Reflex::Literal("insert"), method_16981, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9806, type_9806), Reflex::Literal("erase"), method_16982, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9806, type_9806, type_9806), Reflex::Literal("erase"), method_16983, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_48479), Reflex::Literal("swap"), method_16984, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401), Reflex::Literal("clear"), method_16985, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Association<edm::View<reco::Candidate> > -------------------------------
static void destructor_35087(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Association<edm::View<reco::Candidate> >*)o)->::edm::Association<edm::View<reco::Candidate> >::~Association)();
}
static void constructor_35088( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<edm::View<reco::Candidate> >(*(const ::edm::Association<edm::View<reco::Candidate> >*)arg[0]);
  else ::new(mem) ::edm::Association<edm::View<reco::Candidate> >(*(const ::edm::Association<edm::View<reco::Candidate> >*)arg[0]);
}

static void constructor_35089( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Association<edm::View<reco::Candidate> >();
  else ::new(mem) ::edm::Association<edm::View<reco::Candidate> >();
}

static  void method_35090( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<edm::View<reco::Candidate>,reco::Candidate,edm::refhelper::FindUsingAdvance<edm::View<reco::Candidate>,reco::Candidate> >)((((const ::edm::Association<edm::View<reco::Candidate> >*)o)->get)(*(::size_t*)arg[0]));
  else   (((const ::edm::Association<edm::View<reco::Candidate> >*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_35091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<edm::View<reco::Candidate>,reco::Candidate,edm::refhelper::FindUsingAdvance<edm::View<reco::Candidate>,reco::Candidate> >)((((const ::edm::Association<edm::View<reco::Candidate> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::Association<edm::View<reco::Candidate> >*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_35092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<edm::View<reco::Candidate> >*)o)->operator+=)(*(const ::edm::Association<edm::View<reco::Candidate> >*)arg[0]);
  else   (((::edm::Association<edm::View<reco::Candidate> >*)o)->operator+=)(*(const ::edm::Association<edm::View<reco::Candidate> >*)arg[0]);
}

static  void method_35093( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<edm::View<reco::Candidate> >*)o)->setRef)(*(const ::edm::RefProd<edm::View<reco::Candidate> >*)arg[0]);
}

static  void method_35094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<edm::View<reco::Candidate> >*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::Association<edm::View<reco::Candidate> >*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_35095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::Association<edm::View<reco::Candidate> >*)o)->size)());
  else   (((const ::edm::Association<edm::View<reco::Candidate> >*)o)->size)();
}

static  void method_35096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Association<edm::View<reco::Candidate> >*)o)->empty)());
  else   (((const ::edm::Association<edm::View<reco::Candidate> >*)o)->empty)();
}

static  void method_35097( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::Association<edm::View<reco::Candidate> >*)o)->clear)();
}

static  void method_35098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefProd<edm::View<reco::Candidate> >)((((const ::edm::Association<edm::View<reco::Candidate> >*)o)->ref)());
  else   (((const ::edm::Association<edm::View<reco::Candidate> >*)o)->ref)();
}

static  void method_35099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::Association<edm::View<reco::Candidate> >*)o)->swap)(*(::edm::Association<edm::View<reco::Candidate> >*)arg[0]);
}

static  void operator_35100( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Association<edm::View<reco::Candidate> >*)o)->operator=)(*(const ::edm::Association<edm::View<reco::Candidate> >*)arg[0]);
  else   (((::edm::Association<edm::View<reco::Candidate> >*)o)->operator=)(*(const ::edm::Association<edm::View<reco::Candidate> >*)arg[0]);
}

static  void method_35101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Association<edm::View<reco::Candidate> >*)o)->ids)();
  else   (((const ::edm::Association<edm::View<reco::Candidate> >*)o)->ids)();
}

static  void method_35102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Association<edm::View<reco::Candidate> >*)o)->Class_Version)());
  else   (((::edm::Association<edm::View<reco::Candidate> >*)o)->Class_Version)();
}

static void method_newdel_6486( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Association<edm::View<reco::Candidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Association<edm::View<reco::Candidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Association<edm::View<reco::Candidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Association<edm::View<reco::Candidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Association<edm::View<reco::Candidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>")), ::Reflex::BaseOffset< ::edm::Association<edm::View<reco::Candidate> >,::edm::ValueMap<int> >::Get(),::Reflex::PRIVATE), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Association<edm::View<reco::Candidate> > -------------------------------
void __edm__Association_edm__View_reco__Candidate_s__db_datamem(Reflex::Class*);
void __edm__Association_edm__View_reco__Candidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Association_edm__View_reco__Candidate_s__datamem_bld(&__edm__Association_edm__View_reco__Candidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Association_edm__View_reco__Candidate_s__funcmem_bld(&__edm__Association_edm__View_reco__Candidate_s__db_funcmem);
void __edm__Association_edm__View_reco__Candidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Association<edm::View<reco::Candidate> >"), typeid(::edm::Association<edm::View<reco::Candidate> >), sizeof(::edm::Association<edm::View<reco::Candidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Association<edm::View<reco::Candidate> >::Class_Version())
  .AddBase(type_6395, ::Reflex::BaseOffset< ::edm::Association<edm::View<reco::Candidate> >, ::edm::ValueMap<int> >::Get(), ::Reflex::PRIVATE)
  .AddTypedef(type_72, Reflex::Literal("edm::Association<edm::View<reco::Candidate> >::index"))
  .AddTypedef(type_6395, Reflex::Literal("edm::Association<edm::View<reco::Candidate> >::base"))
  .AddTypedef(type_378, Reflex::Literal("edm::Association<edm::View<reco::Candidate> >::offset"))
  .AddTypedef(type_6399, Reflex::Literal("edm::Association<edm::View<reco::Candidate> >::refprod_type"))
  .AddTypedef(type_6492, Reflex::Literal("edm::Association<edm::View<reco::Candidate> >::reference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Association"), destructor_35087, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55666), Reflex::Literal("Association"), constructor_35088, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Association"), constructor_35089, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6486, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Association_edm__View_reco__Candidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Association_edm__View_reco__Candidate_s__funcmem_bld);
}

//------Delayed data member builder for class Association<edm::View<reco::Candidate> > -------------------
void __edm__Association_edm__View_reco__Candidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6399, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__Association_edm__View_reco__Candidate_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Association<edm::View<reco::Candidate> > -------------------
void __edm__Association_edm__View_reco__Candidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6492, type_2177), Reflex::Literal("get"), method_35090, 0, "rawIdx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6492, type_6619, type_2177), Reflex::Literal("get"), method_35091, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55667, type_55666), Reflex::Literal("operator+="), operator_35092, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_55619), Reflex::Literal("setRef"), method_35093, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637, type_6619), Reflex::Literal("contains"), method_35094, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2177), Reflex::Literal("size"), method_35095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("empty"), method_35096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401), Reflex::Literal("clear"), method_35097, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6399), Reflex::Literal("ref"), method_35098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_55667), Reflex::Literal("swap"), method_35099, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55667, type_55666), Reflex::Literal("operator="), operator_35100, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_48471), Reflex::Literal("ids"), method_35101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_89), Reflex::Literal("Class_Version"), method_35102, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::Association<edm::View<reco::Candidate> > > -------------------------------
static void constructor_33886( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >();
  else ::new(mem) ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >();
}

static void constructor_33887( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >(*(::std::auto_ptr<edm::Association<edm::View<reco::Candidate> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >(*(::std::auto_ptr<edm::Association<edm::View<reco::Candidate> > >*)arg[0]);
}

static void destructor_33888(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >::~Wrapper)();
}
static  void method_33889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->product)();
}

static  void operator_33890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->operator->)();
}

static  void method_33891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->productTypeInfo)();
}

static  void method_33892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->typeInfo)();
}

static void constructor_33893( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >((::edm::Association<edm::View<reco::Candidate> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >((::edm::Association<edm::View<reco::Candidate> >*)arg[0]);
}

static  void method_33894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->getInterface)();
}

static  void method_33895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_33896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_33897( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_33898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->dynamicTypeInfo)();
}

static  void method_33899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->isPresent)();
}

static  void method_33900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6135( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::Association<edm::View<reco::Candidate> > > -------------------------------
void __edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s__datamem_bld(&__edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s__funcmem_bld(&__edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s__db_funcmem);
void __edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >"), typeid(::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >), sizeof(::edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_6486, Reflex::Literal("edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >::value_type"))
  .AddTypedef(type_6486, Reflex::Literal("edm::Wrapper<edm::Association<edm::View<reco::Candidate> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_33886, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2929), Reflex::Literal("Wrapper"), constructor_33887, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_33888, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55334), Reflex::Literal("Wrapper"), constructor_33893, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6135, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::Association<edm::View<reco::Candidate> > > -------------------
void __edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1637, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6486, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::Association<edm::View<reco::Candidate> > > -------------------
void __edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55333), Reflex::Literal("product"), method_33889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55333), Reflex::Literal("operator->"), operator_33890, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("productTypeInfo"), method_33891, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("typeInfo"), method_33892, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55335), Reflex::Literal("getInterface"), method_33894, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_29200, type_29276, type_49747), Reflex::Literal("fillView"), method_33895, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_9227, type_369, type_13610), Reflex::Literal("setPtr"), method_33896, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_9227, type_37151, type_29276), Reflex::Literal("fillPtrVector"), method_33897, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("dynamicTypeInfo"), method_33898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isPresent"), method_33899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("dynamicTypeInfo_"), method_33900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefToBaseVector<pat::Jet> -------------------------------
static void constructor_34176( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBaseVector<pat::Jet>();
  else ::new(mem) ::edm::RefToBaseVector<pat::Jet>();
}

static void constructor_34177( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBaseVector<pat::Jet>(*(const ::edm::RefToBaseVector<pat::Jet>*)arg[0]);
  else ::new(mem) ::edm::RefToBaseVector<pat::Jet>(*(const ::edm::RefToBaseVector<pat::Jet>*)arg[0]);
}

static void constructor_34178( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBaseVector<pat::Jet>(*(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[0]);
  else ::new(mem) ::edm::RefToBaseVector<pat::Jet>(*(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[0]);
}

static  void operator_34179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefToBaseVector<pat::Jet>*)o)->operator=)(*(const ::edm::RefToBaseVector<pat::Jet>*)arg[0]);
  else   (((::edm::RefToBaseVector<pat::Jet>*)o)->operator=)(*(const ::edm::RefToBaseVector<pat::Jet>*)arg[0]);
}

static  void method_34180( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefToBaseVector<pat::Jet>*)o)->swap)(*(::edm::RefToBaseVector<pat::Jet>*)arg[0]);
}

static void destructor_34181(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefToBaseVector<pat::Jet>*)o)->::edm::RefToBaseVector<pat::Jet>::~RefToBaseVector)();
}
static  void method_34182( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefToBaseVector<pat::Jet>*)o)->clear)();
}

static  void method_34183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefToBase<pat::Jet>)((((const ::edm::RefToBaseVector<pat::Jet>*)o)->at)(*(::size_t*)arg[0]));
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->at)(*(::size_t*)arg[0]);
}

static  void operator_34184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefToBase<pat::Jet>)((((const ::edm::RefToBaseVector<pat::Jet>*)o)->operator[])(*(::size_t*)arg[0]));
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_34185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBaseVector<pat::Jet>*)o)->isValid)());
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->isValid)();
}

static  void method_34186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBaseVector<pat::Jet>*)o)->isInvalid)());
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->isInvalid)();
}

static  void method_34187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBaseVector<pat::Jet>*)o)->empty)());
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->empty)();
}

static  void method_34188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::RefToBaseVector<pat::Jet>*)o)->size)());
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->size)();
}

static  void method_34189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefToBaseVector<pat::Jet>*)o)->id)());
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->id)();
}

static  void method_34190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefToBaseVector<pat::Jet>*)o)->productGetter)());
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->productGetter)();
}

static  void method_34191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<pat::Jet>::const_iterator)((((const ::edm::RefToBaseVector<pat::Jet>*)o)->begin)());
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->begin)();
}

static  void method_34192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<pat::Jet>::const_iterator)((((const ::edm::RefToBaseVector<pat::Jet>*)o)->end)());
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->end)();
}

static  void method_34193( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefToBaseVector<pat::Jet>*)o)->push_back)(*(const ::edm::RefToBase<pat::Jet>*)arg[0]);
}

static  void method_34194( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefToBaseVector<pat::Jet>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_34195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::RefToBaseVector<pat::Jet>*)o)->vectorHolder)());
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->vectorHolder)();
}

static  void method_34196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefToBaseVector<pat::Jet>*)o)->product)());
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->product)();
}

static  void method_34197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBaseVector<pat::Jet>*)o)->isAvailable)());
  else   (((const ::edm::RefToBaseVector<pat::Jet>*)o)->isAvailable)();
}

static  void method_34198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefToBaseVector<pat::Jet>*)o)->Class_Version)());
  else   (((::edm::RefToBaseVector<pat::Jet>*)o)->Class_Version)();
}

static void method_newdel_6197( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<pat::Jet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<pat::Jet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<pat::Jet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<pat::Jet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<pat::Jet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefToBaseVector<pat::Jet> -------------------------------
void __edm__RefToBaseVector_pat__Jet__db_datamem(Reflex::Class*);
void __edm__RefToBaseVector_pat__Jet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefToBaseVector_pat__Jet__datamem_bld(&__edm__RefToBaseVector_pat__Jet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefToBaseVector_pat__Jet__funcmem_bld(&__edm__RefToBaseVector_pat__Jet__db_funcmem);
void __edm__RefToBaseVector_pat__Jet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefToBaseVector<pat::Jet>"), typeid(::edm::RefToBaseVector<pat::Jet>), sizeof(::edm::RefToBaseVector<pat::Jet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefToBaseVector<pat::Jet>::Class_Version())
  .AddTypedef(type_6452, Reflex::Literal("edm::RefToBaseVector<pat::Jet>::value_type"))
  .AddTypedef(type_10549, Reflex::Literal("edm::RefToBaseVector<pat::Jet>::member_type"))
  .AddTypedef(type_34057, Reflex::Literal("edm::RefToBaseVector<pat::Jet>::holder_type"))
  .AddTypedef(type_2177, Reflex::Literal("edm::RefToBaseVector<pat::Jet>::size_type"))
  .AddTypedef(type_34174, Reflex::Literal("edm::RefToBaseVector<pat::Jet>::const_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefToBaseVector"), constructor_34176, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55506), Reflex::Literal("RefToBaseVector"), constructor_34177, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5216), Reflex::Literal("RefToBaseVector"), constructor_34178, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefToBaseVector"), destructor_34181, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6197, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefToBaseVector_pat__Jet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefToBaseVector_pat__Jet__funcmem_bld);
}

//------Delayed data member builder for class RefToBaseVector<pat::Jet> -------------------
void __edm__RefToBaseVector_pat__Jet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_55505, Reflex::Literal("holder_"), OffsetOf(__shadow__::__edm__RefToBaseVector_pat__Jet_, holder_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefToBaseVector<pat::Jet> -------------------
void __edm__RefToBaseVector_pat__Jet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55507, type_55506), Reflex::Literal("operator="), operator_34179, 0, "iRHS", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_55507), Reflex::Literal("swap"), method_34180, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401), Reflex::Literal("clear"), method_34182, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6452, type_2177), Reflex::Literal("at"), method_34183, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6452, type_2177), Reflex::Literal("operator[]"), operator_34184, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isValid"), method_34185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isInvalid"), method_34186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("empty"), method_34187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2177), Reflex::Literal("size"), method_34188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6619), Reflex::Literal("id"), method_34189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29272), Reflex::Literal("productGetter"), method_34190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34174), Reflex::Literal("begin"), method_34191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34174), Reflex::Literal("end"), method_34192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_55508), Reflex::Literal("push_back"), method_34193, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_29276), Reflex::Literal("fillView"), method_34194, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2930), Reflex::Literal("vectorHolder"), method_34195, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4784), Reflex::Literal("product"), method_34196, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isAvailable"), method_34197, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_89), Reflex::Literal("Class_Version"), method_34198, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::RefToBaseVector<pat::Jet> > -------------------------------
static void constructor_33907( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >();
  else ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >();
}

static void constructor_33908( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >(*(::std::auto_ptr<edm::RefToBaseVector<pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >(*(::std::auto_ptr<edm::RefToBaseVector<pat::Jet> >*)arg[0]);
}

static void destructor_33909(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >::~Wrapper)();
}
static  void method_33910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->product)();
}

static  void operator_33911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->operator->)();
}

static  void method_33912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->productTypeInfo)();
}

static  void method_33913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->typeInfo)();
}

static void constructor_33914( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >((::edm::RefToBaseVector<pat::Jet>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >((::edm::RefToBaseVector<pat::Jet>*)arg[0]);
}

static  void method_33915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->getInterface)();
}

static  void method_33916( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_33917( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_33918( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_33919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->dynamicTypeInfo)();
}

static  void method_33920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->isPresent)();
}

static  void method_33921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6136( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<pat::Jet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefToBaseVector<pat::Jet> > -------------------------------
void __edm__Wrapper_edm__RefToBaseVector_pat__Jet_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefToBaseVector_pat__Jet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefToBaseVector_pat__Jet_s__datamem_bld(&__edm__Wrapper_edm__RefToBaseVector_pat__Jet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefToBaseVector_pat__Jet_s__funcmem_bld(&__edm__Wrapper_edm__RefToBaseVector_pat__Jet_s__db_funcmem);
void __edm__Wrapper_edm__RefToBaseVector_pat__Jet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefToBaseVector<pat::Jet> >"), typeid(::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >), sizeof(::edm::Wrapper<edm::RefToBaseVector<pat::Jet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_6197, Reflex::Literal("edm::Wrapper<edm::RefToBaseVector<pat::Jet> >::value_type"))
  .AddTypedef(type_6197, Reflex::Literal("edm::Wrapper<edm::RefToBaseVector<pat::Jet> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_33907, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2931), Reflex::Literal("Wrapper"), constructor_33908, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_33909, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55339), Reflex::Literal("Wrapper"), constructor_33914, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6136, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefToBaseVector_pat__Jet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefToBaseVector_pat__Jet_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefToBaseVector<pat::Jet> > -------------------
void __edm__Wrapper_edm__RefToBaseVector_pat__Jet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1637, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefToBaseVector_pat__Jet_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6197, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefToBaseVector_pat__Jet_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefToBaseVector<pat::Jet> > -------------------
void __edm__Wrapper_edm__RefToBaseVector_pat__Jet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55338), Reflex::Literal("product"), method_33910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55338), Reflex::Literal("operator->"), operator_33911, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("productTypeInfo"), method_33912, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("typeInfo"), method_33913, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55340), Reflex::Literal("getInterface"), method_33915, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_29200, type_29276, type_49747), Reflex::Literal("fillView"), method_33916, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_9227, type_369, type_13610), Reflex::Literal("setPtr"), method_33917, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_9227, type_37151, type_29276), Reflex::Literal("fillPtrVector"), method_33918, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("dynamicTypeInfo"), method_33919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isPresent"), method_33920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("dynamicTypeInfo_"), method_33921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefToBaseVector<pat::Muon> -------------------------------
static void constructor_34206( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBaseVector<pat::Muon>();
  else ::new(mem) ::edm::RefToBaseVector<pat::Muon>();
}

static void constructor_34207( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBaseVector<pat::Muon>(*(const ::edm::RefToBaseVector<pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::RefToBaseVector<pat::Muon>(*(const ::edm::RefToBaseVector<pat::Muon>*)arg[0]);
}

static void constructor_34208( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBaseVector<pat::Muon>(*(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[0]);
  else ::new(mem) ::edm::RefToBaseVector<pat::Muon>(*(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[0]);
}

static  void operator_34209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefToBaseVector<pat::Muon>*)o)->operator=)(*(const ::edm::RefToBaseVector<pat::Muon>*)arg[0]);
  else   (((::edm::RefToBaseVector<pat::Muon>*)o)->operator=)(*(const ::edm::RefToBaseVector<pat::Muon>*)arg[0]);
}

static  void method_34210( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefToBaseVector<pat::Muon>*)o)->swap)(*(::edm::RefToBaseVector<pat::Muon>*)arg[0]);
}

static void destructor_34211(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefToBaseVector<pat::Muon>*)o)->::edm::RefToBaseVector<pat::Muon>::~RefToBaseVector)();
}
static  void method_34212( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefToBaseVector<pat::Muon>*)o)->clear)();
}

static  void method_34213( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefToBase<pat::Muon>)((((const ::edm::RefToBaseVector<pat::Muon>*)o)->at)(*(::size_t*)arg[0]));
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->at)(*(::size_t*)arg[0]);
}

static  void operator_34214( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefToBase<pat::Muon>)((((const ::edm::RefToBaseVector<pat::Muon>*)o)->operator[])(*(::size_t*)arg[0]));
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_34215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBaseVector<pat::Muon>*)o)->isValid)());
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->isValid)();
}

static  void method_34216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBaseVector<pat::Muon>*)o)->isInvalid)());
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->isInvalid)();
}

static  void method_34217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBaseVector<pat::Muon>*)o)->empty)());
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->empty)();
}

static  void method_34218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::RefToBaseVector<pat::Muon>*)o)->size)());
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->size)();
}

static  void method_34219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefToBaseVector<pat::Muon>*)o)->id)());
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->id)();
}

static  void method_34220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefToBaseVector<pat::Muon>*)o)->productGetter)());
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->productGetter)();
}

static  void method_34221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<pat::Muon>::const_iterator)((((const ::edm::RefToBaseVector<pat::Muon>*)o)->begin)());
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->begin)();
}

static  void method_34222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<pat::Muon>::const_iterator)((((const ::edm::RefToBaseVector<pat::Muon>*)o)->end)());
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->end)();
}

static  void method_34223( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefToBaseVector<pat::Muon>*)o)->push_back)(*(const ::edm::RefToBase<pat::Muon>*)arg[0]);
}

static  void method_34224( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefToBaseVector<pat::Muon>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_34225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::RefToBaseVector<pat::Muon>*)o)->vectorHolder)());
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->vectorHolder)();
}

static  void method_34226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefToBaseVector<pat::Muon>*)o)->product)());
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->product)();
}

static  void method_34227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBaseVector<pat::Muon>*)o)->isAvailable)());
  else   (((const ::edm::RefToBaseVector<pat::Muon>*)o)->isAvailable)();
}

static  void method_34228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefToBaseVector<pat::Muon>*)o)->Class_Version)());
  else   (((::edm::RefToBaseVector<pat::Muon>*)o)->Class_Version)();
}

static void method_newdel_6198( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<pat::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<pat::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<pat::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<pat::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<pat::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefToBaseVector<pat::Muon> -------------------------------
void __edm__RefToBaseVector_pat__Muon__db_datamem(Reflex::Class*);
void __edm__RefToBaseVector_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefToBaseVector_pat__Muon__datamem_bld(&__edm__RefToBaseVector_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefToBaseVector_pat__Muon__funcmem_bld(&__edm__RefToBaseVector_pat__Muon__db_funcmem);
void __edm__RefToBaseVector_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefToBaseVector<pat::Muon>"), typeid(::edm::RefToBaseVector<pat::Muon>), sizeof(::edm::RefToBaseVector<pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefToBaseVector<pat::Muon>::Class_Version())
  .AddTypedef(type_6453, Reflex::Literal("edm::RefToBaseVector<pat::Muon>::value_type"))
  .AddTypedef(type_10537, Reflex::Literal("edm::RefToBaseVector<pat::Muon>::member_type"))
  .AddTypedef(type_34058, Reflex::Literal("edm::RefToBaseVector<pat::Muon>::holder_type"))
  .AddTypedef(type_2177, Reflex::Literal("edm::RefToBaseVector<pat::Muon>::size_type"))
  .AddTypedef(type_34204, Reflex::Literal("edm::RefToBaseVector<pat::Muon>::const_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefToBaseVector"), constructor_34206, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55510), Reflex::Literal("RefToBaseVector"), constructor_34207, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5216), Reflex::Literal("RefToBaseVector"), constructor_34208, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefToBaseVector"), destructor_34211, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6198, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefToBaseVector_pat__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefToBaseVector_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class RefToBaseVector<pat::Muon> -------------------
void __edm__RefToBaseVector_pat__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_55509, Reflex::Literal("holder_"), OffsetOf(__shadow__::__edm__RefToBaseVector_pat__Muon_, holder_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefToBaseVector<pat::Muon> -------------------
void __edm__RefToBaseVector_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55511, type_55510), Reflex::Literal("operator="), operator_34209, 0, "iRHS", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_55511), Reflex::Literal("swap"), method_34210, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401), Reflex::Literal("clear"), method_34212, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6453, type_2177), Reflex::Literal("at"), method_34213, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6453, type_2177), Reflex::Literal("operator[]"), operator_34214, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isValid"), method_34215, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isInvalid"), method_34216, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("empty"), method_34217, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2177), Reflex::Literal("size"), method_34218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6619), Reflex::Literal("id"), method_34219, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29272), Reflex::Literal("productGetter"), method_34220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34204), Reflex::Literal("begin"), method_34221, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34204), Reflex::Literal("end"), method_34222, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_55512), Reflex::Literal("push_back"), method_34223, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_29276), Reflex::Literal("fillView"), method_34224, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2930), Reflex::Literal("vectorHolder"), method_34225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4784), Reflex::Literal("product"), method_34226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isAvailable"), method_34227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_89), Reflex::Literal("Class_Version"), method_34228, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::RefToBaseVector<pat::Muon> > -------------------------------
static void constructor_33928( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >();
  else ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >();
}

static void constructor_33929( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >(*(::std::auto_ptr<edm::RefToBaseVector<pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >(*(::std::auto_ptr<edm::RefToBaseVector<pat::Muon> >*)arg[0]);
}

static void destructor_33930(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >::~Wrapper)();
}
static  void method_33931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->product)();
}

static  void operator_33932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->operator->)();
}

static  void method_33933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->productTypeInfo)();
}

static  void method_33934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->typeInfo)();
}

static void constructor_33935( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >((::edm::RefToBaseVector<pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >((::edm::RefToBaseVector<pat::Muon>*)arg[0]);
}

static  void method_33936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->getInterface)();
}

static  void method_33937( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_33938( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_33939( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_33940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->dynamicTypeInfo)();
}

static  void method_33941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->isPresent)();
}

static  void method_33942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6137( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefToBaseVector<pat::Muon> > -------------------------------
void __edm__Wrapper_edm__RefToBaseVector_pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefToBaseVector_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefToBaseVector_pat__Muon_s__datamem_bld(&__edm__Wrapper_edm__RefToBaseVector_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefToBaseVector_pat__Muon_s__funcmem_bld(&__edm__Wrapper_edm__RefToBaseVector_pat__Muon_s__db_funcmem);
void __edm__Wrapper_edm__RefToBaseVector_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefToBaseVector<pat::Muon> >"), typeid(::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >), sizeof(::edm::Wrapper<edm::RefToBaseVector<pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_6198, Reflex::Literal("edm::Wrapper<edm::RefToBaseVector<pat::Muon> >::value_type"))
  .AddTypedef(type_6198, Reflex::Literal("edm::Wrapper<edm::RefToBaseVector<pat::Muon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_33928, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2932), Reflex::Literal("Wrapper"), constructor_33929, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_33930, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55344), Reflex::Literal("Wrapper"), constructor_33935, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6137, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefToBaseVector_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefToBaseVector_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefToBaseVector<pat::Muon> > -------------------
void __edm__Wrapper_edm__RefToBaseVector_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1637, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefToBaseVector_pat__Muon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6198, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefToBaseVector_pat__Muon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefToBaseVector<pat::Muon> > -------------------
void __edm__Wrapper_edm__RefToBaseVector_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55343), Reflex::Literal("product"), method_33931, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55343), Reflex::Literal("operator->"), operator_33932, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("productTypeInfo"), method_33933, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("typeInfo"), method_33934, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55345), Reflex::Literal("getInterface"), method_33936, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_29200, type_29276, type_49747), Reflex::Literal("fillView"), method_33937, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_9227, type_369, type_13610), Reflex::Literal("setPtr"), method_33938, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_9227, type_37151, type_29276), Reflex::Literal("fillPtrVector"), method_33939, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("dynamicTypeInfo"), method_33940, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isPresent"), method_33941, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("dynamicTypeInfo_"), method_33942, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > > -------------------------------
static void constructor_33949( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<int> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<int> > >();
}

static void constructor_33950( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<int> > >(*(::std::auto_ptr<std::vector<std::vector<int> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<int> > >(*(::std::auto_ptr<std::vector<std::vector<int> > >*)arg[0]);
}

static void destructor_33951(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<std::vector<int> > >*)o)->::edm::Wrapper<std::vector<std::vector<int> > >::~Wrapper)();
}
static  void method_33952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->product)();
}

static  void operator_33953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->operator->)();
}

static  void method_33954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::vector<int> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<std::vector<int> > >*)o)->productTypeInfo)();
}

static  void method_33955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::vector<int> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<std::vector<int> > >*)o)->typeInfo)();
}

static void constructor_33956( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::vector<int> > >((::std::vector<std::vector<int> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::vector<int> > >((::std::vector<std::vector<int> >*)arg[0]);
}

static  void method_33957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<std::vector<int> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<std::vector<int> > >*)o)->getInterface)();
}

static  void method_33958( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_33959( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_33960( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_33961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->dynamicTypeInfo)();
}

static  void method_33962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->isPresent)();
}

static  void method_33963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<std::vector<int> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6138( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<int> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<int> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<int> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<int> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::vector<int> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > > -------------------------------
void __edm__Wrapper_std__vector_std__vector_int_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_std__vector_int_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__vector_int_s_s__datamem_bld(&__edm__Wrapper_std__vector_std__vector_int_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__vector_int_s_s__funcmem_bld(&__edm__Wrapper_std__vector_std__vector_int_s_s__db_funcmem);
void __edm__Wrapper_std__vector_std__vector_int_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::vector<int> > >"), typeid(::edm::Wrapper<std::vector<std::vector<int> > >), sizeof(::edm::Wrapper<std::vector<std::vector<int> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3222, Reflex::Literal("edm::Wrapper<std::vector<std::vector<int> > >::value_type"))
  .AddTypedef(type_3222, Reflex::Literal("edm::Wrapper<std::vector<std::vector<int> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_33949, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2933), Reflex::Literal("Wrapper"), constructor_33950, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_33951, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55349), Reflex::Literal("Wrapper"), constructor_33956, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_std__vector_int_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_std__vector_int_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > > -------------------
void __edm__Wrapper_std__vector_std__vector_int_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1637, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__vector_int_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3222, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__vector_int_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > > -------------------
void __edm__Wrapper_std__vector_std__vector_int_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55348), Reflex::Literal("product"), method_33952, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55348), Reflex::Literal("operator->"), operator_33953, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("productTypeInfo"), method_33954, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("typeInfo"), method_33955, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55350), Reflex::Literal("getInterface"), method_33957, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_29200, type_29276, type_49747), Reflex::Literal("fillView"), method_33958, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_9227, type_369, type_13610), Reflex::Literal("setPtr"), method_33959, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_9227, type_37151, type_29276), Reflex::Literal("fillPtrVector"), method_33960, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("dynamicTypeInfo"), method_33961, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isPresent"), method_33962, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9227), Reflex::Literal("dynamicTypeInfo_"), method_33963, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefProd<edm::View<reco::Candidate> > -------------------------------
static  void operator_34666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<edm::View<reco::Candidate> >*)o)->operator=)(*(const ::edm::RefProd<edm::View<reco::Candidate> >*)arg[0]);
  else   (((::edm::RefProd<edm::View<reco::Candidate> >*)o)->operator=)(*(const ::edm::RefProd<edm::View<reco::Candidate> >*)arg[0]);
}

static void constructor_34667( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >(*(const ::edm::RefProd<edm::View<reco::Candidate> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >(*(const ::edm::RefProd<edm::View<reco::Candidate> >*)arg[0]);
}

static void constructor_34668( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >();
  else ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >();
}

static void constructor_34669( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >(*(const ::edm::Handle<edm::View<reco::Candidate> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >(*(const ::edm::Handle<edm::View<reco::Candidate> >*)arg[0]);
}

static void constructor_34670( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >(*(const ::edm::OrphanHandle<edm::View<reco::Candidate> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >(*(const ::edm::OrphanHandle<edm::View<reco::Candidate> >*)arg[0]);
}

static void constructor_34671( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >((const ::edm::View<reco::Candidate>*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >((const ::edm::View<reco::Candidate>*)arg[0]);
}

static void constructor_34672( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >(*(const ::edm::TestHandle<edm::View<reco::Candidate> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >(*(const ::edm::TestHandle<edm::View<reco::Candidate> >*)arg[0]);
}

static void constructor_34673( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<edm::View<reco::Candidate> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_34674(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<edm::View<reco::Candidate> >*)o)->::edm::RefProd<edm::View<reco::Candidate> >::~RefProd)();
}
static  void operator_34675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->operator*)();
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->operator*)();
}

static  void operator_34676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->operator->)());
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->operator->)();
}

static  void method_34677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->get)());
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->get)();
}

static  void method_34678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->product)());
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->product)();
}

static  void method_34679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->refCore)();
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->refCore)();
}

static  void method_34680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->isNull)());
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->isNull)();
}

static  void method_34681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->isNonnull)();
}

static  void operator_34682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->operator!)());
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->operator!)();
}

static  void method_34683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->id)());
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->id)();
}

static  void method_34684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->productGetter)();
}

static  void method_34685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->hasCache)();
}

static  void method_34686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->hasProductCache)();
}

static  void method_34687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->isAvailable)();
}

static  void method_34688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<edm::View<reco::Candidate> >*)o)->isTransient)();
}

static  void method_34689( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<edm::View<reco::Candidate> >*)o)->swap)(*(::edm::RefProd<edm::View<reco::Candidate> >*)arg[0]);
}

static  void method_34690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<edm::View<reco::Candidate> >*)o)->Class_Version)());
  else   (((::edm::RefProd<edm::View<reco::Candidate> >*)o)->Class_Version)();
}

static void method_newdel_6399( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::View<reco::Candidate> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::View<reco::Candidate> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::View<reco::Candidate> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::View<reco::Candidate> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::View<reco::Candidate> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<edm::View<reco::Candidate> > -------------------------------
void __edm__RefProd_edm__View_reco__Candidate_s__db_datamem(Reflex::Class*);
void __edm__RefProd_edm__View_reco__Candidate_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_edm__View_reco__Candidate_s__datamem_bld(&__edm__RefProd_edm__View_reco__Candidate_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_edm__View_reco__Candidate_s__funcmem_bld(&__edm__RefProd_edm__View_reco__Candidate_s__db_funcmem);
void __edm__RefProd_edm__View_reco__Candidate_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<edm::View<reco::Candidate> >"), typeid(::edm::RefProd<edm::View<reco::Candidate> >), sizeof(::edm::RefProd<edm::View<reco::Candidate> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<edm::View<reco::Candidate> >::Class_Version())
  .AddTypedef(type_6315, Reflex::Literal("edm::RefProd<edm::View<reco::Candidate> >::product_type"))
  .AddTypedef(type_6315, Reflex::Literal("edm::RefProd<edm::View<reco::Candidate> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55618, type_55619), Reflex::Literal("operator="), operator_34666, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55619), Reflex::Literal("RefProd"), constructor_34667, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_34668, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55620), Reflex::Literal("RefProd"), constructor_34669, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55621), Reflex::Literal("RefProd"), constructor_34670, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55622), Reflex::Literal("RefProd"), constructor_34671, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55623), Reflex::Literal("RefProd"), constructor_34672, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29200, type_29272), Reflex::Literal("RefProd"), constructor_34673, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_34674, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6399, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_edm__View_reco__Candidate_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_edm__View_reco__Candidate_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<edm::View<reco::Candidate> > -------------------
void __edm__RefProd_edm__View_reco__Candidate_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6373, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_edm__View_reco__Candidate_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<edm::View<reco::Candidate> > -------------------
void __edm__RefProd_edm__View_reco__Candidate_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55547), Reflex::Literal("operator*"), operator_34675, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55622), Reflex::Literal("operator->"), operator_34676, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55622), Reflex::Literal("get"), method_34677, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55622), Reflex::Literal("product"), method_34678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29335), Reflex::Literal("refCore"), method_34679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isNull"), method_34680, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isNonnull"), method_34681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("operator!"), operator_34682, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6619), Reflex::Literal("id"), method_34683, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29272), Reflex::Literal("productGetter"), method_34684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("hasCache"), method_34685, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("hasProductCache"), method_34686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isAvailable"), method_34687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isTransient"), method_34688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_55618), Reflex::Literal("swap"), method_34689, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_89), Reflex::Literal("Class_Version"), method_34690, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class BaseVectorHolder<pat::Jet> -------------------------------
static  void operator_55404( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->operator=)(*(const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)arg[0]);
  else   (((::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->operator=)(*(const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)arg[0]);
}

static void destructor_55407(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->::edm::reftobase::BaseVectorHolder<pat::Jet>::~BaseVectorHolder)();
}
static  void method_55408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->clone)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->clone)();
}

static  void method_55409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->cloneEmpty)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->cloneEmpty)();
}

static  void method_55410( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefToBase<pat::Jet>)((((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->at)(*(::size_t*)arg[0]));
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_55411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->empty)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->empty)();
}

static  void method_55412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->size)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->size)();
}

static  void method_55413( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->clear)();
}

static  void method_55414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->id)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->id)();
}

static  void method_55415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->productGetter)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->productGetter)();
}

static  void method_55416( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->swap)(*(::edm::reftobase::BaseVectorHolder<pat::Jet>*)arg[0]);
}

static  void method_55417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<pat::Jet>::const_iterator)((((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->begin)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->begin)();
}

static  void method_55418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<pat::Jet>::const_iterator)((((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->end)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->end)();
}

static  void method_55419( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->push_back)((const ::edm::reftobase::BaseHolder<pat::Jet>*)arg[0]);
}

static  void method_55420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->vectorHolder)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->vectorHolder)();
}

static  void method_55421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->product)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->product)();
}

static  void method_55422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->isAvailable)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->isAvailable)();
}

static  void method_55423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->Class_Version)());
  else   (((::edm::reftobase::BaseVectorHolder<pat::Jet>*)o)->Class_Version)();
}

//------Dictionary for class BaseVectorHolder<pat::Jet> -------------------------------
void __edm__reftobase__BaseVectorHolder_pat__Jet__db_datamem(Reflex::Class*);
void __edm__reftobase__BaseVectorHolder_pat__Jet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__BaseVectorHolder_pat__Jet__datamem_bld(&__edm__reftobase__BaseVectorHolder_pat__Jet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__BaseVectorHolder_pat__Jet__funcmem_bld(&__edm__reftobase__BaseVectorHolder_pat__Jet__db_funcmem);
void __edm__reftobase__BaseVectorHolder_pat__Jet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<pat::Jet>"), typeid(::edm::reftobase::BaseVectorHolder<pat::Jet>), sizeof(::edm::reftobase::BaseVectorHolder<pat::Jet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::BaseVectorHolder<pat::Jet>::Class_Version())
  .AddTypedef(type_2177, Reflex::Literal("edm::reftobase::BaseVectorHolder<pat::Jet>::size_type"))
  .AddTypedef(type_10549, Reflex::Literal("edm::reftobase::BaseVectorHolder<pat::Jet>::element_type"))
  .AddTypedef(type_6452, Reflex::Literal("edm::reftobase::BaseVectorHolder<pat::Jet>::base_ref_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_61516, type_61517), Reflex::Literal("operator="), operator_55404, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BaseVectorHolder"), destructor_55407, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__BaseVectorHolder_pat__Jet__funcmem_bld);
}

//------Delayed data member builder for class BaseVectorHolder<pat::Jet> -------------------
void __edm__reftobase__BaseVectorHolder_pat__Jet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class BaseVectorHolder<pat::Jet> -------------------
void __edm__reftobase__BaseVectorHolder_pat__Jet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55505), Reflex::Literal("clone"), method_55408, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55505), Reflex::Literal("cloneEmpty"), method_55409, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6452c, type_2177), Reflex::Literal("at"), method_55410, 0, "idx", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("empty"), method_55411, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2177), Reflex::Literal("size"), method_55412, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401), Reflex::Literal("clear"), method_55413, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6619), Reflex::Literal("id"), method_55414, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29272), Reflex::Literal("productGetter"), method_55415, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_61516), Reflex::Literal("swap"), method_55416, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34174), Reflex::Literal("begin"), method_55417, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34174), Reflex::Literal("end"), method_55418, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_61519), Reflex::Literal("push_back"), method_55419, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2930), Reflex::Literal("vectorHolder"), method_55420, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4784), Reflex::Literal("product"), method_55421, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isAvailable"), method_55422, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_89), Reflex::Literal("Class_Version"), method_55423, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class BaseVectorHolder<pat::Muon> -------------------------------
static  void operator_55428( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->operator=)(*(const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)arg[0]);
  else   (((::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->operator=)(*(const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)arg[0]);
}

static void destructor_55431(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->::edm::reftobase::BaseVectorHolder<pat::Muon>::~BaseVectorHolder)();
}
static  void method_55432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->clone)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->clone)();
}

static  void method_55433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->cloneEmpty)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->cloneEmpty)();
}

static  void method_55434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefToBase<pat::Muon>)((((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->at)(*(::size_t*)arg[0]));
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_55435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->empty)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->empty)();
}

static  void method_55436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->size)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->size)();
}

static  void method_55437( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->clear)();
}

static  void method_55438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->id)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->id)();
}

static  void method_55439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->productGetter)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->productGetter)();
}

static  void method_55440( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->swap)(*(::edm::reftobase::BaseVectorHolder<pat::Muon>*)arg[0]);
}

static  void method_55441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<pat::Muon>::const_iterator)((((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->begin)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->begin)();
}

static  void method_55442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<pat::Muon>::const_iterator)((((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->end)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->end)();
}

static  void method_55443( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->push_back)((const ::edm::reftobase::BaseHolder<pat::Muon>*)arg[0]);
}

static  void method_55444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->vectorHolder)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->vectorHolder)();
}

static  void method_55445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->product)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->product)();
}

static  void method_55446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->isAvailable)());
  else   (((const ::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->isAvailable)();
}

static  void method_55447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->Class_Version)());
  else   (((::edm::reftobase::BaseVectorHolder<pat::Muon>*)o)->Class_Version)();
}

//------Dictionary for class BaseVectorHolder<pat::Muon> -------------------------------
void __edm__reftobase__BaseVectorHolder_pat__Muon__db_datamem(Reflex::Class*);
void __edm__reftobase__BaseVectorHolder_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__BaseVectorHolder_pat__Muon__datamem_bld(&__edm__reftobase__BaseVectorHolder_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__BaseVectorHolder_pat__Muon__funcmem_bld(&__edm__reftobase__BaseVectorHolder_pat__Muon__db_funcmem);
void __edm__reftobase__BaseVectorHolder_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<pat::Muon>"), typeid(::edm::reftobase::BaseVectorHolder<pat::Muon>), sizeof(::edm::reftobase::BaseVectorHolder<pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::BaseVectorHolder<pat::Muon>::Class_Version())
  .AddTypedef(type_2177, Reflex::Literal("edm::reftobase::BaseVectorHolder<pat::Muon>::size_type"))
  .AddTypedef(type_10537, Reflex::Literal("edm::reftobase::BaseVectorHolder<pat::Muon>::element_type"))
  .AddTypedef(type_6453, Reflex::Literal("edm::reftobase::BaseVectorHolder<pat::Muon>::base_ref_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_61520, type_61521), Reflex::Literal("operator="), operator_55428, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BaseVectorHolder"), destructor_55431, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__BaseVectorHolder_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class BaseVectorHolder<pat::Muon> -------------------
void __edm__reftobase__BaseVectorHolder_pat__Muon__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class BaseVectorHolder<pat::Muon> -------------------
void __edm__reftobase__BaseVectorHolder_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55509), Reflex::Literal("clone"), method_55432, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55509), Reflex::Literal("cloneEmpty"), method_55433, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6453c, type_2177), Reflex::Literal("at"), method_55434, 0, "idx", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("empty"), method_55435, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2177), Reflex::Literal("size"), method_55436, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401), Reflex::Literal("clear"), method_55437, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6619), Reflex::Literal("id"), method_55438, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29272), Reflex::Literal("productGetter"), method_55439, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_61520), Reflex::Literal("swap"), method_55440, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34204), Reflex::Literal("begin"), method_55441, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34204), Reflex::Literal("end"), method_55442, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1401, type_61523), Reflex::Literal("push_back"), method_55443, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2930), Reflex::Literal("vectorHolder"), method_55444, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4784), Reflex::Literal("product"), method_55445, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("isAvailable"), method_55446, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_89), Reflex::Literal("Class_Version"), method_55447, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __ResolutionVariables_dict(); 
      __std__vector_std__vector_int_s__dict(); 
      __edm__Association_edm__View_reco__Candidate_s__dict(); 
      __edm__Wrapper_edm__Association_edm__View_reco__Candidate_s_s__dict(); 
      __edm__RefToBaseVector_pat__Jet__dict(); 
      __edm__Wrapper_edm__RefToBaseVector_pat__Jet_s__dict(); 
      __edm__RefToBaseVector_pat__Muon__dict(); 
      __edm__Wrapper_edm__RefToBaseVector_pat__Muon_s__dict(); 
      __edm__Wrapper_std__vector_std__vector_int_s_s__dict(); 
      __edm__RefProd_edm__View_reco__Candidate_s__dict(); 
      __edm__reftobase__BaseVectorHolder_pat__Jet__dict(); 
      __edm__reftobase__BaseVectorHolder_pat__Muon__dict(); 
    }
    ~Dictionaries() {
      type_235.Unload(); // class ResolutionVariables 
      type_3222.Unload(); // class std::vector<std::vector<int> > 
      type_6486.Unload(); // class edm::Association<edm::View<reco::Candidate> > 
      type_6135.Unload(); // class edm::Wrapper<edm::Association<edm::View<reco::Candidate> > > 
      type_6197.Unload(); // class edm::RefToBaseVector<pat::Jet> 
      type_6136.Unload(); // class edm::Wrapper<edm::RefToBaseVector<pat::Jet> > 
      type_6198.Unload(); // class edm::RefToBaseVector<pat::Muon> 
      type_6137.Unload(); // class edm::Wrapper<edm::RefToBaseVector<pat::Muon> > 
      type_6138.Unload(); // class edm::Wrapper<std::vector<std::vector<int> > > 
      type_6399.Unload(); // class edm::RefProd<edm::View<reco::Candidate> > 
      type_34057.Unload(); // class edm::reftobase::BaseVectorHolder<pat::Jet> 
      type_34058.Unload(); // class edm::reftobase::BaseVectorHolder<pat::Muon> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
