// Generated at Thu Jan 16 14:20:43 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/BEAN/Collections/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_58 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_53 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2827 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2862 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_508 = ::Reflex::TypeBuilder(Reflex::Literal("BNjet"));
  ::Reflex::Type type_685 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_868 = ::Reflex::TypeBuilder(Reflex::Literal("BNmet"));
  ::Reflex::Type type_336 = ::Reflex::TypeBuilder(Reflex::Literal("BNmuon"));
  ::Reflex::Type type_1681 = ::Reflex::TypeBuilder(Reflex::Literal("BNtau"));
  ::Reflex::Type type_1698 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_499 = ::Reflex::TypeBuilder(Reflex::Literal("BNevent"));
  ::Reflex::Type type_1488 = ::Reflex::TypeBuilder(Reflex::Literal("BNtrack"));
  ::Reflex::Type type_891 = ::Reflex::TypeBuilder(Reflex::Literal("BNskimbit"));
  ::Reflex::Type type_196 = ::Reflex::TypeBuilder(Reflex::Literal("BNtrigobj"));
  ::Reflex::Type type_796 = ::Reflex::TypeBuilder(Reflex::Literal("BNtrigger"));
  ::Reflex::Type type_1092 = ::Reflex::TypeBuilder(Reflex::Literal("BNlepton"));
  ::Reflex::Type type_1748 = ::Reflex::TypeBuilder(Reflex::Literal("BNgenjet"));
  ::Reflex::Type type_1001 = ::Reflex::TypeBuilder(Reflex::Literal("BNphoton"));
  ::Reflex::Type type_1299 = ::Reflex::TypeBuilder(Reflex::Literal("BNbxlumi"));
  ::Reflex::Type type_843 = ::Reflex::TypeBuilder(Reflex::Literal("SampleProd"));
  ::Reflex::Type type_1510 = ::Reflex::TypeBuilder(Reflex::Literal("BNelectron"));
  ::Reflex::Type type_111 = ::Reflex::TypeBuilder(Reflex::Literal("BNmcparticle"));
  ::Reflex::Type type_243 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_281 = ::Reflex::TypeBuilder(Reflex::Literal("BNsupercluster"));
  ::Reflex::Type type_1965 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_4166 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_1714 = ::Reflex::TypeBuilder(Reflex::Literal("BNprimaryvertex"));
  ::Reflex::Type type_2317 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_2318 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<bool>"));
  ::Reflex::Type type_236 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNjet>"));
  ::Reflex::Type type_68 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNevent>"));
  ::Reflex::Type type_377 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNmuon>"));
  ::Reflex::Type type_1403 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNtau>"));
  ::Reflex::Type type_1621 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNmet>"));
  ::Reflex::Type type_2316 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_171 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNtrack>"));
  ::Reflex::Type type_4068 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNmet>"));
  ::Reflex::Type type_4074 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNjet>"));
  ::Reflex::Type type_4076 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNtau>"));
  ::Reflex::Type type_760 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNgenjet>"));
  ::Reflex::Type type_2083 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNmet>"));
  ::Reflex::Type type_2089 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNjet>"));
  ::Reflex::Type type_2091 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNtau>"));
  ::Reflex::Type type_4066 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNmuon>"));
  ::Reflex::Type type_125 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNskimbit>"));
  ::Reflex::Type type_140 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNtrigobj>"));
  ::Reflex::Type type_186 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNtrigger>"));
  ::Reflex::Type type_2552 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNjet>"));
  ::Reflex::Type type_1306 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNphoton>"));
  ::Reflex::Type type_2553 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNtau>"));
  ::Reflex::Type type_2549 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNmet>"));
  ::Reflex::Type type_1723 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNbxlumi>"));
  ::Reflex::Type type_2315 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNlepton>"));
  ::Reflex::Type type_2081 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNmuon>"));
  ::Reflex::Type type_4058 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNtrack>"));
  ::Reflex::Type type_4072 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNevent>"));
  ::Reflex::Type type_288 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SampleProd>"));
  ::Reflex::Type type_2548 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNmuon>"));
  ::Reflex::Type type_549 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNelectron>"));
  ::Reflex::Type type_2073 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNtrack>"));
  ::Reflex::Type type_2087 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNevent>"));
  ::Reflex::Type type_4048 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNgenjet>"));
  ::Reflex::Type type_4062 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNphoton>"));
  ::Reflex::Type type_4064 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNlepton>"));
  ::Reflex::Type type_4080 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNbxlumi>"));
  ::Reflex::Type type_2551 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNevent>"));
  ::Reflex::Type type_1865 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_2544 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNtrack>"));
  ::Reflex::Type type_2063 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNgenjet>"));
  ::Reflex::Type type_2077 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNphoton>"));
  ::Reflex::Type type_2079 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNlepton>"));
  ::Reflex::Type type_2095 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNbxlumi>"));
  ::Reflex::Type type_4052 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNtrigobj>"));
  ::Reflex::Type type_4054 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNskimbit>"));
  ::Reflex::Type type_4056 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNtrigger>"));
  ::Reflex::Type type_2539 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNgenjet>"));
  ::Reflex::Type type_2546 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNphoton>"));
  ::Reflex::Type type_2555 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNbxlumi>"));
  ::Reflex::Type type_2547 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNlepton>"));
  ::Reflex::Type type_2313 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2067 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNtrigobj>"));
  ::Reflex::Type type_2069 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNskimbit>"));
  ::Reflex::Type type_2071 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNtrigger>"));
  ::Reflex::Type type_4078 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNelectron>"));
  ::Reflex::Type type_4082 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<SampleProd>"));
  ::Reflex::Type type_2542 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNskimbit>"));
  ::Reflex::Type type_2541 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNtrigobj>"));
  ::Reflex::Type type_2543 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNtrigger>"));
  ::Reflex::Type type_1726 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNmcparticle>"));
  ::Reflex::Type type_2093 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNelectron>"));
  ::Reflex::Type type_2097 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<SampleProd>"));
  ::Reflex::Type type_2556 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SampleProd>"));
  ::Reflex::Type type_2554 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNelectron>"));
  ::Reflex::Type type_576 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNsupercluster>"));
  ::Reflex::Type type_2314 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_4070 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNmcparticle>"));
  ::Reflex::Type type_2085 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNmcparticle>"));
  ::Reflex::Type type_1511 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BNprimaryvertex>"));
  ::Reflex::Type type_2550 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNmcparticle>"));
  ::Reflex::Type type_4105 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNmet>"));
  ::Reflex::Type type_4111 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNjet>"));
  ::Reflex::Type type_4113 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNtau>"));
  ::Reflex::Type type_4060 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNsupercluster>"));
  ::Reflex::Type type_2075 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNsupercluster>"));
  ::Reflex::Type type_4103 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNmuon>"));
  ::Reflex::Type type_4050 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BNprimaryvertex>"));
  ::Reflex::Type type_2545 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNsupercluster>"));
  ::Reflex::Type type_2065 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BNprimaryvertex>"));
  ::Reflex::Type type_4095 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNtrack>"));
  ::Reflex::Type type_4109 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNevent>"));
  ::Reflex::Type type_2540 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BNprimaryvertex>"));
  ::Reflex::Type type_4085 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNgenjet>"));
  ::Reflex::Type type_4099 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNphoton>"));
  ::Reflex::Type type_4101 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNlepton>"));
  ::Reflex::Type type_4117 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNbxlumi>"));
  ::Reflex::Type type_4089 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNtrigobj>"));
  ::Reflex::Type type_4091 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNskimbit>"));
  ::Reflex::Type type_4093 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNtrigger>"));
  ::Reflex::Type type_4115 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNelectron>"));
  ::Reflex::Type type_4119 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<SampleProd>"));
  ::Reflex::Type type_4067 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNmet> >"));
  ::Reflex::Type type_4073 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNjet> >"));
  ::Reflex::Type type_4075 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNtau> >"));
  ::Reflex::Type type_2082 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNmet> >"));
  ::Reflex::Type type_2088 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNjet> >"));
  ::Reflex::Type type_2090 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNtau> >"));
  ::Reflex::Type type_4065 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNmuon> >"));
  ::Reflex::Type type_2080 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNmuon> >"));
  ::Reflex::Type type_4107 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNmcparticle>"));
  ::Reflex::Type type_4057 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNtrack> >"));
  ::Reflex::Type type_4071 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNevent> >"));
  ::Reflex::Type type_2072 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNtrack> >"));
  ::Reflex::Type type_2086 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNevent> >"));
  ::Reflex::Type type_4047 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNgenjet> >"));
  ::Reflex::Type type_4061 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNphoton> >"));
  ::Reflex::Type type_4063 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNlepton> >"));
  ::Reflex::Type type_4079 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNbxlumi> >"));
  ::Reflex::Type type_2062 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNgenjet> >"));
  ::Reflex::Type type_4097 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNsupercluster>"));
  ::Reflex::Type type_2076 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNphoton> >"));
  ::Reflex::Type type_2078 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNlepton> >"));
  ::Reflex::Type type_2094 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNbxlumi> >"));
  ::Reflex::Type type_4051 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNtrigobj> >"));
  ::Reflex::Type type_4053 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNskimbit> >"));
  ::Reflex::Type type_4055 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNtrigger> >"));
  ::Reflex::Type type_4087 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BNprimaryvertex>"));
  ::Reflex::Type type_2066 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNtrigobj> >"));
  ::Reflex::Type type_2068 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNskimbit> >"));
  ::Reflex::Type type_2070 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNtrigger> >"));
  ::Reflex::Type type_4077 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNelectron> >"));
  ::Reflex::Type type_4081 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<SampleProd> >"));
  ::Reflex::Type type_2092 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNelectron> >"));
  ::Reflex::Type type_2096 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<SampleProd> >"));
  ::Reflex::Type type_4069 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNmcparticle> >"));
  ::Reflex::Type type_2084 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNmcparticle> >"));
  ::Reflex::Type type_4104 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNmet> >"));
  ::Reflex::Type type_4110 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNjet> >"));
  ::Reflex::Type type_4112 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNtau> >"));
  ::Reflex::Type type_4059 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNsupercluster> >"));
  ::Reflex::Type type_2074 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNsupercluster> >"));
  ::Reflex::Type type_4102 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNmuon> >"));
  ::Reflex::Type type_4049 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNprimaryvertex> >"));
  ::Reflex::Type type_2064 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BNprimaryvertex> >"));
  ::Reflex::Type type_4094 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNtrack> >"));
  ::Reflex::Type type_4108 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNevent> >"));
  ::Reflex::Type type_4084 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNgenjet> >"));
  ::Reflex::Type type_4098 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNphoton> >"));
  ::Reflex::Type type_4100 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNlepton> >"));
  ::Reflex::Type type_4116 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNbxlumi> >"));
  ::Reflex::Type type_4088 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNtrigobj> >"));
  ::Reflex::Type type_4090 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNskimbit> >"));
  ::Reflex::Type type_4092 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNtrigger> >"));
  ::Reflex::Type type_1837 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNjet,std::allocator<BNjet> >"));
  ::Reflex::Type type_1838 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNtau,std::allocator<BNtau> >"));
  ::Reflex::Type type_1834 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNmet,std::allocator<BNmet> >"));
  ::Reflex::Type type_4114 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNelectron> >"));
  ::Reflex::Type type_4118 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<SampleProd> >"));
  ::Reflex::Type type_1833 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNmuon,std::allocator<BNmuon> >"));
  ::Reflex::Type type_4106 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNmcparticle> >"));
  ::Reflex::Type type_1836 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNevent,std::allocator<BNevent> >"));
  ::Reflex::Type type_1829 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNtrack,std::allocator<BNtrack> >"));
  ::Reflex::Type type_4096 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNsupercluster> >"));
  ::Reflex::Type type_4086 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BNprimaryvertex> >"));
  ::Reflex::Type type_1824 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNgenjet,std::allocator<BNgenjet> >"));
  ::Reflex::Type type_1831 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNphoton,std::allocator<BNphoton> >"));
  ::Reflex::Type type_1840 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNbxlumi,std::allocator<BNbxlumi> >"));
  ::Reflex::Type type_1832 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNlepton,std::allocator<BNlepton> >"));
  ::Reflex::Type type_3497 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_1827 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNskimbit,std::allocator<BNskimbit> >"));
  ::Reflex::Type type_1826 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNtrigobj,std::allocator<BNtrigobj> >"));
  ::Reflex::Type type_1828 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNtrigger,std::allocator<BNtrigger> >"));
  ::Reflex::Type type_3384 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >"));
  ::Reflex::Type type_5443 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >"));
  ::Reflex::Type type_5586 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >"));
  ::Reflex::Type type_1841 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SampleProd,std::allocator<SampleProd> >"));
  ::Reflex::Type type_1839 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNelectron,std::allocator<BNelectron> >"));
  ::Reflex::Type type_4315 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >"));
  ::Reflex::Type type_2880 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >"));
  ::Reflex::Type type_3207 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >"));
  ::Reflex::Type type_1835 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNmcparticle,std::allocator<BNmcparticle> >"));
  ::Reflex::Type type_3386 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNjet*,std::vector<BNjet> >"));
  ::Reflex::Type type_4945 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >"));
  ::Reflex::Type type_5375 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >"));
  ::Reflex::Type type_5445 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNtau*,std::vector<BNtau> >"));
  ::Reflex::Type type_5587 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNmet*,std::vector<BNmet> >"));
  ::Reflex::Type type_5590 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >"));
  ::Reflex::Type type_5584 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >"));
  ::Reflex::Type type_3058 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >"));
  ::Reflex::Type type_3128 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >"));
  ::Reflex::Type type_3279 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >"));
  ::Reflex::Type type_4317 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNmuon*,std::vector<BNmuon> >"));
  ::Reflex::Type type_1830 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNsupercluster,std::allocator<BNsupercluster> >"));
  ::Reflex::Type type_2882 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNevent*,std::vector<BNevent> >"));
  ::Reflex::Type type_3209 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNtrack*,std::vector<BNtrack> >"));
  ::Reflex::Type type_3975 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >"));
  ::Reflex::Type type_4783 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >"));
  ::Reflex::Type type_1825 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNprimaryvertex,std::allocator<BNprimaryvertex> >"));
  ::Reflex::Type type_4947 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNgenjet*,std::vector<BNgenjet> >"));
  ::Reflex::Type type_5377 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNphoton*,std::vector<BNphoton> >"));
  ::Reflex::Type type_5591 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNbxlumi*,std::vector<BNbxlumi> >"));
  ::Reflex::Type type_5585 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNlepton*,std::vector<BNlepton> >"));
  ::Reflex::Type type_3060 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNskimbit*,std::vector<BNskimbit> >"));
  ::Reflex::Type type_3130 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNtrigobj*,std::vector<BNtrigobj> >"));
  ::Reflex::Type type_3281 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNtrigger*,std::vector<BNtrigger> >"));
  ::Reflex::Type type_5588 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >"));
  ::Reflex::Type type_3977 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SampleProd*,std::vector<SampleProd> >"));
  ::Reflex::Type type_4785 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNelectron*,std::vector<BNelectron> >"));
  ::Reflex::Type type_4851 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >"));
  ::Reflex::Type type_5582 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >"));
  ::Reflex::Type type_5589 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNmcparticle*,std::vector<BNmcparticle> >"));
  ::Reflex::Type type_2708 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> > >"));
  ::Reflex::Type type_4853 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNsupercluster*,std::vector<BNsupercluster> >"));
  ::Reflex::Type type_2710 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> > >"));
  ::Reflex::Type type_2702 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> > >"));
  ::Reflex::Type type_2700 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> > >"));
  ::Reflex::Type type_5583 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BNprimaryvertex*,std::vector<BNprimaryvertex> >"));
  ::Reflex::Type type_2706 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> > >"));
  ::Reflex::Type type_2692 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> > >"));
  ::Reflex::Type type_2707 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNjet*,std::vector<BNjet> > >"));
  ::Reflex::Type type_2682 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> > >"));
  ::Reflex::Type type_2696 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> > >"));
  ::Reflex::Type type_2709 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNtau*,std::vector<BNtau> > >"));
  ::Reflex::Type type_2701 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNmet*,std::vector<BNmet> > >"));
  ::Reflex::Type type_2714 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> > >"));
  ::Reflex::Type type_2698 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> > >"));
  ::Reflex::Type type_2688 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> > >"));
  ::Reflex::Type type_2686 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> > >"));
  ::Reflex::Type type_2690 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> > >"));
  ::Reflex::Type type_2699 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNmuon*,std::vector<BNmuon> > >"));
  ::Reflex::Type type_2705 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNevent*,std::vector<BNevent> > >"));
  ::Reflex::Type type_2691 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNtrack*,std::vector<BNtrack> > >"));
  ::Reflex::Type type_2716 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> > >"));
  ::Reflex::Type type_2712 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> > >"));
  ::Reflex::Type type_2681 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNgenjet*,std::vector<BNgenjet> > >"));
  ::Reflex::Type type_2695 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNphoton*,std::vector<BNphoton> > >"));
  ::Reflex::Type type_2713 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNbxlumi*,std::vector<BNbxlumi> > >"));
  ::Reflex::Type type_2697 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNlepton*,std::vector<BNlepton> > >"));
  ::Reflex::Type type_2687 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNskimbit*,std::vector<BNskimbit> > >"));
  ::Reflex::Type type_2685 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNtrigobj*,std::vector<BNtrigobj> > >"));
  ::Reflex::Type type_2689 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNtrigger*,std::vector<BNtrigger> > >"));
  ::Reflex::Type type_2704 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> > >"));
  ::Reflex::Type type_2715 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SampleProd*,std::vector<SampleProd> > >"));
  ::Reflex::Type type_2711 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNelectron*,std::vector<BNelectron> > >"));
  ::Reflex::Type type_2694 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> > >"));
  ::Reflex::Type type_2684 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> > >"));
  ::Reflex::Type type_2703 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNmcparticle*,std::vector<BNmcparticle> > >"));
  ::Reflex::Type type_2693 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNsupercluster*,std::vector<BNsupercluster> > >"));
  ::Reflex::Type type_2683 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BNprimaryvertex*,std::vector<BNprimaryvertex> > >"));
  ::Reflex::Type type_2876 = ::Reflex::ReferenceBuilder(type_499);
  ::Reflex::Type type_499c = ::Reflex::ConstBuilder(type_499);
  ::Reflex::Type type_2878 = ::Reflex::ReferenceBuilder(type_499c);
  ::Reflex::Type type_2872 = ::Reflex::PointerBuilder(type_499);
  ::Reflex::Type type_2874 = ::Reflex::PointerBuilder(type_499c);
  ::Reflex::Type type_2521 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_243);
  ::Reflex::Type type_2421 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_53);
  ::Reflex::Type type_2551c = ::Reflex::ConstBuilder(type_2551);
  ::Reflex::Type type_13660 = ::Reflex::ReferenceBuilder(type_2551c);
  ::Reflex::Type type_68c = ::Reflex::ConstBuilder(type_68);
  ::Reflex::Type type_13661 = ::Reflex::ReferenceBuilder(type_68c);
  ::Reflex::Type type_13662 = ::Reflex::ReferenceBuilder(type_68);
  ::Reflex::Type type_6299 = ::Reflex::ReferenceBuilder(type_111);
  ::Reflex::Type type_111c = ::Reflex::ConstBuilder(type_111);
  ::Reflex::Type type_6301 = ::Reflex::ReferenceBuilder(type_111c);
  ::Reflex::Type type_3054 = ::Reflex::ReferenceBuilder(type_891);
  ::Reflex::Type type_891c = ::Reflex::ConstBuilder(type_891);
  ::Reflex::Type type_3056 = ::Reflex::ReferenceBuilder(type_891c);
  ::Reflex::Type type_3050 = ::Reflex::PointerBuilder(type_891);
  ::Reflex::Type type_3052 = ::Reflex::PointerBuilder(type_891c);
  ::Reflex::Type type_2542c = ::Reflex::ConstBuilder(type_2542);
  ::Reflex::Type type_13716 = ::Reflex::ReferenceBuilder(type_2542c);
  ::Reflex::Type type_125c = ::Reflex::ConstBuilder(type_125);
  ::Reflex::Type type_13717 = ::Reflex::ReferenceBuilder(type_125c);
  ::Reflex::Type type_13718 = ::Reflex::ReferenceBuilder(type_125);
  ::Reflex::Type type_1866 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_1865);
  ::Reflex::Type type_3124 = ::Reflex::ReferenceBuilder(type_196);
  ::Reflex::Type type_196c = ::Reflex::ConstBuilder(type_196);
  ::Reflex::Type type_3126 = ::Reflex::ReferenceBuilder(type_196c);
  ::Reflex::Type type_3120 = ::Reflex::PointerBuilder(type_196);
  ::Reflex::Type type_3122 = ::Reflex::PointerBuilder(type_196c);
  ::Reflex::Type type_2541c = ::Reflex::ConstBuilder(type_2541);
  ::Reflex::Type type_13721 = ::Reflex::ReferenceBuilder(type_2541c);
  ::Reflex::Type type_140c = ::Reflex::ConstBuilder(type_140);
  ::Reflex::Type type_13722 = ::Reflex::ReferenceBuilder(type_140c);
  ::Reflex::Type type_13723 = ::Reflex::ReferenceBuilder(type_140);
  ::Reflex::Type type_3203 = ::Reflex::ReferenceBuilder(type_1488);
  ::Reflex::Type type_1488c = ::Reflex::ConstBuilder(type_1488);
  ::Reflex::Type type_3205 = ::Reflex::ReferenceBuilder(type_1488c);
  ::Reflex::Type type_3199 = ::Reflex::PointerBuilder(type_1488);
  ::Reflex::Type type_3201 = ::Reflex::PointerBuilder(type_1488c);
  ::Reflex::Type type_2544c = ::Reflex::ConstBuilder(type_2544);
  ::Reflex::Type type_13731 = ::Reflex::ReferenceBuilder(type_2544c);
  ::Reflex::Type type_171c = ::Reflex::ConstBuilder(type_171);
  ::Reflex::Type type_13732 = ::Reflex::ReferenceBuilder(type_171c);
  ::Reflex::Type type_13733 = ::Reflex::ReferenceBuilder(type_171);
  ::Reflex::Type type_3275 = ::Reflex::ReferenceBuilder(type_796);
  ::Reflex::Type type_796c = ::Reflex::ConstBuilder(type_796);
  ::Reflex::Type type_3277 = ::Reflex::ReferenceBuilder(type_796c);
  ::Reflex::Type type_3271 = ::Reflex::PointerBuilder(type_796);
  ::Reflex::Type type_3273 = ::Reflex::PointerBuilder(type_796c);
  ::Reflex::Type type_2543c = ::Reflex::ConstBuilder(type_2543);
  ::Reflex::Type type_13735 = ::Reflex::ReferenceBuilder(type_2543c);
  ::Reflex::Type type_186c = ::Reflex::ConstBuilder(type_186);
  ::Reflex::Type type_13736 = ::Reflex::ReferenceBuilder(type_186c);
  ::Reflex::Type type_13737 = ::Reflex::ReferenceBuilder(type_186);
  ::Reflex::Type type_3380 = ::Reflex::ReferenceBuilder(type_508);
  ::Reflex::Type type_508c = ::Reflex::ConstBuilder(type_508);
  ::Reflex::Type type_3382 = ::Reflex::ReferenceBuilder(type_508c);
  ::Reflex::Type type_3376 = ::Reflex::PointerBuilder(type_508);
  ::Reflex::Type type_3378 = ::Reflex::PointerBuilder(type_508c);
  ::Reflex::Type type_2552c = ::Reflex::ConstBuilder(type_2552);
  ::Reflex::Type type_13743 = ::Reflex::ReferenceBuilder(type_2552c);
  ::Reflex::Type type_236c = ::Reflex::ConstBuilder(type_236);
  ::Reflex::Type type_13744 = ::Reflex::ReferenceBuilder(type_236c);
  ::Reflex::Type type_13745 = ::Reflex::ReferenceBuilder(type_236);
  ::Reflex::Type type_4847 = ::Reflex::ReferenceBuilder(type_281);
  ::Reflex::Type type_281c = ::Reflex::ConstBuilder(type_281);
  ::Reflex::Type type_4849 = ::Reflex::ReferenceBuilder(type_281c);
  ::Reflex::Type type_3971 = ::Reflex::ReferenceBuilder(type_843);
  ::Reflex::Type type_843c = ::Reflex::ConstBuilder(type_843);
  ::Reflex::Type type_3973 = ::Reflex::ReferenceBuilder(type_843c);
  ::Reflex::Type type_3967 = ::Reflex::PointerBuilder(type_843);
  ::Reflex::Type type_3969 = ::Reflex::PointerBuilder(type_843c);
  ::Reflex::Type type_2556c = ::Reflex::ConstBuilder(type_2556);
  ::Reflex::Type type_16404 = ::Reflex::ReferenceBuilder(type_2556c);
  ::Reflex::Type type_288c = ::Reflex::ConstBuilder(type_288);
  ::Reflex::Type type_16405 = ::Reflex::ReferenceBuilder(type_288c);
  ::Reflex::Type type_16406 = ::Reflex::ReferenceBuilder(type_288);
  ::Reflex::Type type_4311 = ::Reflex::ReferenceBuilder(type_336);
  ::Reflex::Type type_336c = ::Reflex::ConstBuilder(type_336);
  ::Reflex::Type type_4313 = ::Reflex::ReferenceBuilder(type_336c);
  ::Reflex::Type type_4307 = ::Reflex::PointerBuilder(type_336);
  ::Reflex::Type type_4309 = ::Reflex::PointerBuilder(type_336c);
  ::Reflex::Type type_2548c = ::Reflex::ConstBuilder(type_2548);
  ::Reflex::Type type_17594 = ::Reflex::ReferenceBuilder(type_2548c);
  ::Reflex::Type type_377c = ::Reflex::ConstBuilder(type_377);
  ::Reflex::Type type_17595 = ::Reflex::ReferenceBuilder(type_377c);
  ::Reflex::Type type_17596 = ::Reflex::ReferenceBuilder(type_377);
  ::Reflex::Type type_4779 = ::Reflex::ReferenceBuilder(type_1510);
  ::Reflex::Type type_1510c = ::Reflex::ConstBuilder(type_1510);
  ::Reflex::Type type_4781 = ::Reflex::ReferenceBuilder(type_1510c);
  ::Reflex::Type type_4775 = ::Reflex::PointerBuilder(type_1510);
  ::Reflex::Type type_4777 = ::Reflex::PointerBuilder(type_1510c);
  ::Reflex::Type type_2554c = ::Reflex::ConstBuilder(type_2554);
  ::Reflex::Type type_17777 = ::Reflex::ReferenceBuilder(type_2554c);
  ::Reflex::Type type_549c = ::Reflex::ConstBuilder(type_549);
  ::Reflex::Type type_17778 = ::Reflex::ReferenceBuilder(type_549c);
  ::Reflex::Type type_17779 = ::Reflex::ReferenceBuilder(type_549);
  ::Reflex::Type type_4843 = ::Reflex::PointerBuilder(type_281);
  ::Reflex::Type type_4845 = ::Reflex::PointerBuilder(type_281c);
  ::Reflex::Type type_2545c = ::Reflex::ConstBuilder(type_2545);
  ::Reflex::Type type_17781 = ::Reflex::ReferenceBuilder(type_2545c);
  ::Reflex::Type type_576c = ::Reflex::ConstBuilder(type_576);
  ::Reflex::Type type_17782 = ::Reflex::ReferenceBuilder(type_576c);
  ::Reflex::Type type_17783 = ::Reflex::ReferenceBuilder(type_576);
  ::Reflex::Type type_4941 = ::Reflex::ReferenceBuilder(type_1748);
  ::Reflex::Type type_1748c = ::Reflex::ConstBuilder(type_1748);
  ::Reflex::Type type_4943 = ::Reflex::ReferenceBuilder(type_1748c);
  ::Reflex::Type type_4937 = ::Reflex::PointerBuilder(type_1748);
  ::Reflex::Type type_4939 = ::Reflex::PointerBuilder(type_1748c);
  ::Reflex::Type type_2539c = ::Reflex::ConstBuilder(type_2539);
  ::Reflex::Type type_17795 = ::Reflex::ReferenceBuilder(type_2539c);
  ::Reflex::Type type_760c = ::Reflex::ConstBuilder(type_760);
  ::Reflex::Type type_17796 = ::Reflex::ReferenceBuilder(type_760c);
  ::Reflex::Type type_17797 = ::Reflex::ReferenceBuilder(type_760);
  ::Reflex::Type type_6003 = ::Reflex::ReferenceBuilder(type_868);
  ::Reflex::Type type_868c = ::Reflex::ConstBuilder(type_868);
  ::Reflex::Type type_6005 = ::Reflex::ReferenceBuilder(type_868c);
  ::Reflex::Type type_5371 = ::Reflex::ReferenceBuilder(type_1001);
  ::Reflex::Type type_1001c = ::Reflex::ConstBuilder(type_1001);
  ::Reflex::Type type_5373 = ::Reflex::ReferenceBuilder(type_1001c);
  ::Reflex::Type type_9688 = ::Reflex::ReferenceBuilder(type_1092);
  ::Reflex::Type type_1092c = ::Reflex::ConstBuilder(type_1092);
  ::Reflex::Type type_9690 = ::Reflex::ReferenceBuilder(type_1092c);
  ::Reflex::Type type_6233 = ::Reflex::ReferenceBuilder(type_1299);
  ::Reflex::Type type_1299c = ::Reflex::ConstBuilder(type_1299);
  ::Reflex::Type type_6235 = ::Reflex::ReferenceBuilder(type_1299c);
  ::Reflex::Type type_5367 = ::Reflex::PointerBuilder(type_1001);
  ::Reflex::Type type_5369 = ::Reflex::PointerBuilder(type_1001c);
  ::Reflex::Type type_2546c = ::Reflex::ConstBuilder(type_2546);
  ::Reflex::Type type_17844 = ::Reflex::ReferenceBuilder(type_2546c);
  ::Reflex::Type type_1306c = ::Reflex::ConstBuilder(type_1306);
  ::Reflex::Type type_17845 = ::Reflex::ReferenceBuilder(type_1306c);
  ::Reflex::Type type_17846 = ::Reflex::ReferenceBuilder(type_1306);
  ::Reflex::Type type_5439 = ::Reflex::ReferenceBuilder(type_1681);
  ::Reflex::Type type_1681c = ::Reflex::ConstBuilder(type_1681);
  ::Reflex::Type type_5441 = ::Reflex::ReferenceBuilder(type_1681c);
  ::Reflex::Type type_5435 = ::Reflex::PointerBuilder(type_1681);
  ::Reflex::Type type_5437 = ::Reflex::PointerBuilder(type_1681c);
  ::Reflex::Type type_2553c = ::Reflex::ConstBuilder(type_2553);
  ::Reflex::Type type_17848 = ::Reflex::ReferenceBuilder(type_2553c);
  ::Reflex::Type type_1403c = ::Reflex::ConstBuilder(type_1403);
  ::Reflex::Type type_17849 = ::Reflex::ReferenceBuilder(type_1403c);
  ::Reflex::Type type_17850 = ::Reflex::ReferenceBuilder(type_1403);
  ::Reflex::Type type_5841 = ::Reflex::ReferenceBuilder(type_1714);
  ::Reflex::Type type_1714c = ::Reflex::ConstBuilder(type_1714);
  ::Reflex::Type type_5843 = ::Reflex::ReferenceBuilder(type_1714c);
  ::Reflex::Type type_5837 = ::Reflex::PointerBuilder(type_1714);
  ::Reflex::Type type_5839 = ::Reflex::PointerBuilder(type_1714c);
  ::Reflex::Type type_2540c = ::Reflex::ConstBuilder(type_2540);
  ::Reflex::Type type_19399 = ::Reflex::ReferenceBuilder(type_2540c);
  ::Reflex::Type type_1511c = ::Reflex::ConstBuilder(type_1511);
  ::Reflex::Type type_19400 = ::Reflex::ReferenceBuilder(type_1511c);
  ::Reflex::Type type_19401 = ::Reflex::ReferenceBuilder(type_1511);
  ::Reflex::Type type_5999 = ::Reflex::PointerBuilder(type_868);
  ::Reflex::Type type_6001 = ::Reflex::PointerBuilder(type_868c);
  ::Reflex::Type type_2549c = ::Reflex::ConstBuilder(type_2549);
  ::Reflex::Type type_20301 = ::Reflex::ReferenceBuilder(type_2549c);
  ::Reflex::Type type_1621c = ::Reflex::ConstBuilder(type_1621);
  ::Reflex::Type type_20302 = ::Reflex::ReferenceBuilder(type_1621c);
  ::Reflex::Type type_20303 = ::Reflex::ReferenceBuilder(type_1621);
  ::Reflex::Type type_6229 = ::Reflex::PointerBuilder(type_1299);
  ::Reflex::Type type_6231 = ::Reflex::PointerBuilder(type_1299c);
  ::Reflex::Type type_2555c = ::Reflex::ConstBuilder(type_2555);
  ::Reflex::Type type_20632 = ::Reflex::ReferenceBuilder(type_2555c);
  ::Reflex::Type type_1723c = ::Reflex::ConstBuilder(type_1723);
  ::Reflex::Type type_20633 = ::Reflex::ReferenceBuilder(type_1723c);
  ::Reflex::Type type_20634 = ::Reflex::ReferenceBuilder(type_1723);
  ::Reflex::Type type_6295 = ::Reflex::PointerBuilder(type_111);
  ::Reflex::Type type_6297 = ::Reflex::PointerBuilder(type_111c);
  ::Reflex::Type type_2550c = ::Reflex::ConstBuilder(type_2550);
  ::Reflex::Type type_20636 = ::Reflex::ReferenceBuilder(type_2550c);
  ::Reflex::Type type_1726c = ::Reflex::ConstBuilder(type_1726);
  ::Reflex::Type type_20637 = ::Reflex::ReferenceBuilder(type_1726c);
  ::Reflex::Type type_20638 = ::Reflex::ReferenceBuilder(type_1726);
  ::Reflex::Type type_9684 = ::Reflex::PointerBuilder(type_1092);
  ::Reflex::Type type_9686 = ::Reflex::PointerBuilder(type_1092c);
  ::Reflex::Type type_2547c = ::Reflex::ConstBuilder(type_2547);
  ::Reflex::Type type_20762 = ::Reflex::ReferenceBuilder(type_2547c);
  ::Reflex::Type type_2315c = ::Reflex::ConstBuilder(type_2315);
  ::Reflex::Type type_21537 = ::Reflex::ReferenceBuilder(type_2315c);
  ::Reflex::Type type_21538 = ::Reflex::ReferenceBuilder(type_2315);
  ::Reflex::Type type_25741 = ::Reflex::PointerBuilder(type_760c);
  ::Reflex::Type type_1965c = ::Reflex::ConstBuilder(type_1965);
  ::Reflex::Type type_4030 = ::Reflex::ReferenceBuilder(type_1965c);
  ::Reflex::Type type_25742 = ::Reflex::PointerBuilder(type_760);
  ::Reflex::Type type_4084c = ::Reflex::ConstBuilder(type_4084);
  ::Reflex::Type type_25743 = ::Reflex::PointerBuilder(type_4084c);
  ::Reflex::Type type_4166c = ::Reflex::ConstBuilder(type_4166);
  ::Reflex::Type type_17303 = ::Reflex::ReferenceBuilder(type_4166c);
  ::Reflex::Type type_21533 = ::Reflex::ReferenceBuilder(type_2313);
  ::Reflex::Type type_22146 = ::Reflex::ReferenceBuilder(type_3497);
  ::Reflex::Type type_2827c = ::Reflex::ConstBuilder(type_2827);
  ::Reflex::Type type_3044 = ::Reflex::PointerBuilder(type_2827c);
  ::Reflex::Type type_7491 = ::Reflex::ReferenceBuilder(type_3044);
  ::Reflex::Type type_2314c = ::Reflex::ConstBuilder(type_2314);
  ::Reflex::Type type_21534 = ::Reflex::ReferenceBuilder(type_2314c);
  ::Reflex::Type type_4085c = ::Reflex::ConstBuilder(type_4085);
  ::Reflex::Type type_25746 = ::Reflex::PointerBuilder(type_4085c);
  ::Reflex::Type type_25749 = ::Reflex::PointerBuilder(type_1511c);
  ::Reflex::Type type_25750 = ::Reflex::PointerBuilder(type_1511);
  ::Reflex::Type type_4086c = ::Reflex::ConstBuilder(type_4086);
  ::Reflex::Type type_25751 = ::Reflex::PointerBuilder(type_4086c);
  ::Reflex::Type type_4087c = ::Reflex::ConstBuilder(type_4087);
  ::Reflex::Type type_25754 = ::Reflex::PointerBuilder(type_4087c);
  ::Reflex::Type type_25757 = ::Reflex::PointerBuilder(type_140c);
  ::Reflex::Type type_25758 = ::Reflex::PointerBuilder(type_140);
  ::Reflex::Type type_4088c = ::Reflex::ConstBuilder(type_4088);
  ::Reflex::Type type_25759 = ::Reflex::PointerBuilder(type_4088c);
  ::Reflex::Type type_4089c = ::Reflex::ConstBuilder(type_4089);
  ::Reflex::Type type_25762 = ::Reflex::PointerBuilder(type_4089c);
  ::Reflex::Type type_25765 = ::Reflex::PointerBuilder(type_125c);
  ::Reflex::Type type_25766 = ::Reflex::PointerBuilder(type_125);
  ::Reflex::Type type_4090c = ::Reflex::ConstBuilder(type_4090);
  ::Reflex::Type type_25767 = ::Reflex::PointerBuilder(type_4090c);
  ::Reflex::Type type_4091c = ::Reflex::ConstBuilder(type_4091);
  ::Reflex::Type type_25770 = ::Reflex::PointerBuilder(type_4091c);
  ::Reflex::Type type_25773 = ::Reflex::PointerBuilder(type_186c);
  ::Reflex::Type type_25774 = ::Reflex::PointerBuilder(type_186);
  ::Reflex::Type type_4092c = ::Reflex::ConstBuilder(type_4092);
  ::Reflex::Type type_25775 = ::Reflex::PointerBuilder(type_4092c);
  ::Reflex::Type type_4093c = ::Reflex::ConstBuilder(type_4093);
  ::Reflex::Type type_25778 = ::Reflex::PointerBuilder(type_4093c);
  ::Reflex::Type type_25781 = ::Reflex::PointerBuilder(type_171c);
  ::Reflex::Type type_25782 = ::Reflex::PointerBuilder(type_171);
  ::Reflex::Type type_4094c = ::Reflex::ConstBuilder(type_4094);
  ::Reflex::Type type_25783 = ::Reflex::PointerBuilder(type_4094c);
  ::Reflex::Type type_4095c = ::Reflex::ConstBuilder(type_4095);
  ::Reflex::Type type_25786 = ::Reflex::PointerBuilder(type_4095c);
  ::Reflex::Type type_25789 = ::Reflex::PointerBuilder(type_576c);
  ::Reflex::Type type_25790 = ::Reflex::PointerBuilder(type_576);
  ::Reflex::Type type_4096c = ::Reflex::ConstBuilder(type_4096);
  ::Reflex::Type type_25791 = ::Reflex::PointerBuilder(type_4096c);
  ::Reflex::Type type_4097c = ::Reflex::ConstBuilder(type_4097);
  ::Reflex::Type type_25794 = ::Reflex::PointerBuilder(type_4097c);
  ::Reflex::Type type_25797 = ::Reflex::PointerBuilder(type_1306c);
  ::Reflex::Type type_25798 = ::Reflex::PointerBuilder(type_1306);
  ::Reflex::Type type_4098c = ::Reflex::ConstBuilder(type_4098);
  ::Reflex::Type type_25799 = ::Reflex::PointerBuilder(type_4098c);
  ::Reflex::Type type_4099c = ::Reflex::ConstBuilder(type_4099);
  ::Reflex::Type type_25802 = ::Reflex::PointerBuilder(type_4099c);
  ::Reflex::Type type_25805 = ::Reflex::PointerBuilder(type_2315c);
  ::Reflex::Type type_25806 = ::Reflex::PointerBuilder(type_2315);
  ::Reflex::Type type_4100c = ::Reflex::ConstBuilder(type_4100);
  ::Reflex::Type type_25807 = ::Reflex::PointerBuilder(type_4100c);
  ::Reflex::Type type_4101c = ::Reflex::ConstBuilder(type_4101);
  ::Reflex::Type type_25810 = ::Reflex::PointerBuilder(type_4101c);
  ::Reflex::Type type_25813 = ::Reflex::PointerBuilder(type_377c);
  ::Reflex::Type type_25814 = ::Reflex::PointerBuilder(type_377);
  ::Reflex::Type type_4102c = ::Reflex::ConstBuilder(type_4102);
  ::Reflex::Type type_25815 = ::Reflex::PointerBuilder(type_4102c);
  ::Reflex::Type type_4103c = ::Reflex::ConstBuilder(type_4103);
  ::Reflex::Type type_25818 = ::Reflex::PointerBuilder(type_4103c);
  ::Reflex::Type type_25821 = ::Reflex::PointerBuilder(type_1621c);
  ::Reflex::Type type_25822 = ::Reflex::PointerBuilder(type_1621);
  ::Reflex::Type type_4104c = ::Reflex::ConstBuilder(type_4104);
  ::Reflex::Type type_25823 = ::Reflex::PointerBuilder(type_4104c);
  ::Reflex::Type type_4105c = ::Reflex::ConstBuilder(type_4105);
  ::Reflex::Type type_25826 = ::Reflex::PointerBuilder(type_4105c);
  ::Reflex::Type type_25829 = ::Reflex::PointerBuilder(type_1726c);
  ::Reflex::Type type_25830 = ::Reflex::PointerBuilder(type_1726);
  ::Reflex::Type type_4106c = ::Reflex::ConstBuilder(type_4106);
  ::Reflex::Type type_25831 = ::Reflex::PointerBuilder(type_4106c);
  ::Reflex::Type type_4107c = ::Reflex::ConstBuilder(type_4107);
  ::Reflex::Type type_25834 = ::Reflex::PointerBuilder(type_4107c);
  ::Reflex::Type type_25837 = ::Reflex::PointerBuilder(type_68c);
  ::Reflex::Type type_25838 = ::Reflex::PointerBuilder(type_68);
  ::Reflex::Type type_4108c = ::Reflex::ConstBuilder(type_4108);
  ::Reflex::Type type_25839 = ::Reflex::PointerBuilder(type_4108c);
  ::Reflex::Type type_4109c = ::Reflex::ConstBuilder(type_4109);
  ::Reflex::Type type_25842 = ::Reflex::PointerBuilder(type_4109c);
  ::Reflex::Type type_25845 = ::Reflex::PointerBuilder(type_236c);
  ::Reflex::Type type_25846 = ::Reflex::PointerBuilder(type_236);
  ::Reflex::Type type_4110c = ::Reflex::ConstBuilder(type_4110);
  ::Reflex::Type type_25847 = ::Reflex::PointerBuilder(type_4110c);
  ::Reflex::Type type_4111c = ::Reflex::ConstBuilder(type_4111);
  ::Reflex::Type type_25850 = ::Reflex::PointerBuilder(type_4111c);
  ::Reflex::Type type_25853 = ::Reflex::PointerBuilder(type_1403c);
  ::Reflex::Type type_25854 = ::Reflex::PointerBuilder(type_1403);
  ::Reflex::Type type_4112c = ::Reflex::ConstBuilder(type_4112);
  ::Reflex::Type type_25855 = ::Reflex::PointerBuilder(type_4112c);
  ::Reflex::Type type_4113c = ::Reflex::ConstBuilder(type_4113);
  ::Reflex::Type type_25858 = ::Reflex::PointerBuilder(type_4113c);
  ::Reflex::Type type_25861 = ::Reflex::PointerBuilder(type_549c);
  ::Reflex::Type type_25862 = ::Reflex::PointerBuilder(type_549);
  ::Reflex::Type type_4114c = ::Reflex::ConstBuilder(type_4114);
  ::Reflex::Type type_25863 = ::Reflex::PointerBuilder(type_4114c);
  ::Reflex::Type type_4115c = ::Reflex::ConstBuilder(type_4115);
  ::Reflex::Type type_25866 = ::Reflex::PointerBuilder(type_4115c);
  ::Reflex::Type type_25869 = ::Reflex::PointerBuilder(type_1723c);
  ::Reflex::Type type_25870 = ::Reflex::PointerBuilder(type_1723);
  ::Reflex::Type type_4116c = ::Reflex::ConstBuilder(type_4116);
  ::Reflex::Type type_25871 = ::Reflex::PointerBuilder(type_4116c);
  ::Reflex::Type type_4117c = ::Reflex::ConstBuilder(type_4117);
  ::Reflex::Type type_25874 = ::Reflex::PointerBuilder(type_4117c);
  ::Reflex::Type type_25877 = ::Reflex::PointerBuilder(type_288c);
  ::Reflex::Type type_25878 = ::Reflex::PointerBuilder(type_288);
  ::Reflex::Type type_4118c = ::Reflex::ConstBuilder(type_4118);
  ::Reflex::Type type_25879 = ::Reflex::PointerBuilder(type_4118c);
  ::Reflex::Type type_4119c = ::Reflex::ConstBuilder(type_4119);
  ::Reflex::Type type_25882 = ::Reflex::PointerBuilder(type_4119c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __BNevent
#undef __BNevent
#endif
struct __BNevent {
  public:
  __BNevent();
  double weight;
  double pthat;
  double qScale;
  double alphaQCD;
  double alphaQED;
  double scalePDF;
  double x1;
  double x2;
  double xPDF1;
  double xPDF2;
  double BSx;
  double BSy;
  double BSz;
  double PVx;
  double PVy;
  double PVz;
  double bField;
  double instLumi;
  double bxLumi;
  double FilterOutScrapingFraction;
  double sumNVtx;
  double sumTrueNVtx;
  double nm1_true;
  double n0_true;
  double np1_true;
  double numTruePV;
  double Q2ScaleUpWgt;
  double Q2ScaleDownWgt;
  double rho_kt6PFJets;
  double rho_kt6PFJetsCentralChargedPileUp;
  double rho_kt6PFJetsCentralNeutral;
  double rho_kt6PFJetsCentralNeutralTight;
  int run;
  int lumi;
  int sample;
  int numPV;
  int W0decay;
  int W1decay;
  int Z0decay;
  int Z1decay;
  int H0decay;
  int H1decay;
  int hcalnoiseLoose;
  int hcalnoiseTight;
  int GoodVertex;
  int FilterOutScraping;
  int HBHENoiseFilter;
  int CSCLooseHaloId;
  int CSCTightHaloId;
  int EcalLooseHaloId;
  int EcalTightHaloId;
  int HcalLooseHaloId;
  int HcalTightHaloId;
  int GlobalLooseHaloId;
  int GlobalTightHaloId;
  int LooseId;
  int TightId;
  int numGenPV;
  int nm1;
  int n0;
  int np1;
  int id1;
  int id2;
  long evt;
};
#ifdef __std__vector_BNevent_
#undef __std__vector_BNevent_
#endif
class __std__vector_BNevent_ : protected ::std::_Vector_base<BNevent,std::allocator<BNevent> > {
  public:
  __std__vector_BNevent_();
};
#ifdef __BNmcparticle
#undef __BNmcparticle
#endif
struct __BNmcparticle {
  public:
  __BNmcparticle();
  double energy;
  double et;
  double pt;
  double px;
  double py;
  double pz;
  double phi;
  double eta;
  double theta;
  double mass;
  double vx;
  double vy;
  double vz;
  double motherET;
  double motherPT;
  double motherPhi;
  double motherEta;
  double mother0ET;
  double mother0PT;
  double mother0Phi;
  double mother0Eta;
  double mother1ET;
  double mother1PT;
  double mother1Phi;
  double mother1Eta;
  double daughter0ET;
  double daughter0PT;
  double daughter0Phi;
  double daughter0Eta;
  double daughter1ET;
  double daughter1PT;
  double daughter1Phi;
  double daughter1Eta;
  double grandMotherET;
  double grandMotherPT;
  double grandMotherPhi;
  double grandMotherEta;
  double grandMother00ET;
  double grandMother00PT;
  double grandMother00Phi;
  double grandMother00Eta;
  double grandMother01ET;
  double grandMother01PT;
  double grandMother01Phi;
  double grandMother01Eta;
  double grandMother10ET;
  double grandMother10PT;
  double grandMother10Phi;
  double grandMother10Eta;
  double grandMother11ET;
  double grandMother11PT;
  double grandMother11Phi;
  double grandMother11Eta;
  int charge;
  int id;
  int status;
  int motherId;
  int motherCharge;
  int mother0Id;
  int mother0Status;
  int mother0Charge;
  int mother1Id;
  int mother1Status;
  int mother1Charge;
  int daughter0Id;
  int daughter0Status;
  int daughter0Charge;
  int daughter1Id;
  int daughter1Status;
  int daughter1Charge;
  int grandMotherId;
  int grandMotherCharge;
  int grandMother00Id;
  int grandMother00Status;
  int grandMother00Charge;
  int grandMother01Id;
  int grandMother01Status;
  int grandMother01Charge;
  int grandMother10Id;
  int grandMother10Status;
  int grandMother10Charge;
  int grandMother11Id;
  int grandMother11Status;
  int grandMother11Charge;
};
#ifdef __BNskimbit
#undef __BNskimbit
#endif
struct __BNskimbit {
  public:
  __BNskimbit();
  int EG;
  int JetMETTau;
  int HLT_Ele15_LW_L1R;
  int HLT_Jet15U;
  int HLT_Jet30U;
  int HLT_Jet50U;
  int HLT_Ele15_SW_L1R;
  int HLT_L1Jet15;
  int HLT_Jet30;
  int HLT_Jet50;
  int Ncalojet;
  int Npfjet;
  int Ntcjet;
  int Nele;
  int MET30;
  int MET100;
  int MET150;
  int L1T_TechBit_032;
  int L1T_TechBit_033;
  int L1T_TechBit_040;
  int L1T_TechBit_041;
  int L1T_TechBit_032_to_043;
  int GoodVertex;
  int FilterOutScraping;
  int FilterOutScrapingFraction;
};
#ifdef __std__vector_BNskimbit_
#undef __std__vector_BNskimbit_
#endif
class __std__vector_BNskimbit_ : protected ::std::_Vector_base<BNskimbit,std::allocator<BNskimbit> > {
  public:
  __std__vector_BNskimbit_();
};
#ifdef __BNtrigobj
#undef __BNtrigobj
#endif
struct __BNtrigobj {
  public:
  __BNtrigobj();
  double pt;
  double eta;
  double phi;
  double px;
  double py;
  double pz;
  double et;
  double energy;
  double etTotal;
  int id;
  int charge;
  int isIsolated;
  int isMip;
  int isForward;
  int isRPC;
  int bx;
  ::std::string filter;
};
#ifdef __std__vector_BNtrigobj_
#undef __std__vector_BNtrigobj_
#endif
class __std__vector_BNtrigobj_ : protected ::std::_Vector_base<BNtrigobj,std::allocator<BNtrigobj> > {
  public:
  __std__vector_BNtrigobj_();
};
#ifdef __BNtrack
#undef __BNtrack
#endif
struct __BNtrack {
  public:
  __BNtrack();
  double pt;
  double ptError;
  double px;
  double py;
  double pz;
  double phi;
  double eta;
  double theta;
  double normChi2;
  double dZ;
  double d0;
  double d0err;
  double vx;
  double vy;
  double vz;
  int charge;
  int numValidHits;
  int isHighPurity;
  int nHitsMissingOuter;
  int nHitsMissingInner;
  int nHitsMissingMiddle;
  int layersWithMeasurement;
  int numberOfHits;
  int numberOfLostHits;
  int numberOfValidPixelHits;
  int numberOfValidStripHits;
  double lastHitOuterRadius;
  double lastHitOuterEta;
  double lastHitOuterTheta;
  double lastHitOuterPhi;
  double caloEMDeltaRp3;
  double caloHadDeltaRp3;
  double caloEMDeltaRp4;
  double caloHadDeltaRp4;
  double caloEMDeltaRp5;
  double caloHadDeltaRp5;
  double depTrkRp3;
  double depEcalRp3;
  double depHcalRp3;
  double depHoRp3;
  double nTracksRp3;
  double trackerVetoPtRp3;
  double emVetoEtRp3;
  double hadVetoEtRp3;
  double hoVetoEtRp3;
  double depTrkRp5;
  double depEcalRp5;
  double depHcalRp5;
  double depHoRp5;
  double nTracksRp5;
  double trackerVetoPtRp5;
  double emVetoEtRp5;
  double hadVetoEtRp5;
  double hoVetoEtRp5;
  ::std::vector<int> subDetIdHits;
  ::std::vector<int> rawDetIdHits;
  ::std::vector<bool> isValidHits;
  ::std::vector<double> modulePerpHits;
  ::std::vector<double> moduleZHits;
  ::std::vector<double> modulePhiHits;
};
#ifdef __std__vector_BNtrack_
#undef __std__vector_BNtrack_
#endif
class __std__vector_BNtrack_ : protected ::std::_Vector_base<BNtrack,std::allocator<BNtrack> > {
  public:
  __std__vector_BNtrack_();
};
#ifdef __BNtrigger
#undef __BNtrigger
#endif
struct __BNtrigger {
  public:
  __BNtrigger();
  int pass;
  int prescale;
  ::std::string name;
};
#ifdef __std__vector_BNtrigger_
#undef __std__vector_BNtrigger_
#endif
class __std__vector_BNtrigger_ : protected ::std::_Vector_base<BNtrigger,std::allocator<BNtrigger> > {
  public:
  __std__vector_BNtrigger_();
};
#ifdef __BNjet
#undef __BNjet
#endif
struct __BNjet {
  public:
  __BNjet();
  double energy;
  double et;
  double pt;
  double px;
  double py;
  double pz;
  double phi;
  double eta;
  double theta;
  double Upt;
  double Uenergy;
  double L2pt;
  double L2L3pt;
  double L2L3respt;
  double respt;
  double EMfrac;
  double Hadfrac;
  double charge;
  double jetChargeRelativePtWeighted;
  double mass;
  double area;
  double fHPD;
  double approximatefHPD;
  double genPartonET;
  double genPartonPT;
  double genPartonEta;
  double genPartonPhi;
  double genJetET;
  double genJetPT;
  double genJetEta;
  double genJetPhi;
  double btagTChighPur;
  double btagTChighEff;
  double btagJetProb;
  double btagJetBProb;
  double btagSoftEle;
  double btagSoftMuon;
  double btagSoftMuonNoIP;
  double btagSecVertex;
  double btagSecVertexHighEff;
  double btagSecVertexHighPur;
  double btagCombinedSecVertex;
  double btagCombinedSecVertexMVA;
  double btagSoftMuonByPt;
  double btagSoftMuonByIP3;
  double btagSoftElectronByPt;
  double btagSoftElectronByIP3;
  double n90Hits;
  double hitsInN90;
  double chargedHadronEnergyFraction;
  double neutralHadronEnergyFraction;
  double chargedEmEnergyFraction;
  double neutralEmEnergyFraction;
  double fLong;
  double fShort;
  double etaetaMoment;
  double phiphiMoment;
  double JESunc;
  double JECuncUp;
  double JECuncDown;
  double puJetMVA_full;
  double puJetMVA_simple;
  double puJetMVA_cutbased;
  double dZ;
  double dR2Mean;
  double dRMean;
  double frac01;
  double frac02;
  double frac03;
  double frac04;
  double frac05;
  double frac06;
  double frac07;
  double beta;
  double betaStar;
  double betaClassic;
  double betaStarClassic;
  double ptD;
  double nvtx;
  double d0;
  double leadCandPt;
  double leadCandVx;
  double leadCandVy;
  double leadCandVz;
  double leadCandDistFromPV;
  int isCorrected;
  int flavour;
  int Nconst;
  int jetIDMinimal;
  int jetIDLooseAOD;
  int jetIDLoose;
  int jetIDTight;
  int genPartonId;
  int genPartonMotherId;
  int genPartonMother0Id;
  int genPartonMother1Id;
  int genPartonGrandMotherId;
  int genPartonGrandMother00Id;
  int genPartonGrandMother01Id;
  int genPartonGrandMother10Id;
  int genPartonGrandMother11Id;
  int chargedMultiplicity;
  int neutralMultiplicity;
  int nconstituents;
  int nHit;
  int puJetId_full;
  int puJetId_simple;
  int puJetId_cutbased;
  int puJetId_tight_full;
  int puJetId_tight_simple;
  int puJetId_tight_cutbased;
  int puJetId_medium_full;
  int puJetId_medium_simple;
  int puJetId_medium_cutbased;
  int puJetId_loose_full;
  int puJetId_loose_simple;
  int puJetId_loose_cutbased;
  int QGMLP;
  int QGLD;
};
#ifdef __std__vector_BNjet_
#undef __std__vector_BNjet_
#endif
class __std__vector_BNjet_ : protected ::std::_Vector_base<BNjet,std::allocator<BNjet> > {
  public:
  __std__vector_BNjet_();
};
#ifdef __BNsupercluster
#undef __BNsupercluster
#endif
struct __BNsupercluster {
  public:
  __BNsupercluster();
  double energy;
  double et;
  double ex;
  double ey;
  double ez;
  double phi;
  double eta;
  double theta;
};
#ifdef __SampleProd
#undef __SampleProd
#endif
struct __SampleProd {
  public:
  __SampleProd();
  float et_;
  float pt_;
  float px_;
  float py_;
  float pz_;
  float phi_;
  float eta_;
  float theta_;
};
#ifdef __std__vector_SampleProd_
#undef __std__vector_SampleProd_
#endif
class __std__vector_SampleProd_ : protected ::std::_Vector_base<SampleProd,std::allocator<SampleProd> > {
  public:
  __std__vector_SampleProd_();
};
#ifdef __BNmuon
#undef __BNmuon
#endif
struct __BNmuon : public ::BNlepton {
  public:
  __BNmuon();
  double trackVetoIsoDR03;
  double ecalVetoIsoDR03;
  double hcalVetoIsoDR03;
  double caloVetoIsoDR03;
  double trackIsoDR05;
  double ecalIsoDR05;
  double hcalIsoDR05;
  double caloIsoDR05;
  double trackVetoIsoDR05;
  double ecalVetoIsoDR05;
  double hcalVetoIsoDR05;
  double caloVetoIsoDR05;
  double hcalE;
  double ecalE;
  double samNormChi2;
  double samPT;
  double samEta;
  double samPhi;
  double samDZ;
  double samDZerr;
  double samD0;
  double samD0bs;
  double samD0err;
  double comNormChi2;
  double comPT;
  double comEta;
  double comPhi;
  double comDZ;
  double comDZerr;
  double comD0;
  double comD0bs;
  double comD0err;
  double isolationR03emVetoEt;
  double isolationR03hadVetoEt;
  double normalizedChi2;
  double dVzPVz;
  double dB;
  double ptErr;
  double innerTrackNormChi2;
  double pfIsoR03SumChargedHadronPt;
  double pfIsoR03SumNeutralHadronEt;
  double pfIsoR03SumPhotonEt;
  double pfIsoR03SumPUPt;
  double pfIsoR04SumChargedHadronPt;
  double pfIsoR04SumNeutralHadronEt;
  double pfIsoR04SumPhotonEt;
  double pfIsoR04SumPUPt;
  double timeAtIpInOut;
  double timeAtIpInOutErr;
  double timeAtIpOutIn;
  double timeAtIpOutInErr;
  double ecal_time;
  double hcal_time;
  double ecal_timeError;
  double hcal_timeError;
  double energy_ecal;
  double energy_hcal;
  double e3x3_ecal;
  double e3x3_hcal;
  double energyMax_ecal;
  double energyMax_hcal;
  int IDGMPTight;
  int tkNumValidHits;
  int samNumValidHits;
  int samCharge;
  int comNumValidHits;
  int comCharge;
  int isPFMuon;
  int isGoodMuon_1StationTight;
  int isGlobalMuon;
  int isTrackerMuon;
  int isStandAloneMuon;
  int isGlobalMuonPromptTight;
  int numberOfValidMuonHits;
  int numberOfValidTrackerHits;
  int numberOfLayersWithMeasurement;
  int pixelLayersWithMeasurement;
  int numberOfMatches;
  int numberOfValidTrackerHitsInnerTrack;
  int numberOfValidPixelHits;
  int numberOfMatchedStations;
  int time_ndof;
  int innerTrackPt;
  int innerTrackPtError;
};
#ifdef __std__vector_BNmuon_
#undef __std__vector_BNmuon_
#endif
class __std__vector_BNmuon_ : protected ::std::_Vector_base<BNmuon,std::allocator<BNmuon> > {
  public:
  __std__vector_BNmuon_();
};
#ifdef __BNelectron
#undef __BNelectron
#endif
struct __BNelectron : public ::BNlepton {
  public:
  __BNelectron();
  double gsfEt;
  double pIn;
  double pOut;
  double EscOverPin;
  double EseedOverPout;
  double hadOverEm;
  double hcalIsoDR03depth1;
  double hcalIsoDR03depth2;
  double trackIsoDR04;
  double ecalIsoDR04;
  double hcalIsoDR04;
  double hcalIsoDR04depth1;
  double hcalIsoDR04depth2;
  double caloIsoDR04;
  double fbrem;
  double absInvEMinusInvPin;
  double delPhiIn;
  double delEtaIn;
  double scEnergy;
  double scRawEnergy;
  double scSigmaEtaEta;
  double scSigmaIEtaIEta;
  double scE1x5;
  double scE2x5Max;
  double scE5x5;
  double scEt;
  double scEta;
  double scPhi;
  double scZ;
  double mva;
  double mvaTrigV0;
  double mvaNonTrigV0;
  double dist;
  double dcot;
  double convradius;
  double convPointX;
  double convPointY;
  double convPointZ;
  double eMax;
  double eLeft;
  double eRight;
  double eTop;
  double eBottom;
  double e3x3;
  double swissCross;
  double seedEnergy;
  double seedTime;
  double swissCrossNoI85;
  double swissCrossI85;
  double E2overE9NoI85;
  double E2overE9I85;
  int classification;
  int genGrandMother11Id;
  int numClusters;
  int tkNumValidHits;
  int gsfCharge;
  int isEB;
  int isEE;
  int isGap;
  int isEBEEGap;
  int isEBGap;
  int isEEGap;
  int isEcalDriven;
  int isTrackerDriven;
  int numberOfLostHits;
  int numberOfExpectedInnerHits;
  int numberOfValidPixelHits;
  int numberOfValidPixelBarrelHits;
  int numberOfValidPixelEndcapHits;
  int isHEEP;
  int isHEEPnoEt;
  int seedRecoFlag;
  int eidRobustHighEnergy;
  int eidRobustLoose;
  int eidRobustTight;
  int eidLoose;
  int eidTight;
  int eidVeryLooseMC;
  int eidLooseMC;
  int eidMediumMC;
  int eidTightMC;
  int eidSuperTightMC;
  int eidHyperTight1MC;
  int eidHyperTight2MC;
  int eidHyperTight3MC;
  int eidHyperTight4MC;
  int passConvVeto;
  int isGsfCtfScPixChargeConsistent;
};
#ifdef __std__vector_BNelectron_
#undef __std__vector_BNelectron_
#endif
class __std__vector_BNelectron_ : protected ::std::_Vector_base<BNelectron,std::allocator<BNelectron> > {
  public:
  __std__vector_BNelectron_();
};
#ifdef __std__vector_BNsupercluster_
#undef __std__vector_BNsupercluster_
#endif
class __std__vector_BNsupercluster_ : protected ::std::_Vector_base<BNsupercluster,std::allocator<BNsupercluster> > {
  public:
  __std__vector_BNsupercluster_();
};
#ifdef __BNgenjet
#undef __BNgenjet
#endif
struct __BNgenjet {
  public:
  __BNgenjet();
  double pt;
  double eta;
  double phi;
  double px;
  double py;
  double pz;
  double et;
  double energy;
  double mass;
  double emEnergy;
  double hadEnergy;
  double invisibleEnergy;
  double auxiliaryEnergy;
  int charge;
};
#ifdef __std__vector_BNgenjet_
#undef __std__vector_BNgenjet_
#endif
class __std__vector_BNgenjet_ : protected ::std::_Vector_base<BNgenjet,std::allocator<BNgenjet> > {
  public:
  __std__vector_BNgenjet_();
};
#ifdef __BNmet
#undef __BNmet
#endif
struct __BNmet {
  public:
  __BNmet();
  double energy;
  double et;
  double pt;
  double px;
  double py;
  double eta;
  double phi;
  double Upt;
  double Uphi;
  double NeutralEMFraction;
  double NeutralHadEtFraction;
  double ChargedEMEtFraction;
  double ChargedHadEtFraction;
  double MuonEtFraction;
  double Type6EtFraction;
  double Type7EtFraction;
  double genPT;
  double genPhi;
  double muonCorEx;
  double muonCorEy;
  double jet20CorEx;
  double jet20CorEy;
  double jet1CorEx;
  double jet1CorEy;
  double sumET;
  double corSumET;
  double mEtSig;
  double metSignificance;
  double significance;
  double sigmaX2;
  double sigmaY2;
  double sigmaXY;
  double sigmaYX;
  double maxEtInEmTowers;
  double emEtFraction;
  double emEtInEB;
  double emEtInEE;
  double emEtInHF;
  double maxEtInHadTowers;
  double hadEtFraction;
  double hadEtInHB;
  double hadEtInHE;
  double hadEtInHF;
  double hadEtInHO;
  double UDeltaPx;
  double UDeltaPy;
  double UDeltaP;
  double Uscale;
  double type2corPx;
  double type2corPy;
  double T2pt;
  double T2px;
  double T2py;
  double T2phi;
  double T2sumET;
  double pfT1jet1pt;
  double pfT1jet1phi;
  double pfT1jet6pt;
  double pfT1jet6phi;
  double pfT1jet10pt;
  double pfT1jet10phi;
};
#ifdef __BNphoton
#undef __BNphoton
#endif
struct __BNphoton {
  public:
  __BNphoton();
  double energy;
  double et;
  double pt;
  double px;
  double py;
  double pz;
  double phi;
  double eta;
  double theta;
  double trackIso;
  double ecalIso;
  double hcalIso;
  double caloIso;
  double trackIsoHollowConeDR03;
  double trackIsoSolidConeDR03;
  double ecalIsoDR03;
  double hcalIsoDR03;
  double caloIsoDR03;
  double trackIsoHollowConeDR04;
  double trackIsoSolidConeDR04;
  double ecalIsoDR04;
  double hcalIsoDR04;
  double caloIsoDR04;
  double hadOverEm;
  double sigmaEtaEta;
  double sigmaIetaIeta;
  double r9;
  double scEnergy;
  double scRawEnergy;
  double scSeedEnergy;
  double scEta;
  double scPhi;
  double scZ;
  double genET;
  double genPT;
  double genPhi;
  double genEta;
  double genMotherET;
  double genMotherPT;
  double genMotherPhi;
  double genMotherEta;
  double eMax;
  double eLeft;
  double eRight;
  double eTop;
  double eBottom;
  double e3x3;
  double swissCross;
  double seedEnergy;
  double seedTime;
  double swissCrossNoI85;
  double swissCrossI85;
  double E2overE9NoI85;
  double E2overE9I85;
  int IDTight;
  int IDLoose;
  int IDLooseEM;
  int genId;
  int genCharge;
  int genMotherId;
  int genMotherCharge;
  int isEB;
  int isEE;
  int isGap;
  int isEBEEGap;
  int isEBGap;
  int isEEGap;
  int hasPixelSeed;
  int seedRecoFlag;
};
#ifdef __BNlepton
#undef __BNlepton
#endif
struct __BNlepton {
  public:
  __BNlepton();
  double energy;
  double et;
  double pt;
  double px;
  double py;
  double pz;
  double phi;
  double eta;
  double theta;
  double jetDeltaR;
  double jetPtRatio;
  double jetBTagCSV;
  double trackIso;
  double ecalIso;
  double hcalIso;
  double caloIso;
  double trackIsoDR03;
  double ecalIsoDR03;
  double hcalIsoDR03;
  double caloIsoDR03;
  double genET;
  double genPT;
  double genPhi;
  double genEta;
  double genMotherET;
  double genMotherPT;
  double genMotherPhi;
  double genMotherEta;
  double vx;
  double vy;
  double vz;
  double tkNormChi2;
  double tkPT;
  double tkEta;
  double tkPhi;
  double tkDZ;
  double tkDZerr;
  double tkD0;
  double tkD0bs;
  double tkD0err;
  double correctedD0;
  double correctedD0Vertex;
  double correctedDZ;
  double particleIso;
  double chargedHadronIso;
  double neutralHadronIso;
  double photonIso;
  double puChargedHadronIso;
  double chargedHadronIsoDR03;
  double neutralHadronIsoDR03;
  double photonIsoDR03;
  double puChargedHadronIsoDR03;
  double chargedHadronIsoDR04;
  double neutralHadronIsoDR04;
  double photonIsoDR04;
  double puChargedHadronIsoDR04;
  double rhoPrime;
  double AEffDr03;
  double AEffDr04;
  double IP;
  double IPError;
  double SIP;
  int isElectron;
  int isMuon;
  int charge;
  int tkCharge;
  int genId;
  int genCharge;
  int genNumberOfMothers;
  int genMotherId;
  int genMotherCharge;
  int genMother0Id;
  int genMother1Id;
  int genGrandMother00Id;
  int genGrandMother01Id;
  int genGrandMother10Id;
  int genGrandMother11Id;
  int mcMatchID;
  int mcMatchAny;
};
#ifdef __BNbxlumi
#undef __BNbxlumi
#endif
struct __BNbxlumi {
  public:
  __BNbxlumi();
  double bx_B1_now;
  double bx_B2_now;
  double bx_LUMI_now;
};
#ifdef __std__vector_BNphoton_
#undef __std__vector_BNphoton_
#endif
class __std__vector_BNphoton_ : protected ::std::_Vector_base<BNphoton,std::allocator<BNphoton> > {
  public:
  __std__vector_BNphoton_();
};
#ifdef __BNtau
#undef __BNtau
#endif
struct __BNtau {
  public:
  __BNtau();
  double px;
  double py;
  double pz;
  double energy;
  double et;
  double pt;
  double eta;
  double phi;
  double emFraction;
  int leadingTrackValid;
  double leadingTrackPt;
  double leadingTrackIpVtdxy;
  double leadingTrackIpVtdz;
  double leadingTrackIpVtdxyError;
  double leadingTrackIpVtdzError;
  double leadingTrackVx;
  double leadingTrackVy;
  double leadingTrackVz;
  double leadingTrackValidHits;
  double leadingTrackNormChiSqrd;
  int numProngs;
  int numSignalGammas;
  int numSignalNeutrals;
  int numSignalPiZeros;
  int decayMode;
  int charge;
  int inTheCracks;
  int HPSagainstMuonMedium;
  int HPSagainstElectronTightMVA3;
  int HPSagainstElectronTightMVA2;
  int HPSbyLooseIsolationMVA2;
  int HPSagainstMuonTight;
  int HPSagainstElectronMedium;
  int HPSbyTightIsolationMVA;
  int HPSagainstMuonLoose2;
  int HPSbyLooseCombinedIsolationDeltaBetaCorr;
  int HPSagainstElectronLooseMVA3;
  int HPSagainstElectronLooseMVA2;
  int HPSagainstElectronTight;
  int HPSbyVLooseCombinedIsolationDeltaBetaCorr;
  int HPSagainstElectronVTightMVA3;
  int HPSagainstElectronMediumMVA3;
  int HPSagainstElectronMediumMVA2;
  int HPSagainstElectronMVA;
  int HPSagainstMuonLoose;
  int HPSagainstMuonTight2;
  int HPSbyMediumCombinedIsolationDeltaBetaCorr;
  int HPSagainstElectronVLooseMVA2;
  int HPSagainstElectronLoose;
  int HPSbyMediumIsolationMVA;
  int HPSbyMediumCombinedIsolationDeltaBetaCorr3Hits;
  int HPSbyMediumIsolationMVA2;
  int HPSbyTightIsolationMVA2;
  int HPSagainstElectronMVA2category;
  int HPSagainstElectronDeadECAL;
  int HPSagainstElectronMVA3category;
  int HPSbyTightCombinedIsolationDeltaBetaCorr;
  int HPSbyLooseCombinedIsolationDeltaBetaCorr3Hits;
  int HPSagainstMuonMedium2;
  int HPSbyLooseIsolationMVA;
  int HPSbyTightCombinedIsolationDeltaBetaCorr3Hits;
  int HPSdecayModeFinding;
  double HPSbyIsolationMVAraw;
  double HPSbyCombinedIsolationDeltaBetaCorrRaw3Hits;
  double HPSbyIsolationMVA2raw;
  double HPSagainstElectronMVA2raw;
  double HPSagainstElectronMVA3raw;
  double HPSbyCombinedIsolationDeltaBetaCorrRaw;
};
#ifdef __std__vector_BNtau_
#undef __std__vector_BNtau_
#endif
class __std__vector_BNtau_ : protected ::std::_Vector_base<BNtau,std::allocator<BNtau> > {
  public:
  __std__vector_BNtau_();
};
#ifdef __BNprimaryvertex
#undef __BNprimaryvertex
#endif
struct __BNprimaryvertex {
  public:
  __BNprimaryvertex();
  double x;
  double xError;
  double y;
  double yError;
  double z;
  double zError;
  double rho;
  double normalizedChi2;
  double ndof;
  int isFake;
  int isValid;
  int tracksSize;
  int isGood;
};
#ifdef __std__vector_BNprimaryvertex_
#undef __std__vector_BNprimaryvertex_
#endif
class __std__vector_BNprimaryvertex_ : protected ::std::_Vector_base<BNprimaryvertex,std::allocator<BNprimaryvertex> > {
  public:
  __std__vector_BNprimaryvertex_();
};
#ifdef __std__vector_BNmet_
#undef __std__vector_BNmet_
#endif
class __std__vector_BNmet_ : protected ::std::_Vector_base<BNmet,std::allocator<BNmet> > {
  public:
  __std__vector_BNmet_();
};
#ifdef __std__vector_BNbxlumi_
#undef __std__vector_BNbxlumi_
#endif
class __std__vector_BNbxlumi_ : protected ::std::_Vector_base<BNbxlumi,std::allocator<BNbxlumi> > {
  public:
  __std__vector_BNbxlumi_();
};
#ifdef __std__vector_BNmcparticle_
#undef __std__vector_BNmcparticle_
#endif
class __std__vector_BNmcparticle_ : protected ::std::_Vector_base<BNmcparticle,std::allocator<BNmcparticle> > {
  public:
  __std__vector_BNmcparticle_();
};
#ifdef __std__vector_BNlepton_
#undef __std__vector_BNlepton_
#endif
class __std__vector_BNlepton_ : protected ::std::_Vector_base<BNlepton,std::allocator<BNlepton> > {
  public:
  __std__vector_BNlepton_();
};
#ifdef __edm__Wrapper_std__vector_BNgenjet_s_
#undef __edm__Wrapper_std__vector_BNgenjet_s_
#endif
class __edm__Wrapper_std__vector_BNgenjet_s_ {
  public:
  __edm__Wrapper_std__vector_BNgenjet_s_();
  bool present;
  ::std::vector<BNgenjet> obj;
};
#ifdef __edm__Wrapper_BNgenjet_
#undef __edm__Wrapper_BNgenjet_
#endif
class __edm__Wrapper_BNgenjet_ {
  public:
  __edm__Wrapper_BNgenjet_();
  bool present;
  ::BNgenjet obj;
};
#ifdef __edm__Wrapper_std__vector_BNprimaryvertex_s_
#undef __edm__Wrapper_std__vector_BNprimaryvertex_s_
#endif
class __edm__Wrapper_std__vector_BNprimaryvertex_s_ {
  public:
  __edm__Wrapper_std__vector_BNprimaryvertex_s_();
  bool present;
  ::std::vector<BNprimaryvertex> obj;
};
#ifdef __edm__Wrapper_BNprimaryvertex_
#undef __edm__Wrapper_BNprimaryvertex_
#endif
class __edm__Wrapper_BNprimaryvertex_ {
  public:
  __edm__Wrapper_BNprimaryvertex_();
  bool present;
  ::BNprimaryvertex obj;
};
#ifdef __edm__Wrapper_std__vector_BNtrigobj_s_
#undef __edm__Wrapper_std__vector_BNtrigobj_s_
#endif
class __edm__Wrapper_std__vector_BNtrigobj_s_ {
  public:
  __edm__Wrapper_std__vector_BNtrigobj_s_();
  bool present;
  ::std::vector<BNtrigobj> obj;
};
#ifdef __edm__Wrapper_BNtrigobj_
#undef __edm__Wrapper_BNtrigobj_
#endif
class __edm__Wrapper_BNtrigobj_ {
  public:
  __edm__Wrapper_BNtrigobj_();
  bool present;
  ::BNtrigobj obj;
};
#ifdef __edm__Wrapper_std__vector_BNskimbit_s_
#undef __edm__Wrapper_std__vector_BNskimbit_s_
#endif
class __edm__Wrapper_std__vector_BNskimbit_s_ {
  public:
  __edm__Wrapper_std__vector_BNskimbit_s_();
  bool present;
  ::std::vector<BNskimbit> obj;
};
#ifdef __edm__Wrapper_BNskimbit_
#undef __edm__Wrapper_BNskimbit_
#endif
class __edm__Wrapper_BNskimbit_ {
  public:
  __edm__Wrapper_BNskimbit_();
  bool present;
  ::BNskimbit obj;
};
#ifdef __edm__Wrapper_std__vector_BNtrigger_s_
#undef __edm__Wrapper_std__vector_BNtrigger_s_
#endif
class __edm__Wrapper_std__vector_BNtrigger_s_ {
  public:
  __edm__Wrapper_std__vector_BNtrigger_s_();
  bool present;
  ::std::vector<BNtrigger> obj;
};
#ifdef __edm__Wrapper_BNtrigger_
#undef __edm__Wrapper_BNtrigger_
#endif
class __edm__Wrapper_BNtrigger_ {
  public:
  __edm__Wrapper_BNtrigger_();
  bool present;
  ::BNtrigger obj;
};
#ifdef __edm__Wrapper_std__vector_BNtrack_s_
#undef __edm__Wrapper_std__vector_BNtrack_s_
#endif
class __edm__Wrapper_std__vector_BNtrack_s_ {
  public:
  __edm__Wrapper_std__vector_BNtrack_s_();
  bool present;
  ::std::vector<BNtrack> obj;
};
#ifdef __edm__Wrapper_BNtrack_
#undef __edm__Wrapper_BNtrack_
#endif
class __edm__Wrapper_BNtrack_ {
  public:
  __edm__Wrapper_BNtrack_();
  bool present;
  ::BNtrack obj;
};
#ifdef __edm__Wrapper_std__vector_BNsupercluster_s_
#undef __edm__Wrapper_std__vector_BNsupercluster_s_
#endif
class __edm__Wrapper_std__vector_BNsupercluster_s_ {
  public:
  __edm__Wrapper_std__vector_BNsupercluster_s_();
  bool present;
  ::std::vector<BNsupercluster> obj;
};
#ifdef __edm__Wrapper_BNsupercluster_
#undef __edm__Wrapper_BNsupercluster_
#endif
class __edm__Wrapper_BNsupercluster_ {
  public:
  __edm__Wrapper_BNsupercluster_();
  bool present;
  ::BNsupercluster obj;
};
#ifdef __edm__Wrapper_std__vector_BNphoton_s_
#undef __edm__Wrapper_std__vector_BNphoton_s_
#endif
class __edm__Wrapper_std__vector_BNphoton_s_ {
  public:
  __edm__Wrapper_std__vector_BNphoton_s_();
  bool present;
  ::std::vector<BNphoton> obj;
};
#ifdef __edm__Wrapper_BNphoton_
#undef __edm__Wrapper_BNphoton_
#endif
class __edm__Wrapper_BNphoton_ {
  public:
  __edm__Wrapper_BNphoton_();
  bool present;
  ::BNphoton obj;
};
#ifdef __edm__Wrapper_std__vector_BNlepton_s_
#undef __edm__Wrapper_std__vector_BNlepton_s_
#endif
class __edm__Wrapper_std__vector_BNlepton_s_ {
  public:
  __edm__Wrapper_std__vector_BNlepton_s_();
  bool present;
  ::std::vector<BNlepton> obj;
};
#ifdef __edm__Wrapper_BNlepton_
#undef __edm__Wrapper_BNlepton_
#endif
class __edm__Wrapper_BNlepton_ {
  public:
  __edm__Wrapper_BNlepton_();
  bool present;
  ::BNlepton obj;
};
#ifdef __edm__Wrapper_std__vector_BNmuon_s_
#undef __edm__Wrapper_std__vector_BNmuon_s_
#endif
class __edm__Wrapper_std__vector_BNmuon_s_ {
  public:
  __edm__Wrapper_std__vector_BNmuon_s_();
  bool present;
  ::std::vector<BNmuon> obj;
};
#ifdef __edm__Wrapper_BNmuon_
#undef __edm__Wrapper_BNmuon_
#endif
class __edm__Wrapper_BNmuon_ {
  public:
  __edm__Wrapper_BNmuon_();
  bool present;
  ::BNmuon obj;
};
#ifdef __edm__Wrapper_std__vector_BNmet_s_
#undef __edm__Wrapper_std__vector_BNmet_s_
#endif
class __edm__Wrapper_std__vector_BNmet_s_ {
  public:
  __edm__Wrapper_std__vector_BNmet_s_();
  bool present;
  ::std::vector<BNmet> obj;
};
#ifdef __edm__Wrapper_BNmet_
#undef __edm__Wrapper_BNmet_
#endif
class __edm__Wrapper_BNmet_ {
  public:
  __edm__Wrapper_BNmet_();
  bool present;
  ::BNmet obj;
};
#ifdef __edm__Wrapper_std__vector_BNmcparticle_s_
#undef __edm__Wrapper_std__vector_BNmcparticle_s_
#endif
class __edm__Wrapper_std__vector_BNmcparticle_s_ {
  public:
  __edm__Wrapper_std__vector_BNmcparticle_s_();
  bool present;
  ::std::vector<BNmcparticle> obj;
};
#ifdef __edm__Wrapper_BNmcparticle_
#undef __edm__Wrapper_BNmcparticle_
#endif
class __edm__Wrapper_BNmcparticle_ {
  public:
  __edm__Wrapper_BNmcparticle_();
  bool present;
  ::BNmcparticle obj;
};
#ifdef __edm__Wrapper_std__vector_BNevent_s_
#undef __edm__Wrapper_std__vector_BNevent_s_
#endif
class __edm__Wrapper_std__vector_BNevent_s_ {
  public:
  __edm__Wrapper_std__vector_BNevent_s_();
  bool present;
  ::std::vector<BNevent> obj;
};
#ifdef __edm__Wrapper_BNevent_
#undef __edm__Wrapper_BNevent_
#endif
class __edm__Wrapper_BNevent_ {
  public:
  __edm__Wrapper_BNevent_();
  bool present;
  ::BNevent obj;
};
#ifdef __edm__Wrapper_std__vector_BNjet_s_
#undef __edm__Wrapper_std__vector_BNjet_s_
#endif
class __edm__Wrapper_std__vector_BNjet_s_ {
  public:
  __edm__Wrapper_std__vector_BNjet_s_();
  bool present;
  ::std::vector<BNjet> obj;
};
#ifdef __edm__Wrapper_BNjet_
#undef __edm__Wrapper_BNjet_
#endif
class __edm__Wrapper_BNjet_ {
  public:
  __edm__Wrapper_BNjet_();
  bool present;
  ::BNjet obj;
};
#ifdef __edm__Wrapper_std__vector_BNtau_s_
#undef __edm__Wrapper_std__vector_BNtau_s_
#endif
class __edm__Wrapper_std__vector_BNtau_s_ {
  public:
  __edm__Wrapper_std__vector_BNtau_s_();
  bool present;
  ::std::vector<BNtau> obj;
};
#ifdef __edm__Wrapper_BNtau_
#undef __edm__Wrapper_BNtau_
#endif
class __edm__Wrapper_BNtau_ {
  public:
  __edm__Wrapper_BNtau_();
  bool present;
  ::BNtau obj;
};
#ifdef __edm__Wrapper_std__vector_BNelectron_s_
#undef __edm__Wrapper_std__vector_BNelectron_s_
#endif
class __edm__Wrapper_std__vector_BNelectron_s_ {
  public:
  __edm__Wrapper_std__vector_BNelectron_s_();
  bool present;
  ::std::vector<BNelectron> obj;
};
#ifdef __edm__Wrapper_BNelectron_
#undef __edm__Wrapper_BNelectron_
#endif
class __edm__Wrapper_BNelectron_ {
  public:
  __edm__Wrapper_BNelectron_();
  bool present;
  ::BNelectron obj;
};
#ifdef __edm__Wrapper_std__vector_BNbxlumi_s_
#undef __edm__Wrapper_std__vector_BNbxlumi_s_
#endif
class __edm__Wrapper_std__vector_BNbxlumi_s_ {
  public:
  __edm__Wrapper_std__vector_BNbxlumi_s_();
  bool present;
  ::std::vector<BNbxlumi> obj;
};
#ifdef __edm__Wrapper_BNbxlumi_
#undef __edm__Wrapper_BNbxlumi_
#endif
class __edm__Wrapper_BNbxlumi_ {
  public:
  __edm__Wrapper_BNbxlumi_();
  bool present;
  ::BNbxlumi obj;
};
#ifdef __edm__Wrapper_std__vector_SampleProd_s_
#undef __edm__Wrapper_std__vector_SampleProd_s_
#endif
class __edm__Wrapper_std__vector_SampleProd_s_ {
  public:
  __edm__Wrapper_std__vector_SampleProd_s_();
  bool present;
  ::std::vector<SampleProd> obj;
};
#ifdef __edm__Wrapper_SampleProd_
#undef __edm__Wrapper_SampleProd_
#endif
class __edm__Wrapper_SampleProd_ {
  public:
  __edm__Wrapper_SampleProd_();
  bool present;
  ::SampleProd obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class BNevent -------------------------------
static void destructor_4589(void*, void * o, const std::vector<void*>&, void *) {
(((::BNevent*)o)->::BNevent::~BNevent)();
}
static  void operator_4590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNevent*)o)->operator=)(*(const ::BNevent*)arg[0]);
  else   (((::BNevent*)o)->operator=)(*(const ::BNevent*)arg[0]);
}

static void constructor_4591( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNevent(*(const ::BNevent*)arg[0]);
  else ::new(mem) ::BNevent(*(const ::BNevent*)arg[0]);
}

static void constructor_4592( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNevent(*(double*)arg[0],
      *(int*)arg[1],
      *(long*)arg[2]);
  else ::new(mem) ::BNevent(*(double*)arg[0],
      *(int*)arg[1],
      *(long*)arg[2]);
}

static void constructor_4593( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNevent();
  else ::new(mem) ::BNevent();
}

static void method_newdel_499( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNevent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNevent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNevent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNevent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNevent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNevent -------------------------------
void __BNevent_db_datamem(Reflex::Class*);
void __BNevent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNevent_datamem_bld(&__BNevent_db_datamem);
Reflex::GenreflexMemberBuilder __BNevent_funcmem_bld(&__BNevent_db_funcmem);
void __BNevent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNevent"), typeid(::BNevent), sizeof(::BNevent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNevent"), destructor_4589, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2876, type_2878), Reflex::Literal("operator="), operator_4590, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2878), Reflex::Literal("BNevent"), constructor_4591, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698, type_58, type_53), Reflex::Literal("BNevent"), constructor_4592, 0, "v;c;l", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNevent"), constructor_4593, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_499, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNevent_datamem_bld);
}

//------Delayed data member builder for class BNevent -------------------
void __BNevent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("weight"), OffsetOf(__shadow__::__BNevent, weight), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pthat"), OffsetOf(__shadow__::__BNevent, pthat), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("qScale"), OffsetOf(__shadow__::__BNevent, qScale), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("alphaQCD"), OffsetOf(__shadow__::__BNevent, alphaQCD), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("alphaQED"), OffsetOf(__shadow__::__BNevent, alphaQED), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scalePDF"), OffsetOf(__shadow__::__BNevent, scalePDF), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("x1"), OffsetOf(__shadow__::__BNevent, x1), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("x2"), OffsetOf(__shadow__::__BNevent, x2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("xPDF1"), OffsetOf(__shadow__::__BNevent, xPDF1), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("xPDF2"), OffsetOf(__shadow__::__BNevent, xPDF2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("BSx"), OffsetOf(__shadow__::__BNevent, BSx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("BSy"), OffsetOf(__shadow__::__BNevent, BSy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("BSz"), OffsetOf(__shadow__::__BNevent, BSz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("PVx"), OffsetOf(__shadow__::__BNevent, PVx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("PVy"), OffsetOf(__shadow__::__BNevent, PVy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("PVz"), OffsetOf(__shadow__::__BNevent, PVz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("bField"), OffsetOf(__shadow__::__BNevent, bField), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("instLumi"), OffsetOf(__shadow__::__BNevent, instLumi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("bxLumi"), OffsetOf(__shadow__::__BNevent, bxLumi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("FilterOutScrapingFraction"), OffsetOf(__shadow__::__BNevent, FilterOutScrapingFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("sumNVtx"), OffsetOf(__shadow__::__BNevent, sumNVtx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("sumTrueNVtx"), OffsetOf(__shadow__::__BNevent, sumTrueNVtx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("nm1_true"), OffsetOf(__shadow__::__BNevent, nm1_true), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("n0_true"), OffsetOf(__shadow__::__BNevent, n0_true), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("np1_true"), OffsetOf(__shadow__::__BNevent, np1_true), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("numTruePV"), OffsetOf(__shadow__::__BNevent, numTruePV), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("Q2ScaleUpWgt"), OffsetOf(__shadow__::__BNevent, Q2ScaleUpWgt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("Q2ScaleDownWgt"), OffsetOf(__shadow__::__BNevent, Q2ScaleDownWgt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("rho_kt6PFJets"), OffsetOf(__shadow__::__BNevent, rho_kt6PFJets), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("rho_kt6PFJetsCentralChargedPileUp"), OffsetOf(__shadow__::__BNevent, rho_kt6PFJetsCentralChargedPileUp), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("rho_kt6PFJetsCentralNeutral"), OffsetOf(__shadow__::__BNevent, rho_kt6PFJetsCentralNeutral), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("rho_kt6PFJetsCentralNeutralTight"), OffsetOf(__shadow__::__BNevent, rho_kt6PFJetsCentralNeutralTight), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("run"), OffsetOf(__shadow__::__BNevent, run), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("lumi"), OffsetOf(__shadow__::__BNevent, lumi), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("sample"), OffsetOf(__shadow__::__BNevent, sample), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numPV"), OffsetOf(__shadow__::__BNevent, numPV), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("W0decay"), OffsetOf(__shadow__::__BNevent, W0decay), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("W1decay"), OffsetOf(__shadow__::__BNevent, W1decay), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("Z0decay"), OffsetOf(__shadow__::__BNevent, Z0decay), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("Z1decay"), OffsetOf(__shadow__::__BNevent, Z1decay), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("H0decay"), OffsetOf(__shadow__::__BNevent, H0decay), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("H1decay"), OffsetOf(__shadow__::__BNevent, H1decay), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("hcalnoiseLoose"), OffsetOf(__shadow__::__BNevent, hcalnoiseLoose), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("hcalnoiseTight"), OffsetOf(__shadow__::__BNevent, hcalnoiseTight), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("GoodVertex"), OffsetOf(__shadow__::__BNevent, GoodVertex), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("FilterOutScraping"), OffsetOf(__shadow__::__BNevent, FilterOutScraping), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HBHENoiseFilter"), OffsetOf(__shadow__::__BNevent, HBHENoiseFilter), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("CSCLooseHaloId"), OffsetOf(__shadow__::__BNevent, CSCLooseHaloId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("CSCTightHaloId"), OffsetOf(__shadow__::__BNevent, CSCTightHaloId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("EcalLooseHaloId"), OffsetOf(__shadow__::__BNevent, EcalLooseHaloId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("EcalTightHaloId"), OffsetOf(__shadow__::__BNevent, EcalTightHaloId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HcalLooseHaloId"), OffsetOf(__shadow__::__BNevent, HcalLooseHaloId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HcalTightHaloId"), OffsetOf(__shadow__::__BNevent, HcalTightHaloId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("GlobalLooseHaloId"), OffsetOf(__shadow__::__BNevent, GlobalLooseHaloId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("GlobalTightHaloId"), OffsetOf(__shadow__::__BNevent, GlobalTightHaloId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("LooseId"), OffsetOf(__shadow__::__BNevent, LooseId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("TightId"), OffsetOf(__shadow__::__BNevent, TightId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numGenPV"), OffsetOf(__shadow__::__BNevent, numGenPV), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("nm1"), OffsetOf(__shadow__::__BNevent, nm1), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("n0"), OffsetOf(__shadow__::__BNevent, n0), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("np1"), OffsetOf(__shadow__::__BNevent, np1), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("id1"), OffsetOf(__shadow__::__BNevent, id1), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("id2"), OffsetOf(__shadow__::__BNevent, id2), ::Reflex::PUBLIC)
  .AddDataMember(type_53, Reflex::Literal("evt"), OffsetOf(__shadow__::__BNevent, evt), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNevent -------------------
void __BNevent_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BNevent,std::allocator<BNevent> > -------------------------------
static void constructor_2889( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNevent>();
  else ::new(mem) ::std::vector<BNevent>();
}

static void constructor_2890( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNevent>(*(const ::std::allocator<BNevent>*)arg[0]);
  else ::new(mem) ::std::vector<BNevent>(*(const ::std::allocator<BNevent>*)arg[0]);
}

static void constructor_2891( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNevent>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNevent>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNevent>(*(::std::size_t*)arg[0],
      *(const ::BNevent*)arg[1]);
  else ::new(mem) ::std::vector<BNevent>(*(::std::size_t*)arg[0],
      *(const ::BNevent*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNevent>(*(::std::size_t*)arg[0],
      *(const ::BNevent*)arg[1],
      *(const ::std::allocator<BNevent>*)arg[2]);
  else ::new(mem) ::std::vector<BNevent>(*(::std::size_t*)arg[0],
      *(const ::BNevent*)arg[1],
      *(const ::std::allocator<BNevent>*)arg[2]);
  }
}

static void constructor_2892( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNevent>(*(const ::std::vector<BNevent>*)arg[0]);
  else ::new(mem) ::std::vector<BNevent>(*(const ::std::vector<BNevent>*)arg[0]);
}

static void destructor_2893(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNevent>*)o)->::std::vector<BNevent>::~vector)();
}
static  void operator_2894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNevent>*)o)->operator=)(*(const ::std::vector<BNevent>*)arg[0]);
  else   (((::std::vector<BNevent>*)o)->operator=)(*(const ::std::vector<BNevent>*)arg[0]);
}

static  void method_2895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNevent>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNevent*)arg[1]);
}

static  void method_2896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >)((((::std::vector<BNevent>*)o)->begin)());
  else   (((::std::vector<BNevent>*)o)->begin)();
}

static  void method_2897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNevent*,std::vector<BNevent> >)((((const ::std::vector<BNevent>*)o)->begin)());
  else   (((const ::std::vector<BNevent>*)o)->begin)();
}

static  void method_2898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >)((((::std::vector<BNevent>*)o)->end)());
  else   (((::std::vector<BNevent>*)o)->end)();
}

static  void method_2899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNevent*,std::vector<BNevent> >)((((const ::std::vector<BNevent>*)o)->end)());
  else   (((const ::std::vector<BNevent>*)o)->end)();
}

static  void method_2904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNevent>*)o)->size)());
  else   (((const ::std::vector<BNevent>*)o)->size)();
}

static  void method_2905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNevent>*)o)->max_size)());
  else   (((const ::std::vector<BNevent>*)o)->max_size)();
}

static  void method_2906( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNevent>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNevent>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNevent*)arg[1]);
  }
}

static  void method_2907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNevent>*)o)->capacity)());
  else   (((const ::std::vector<BNevent>*)o)->capacity)();
}

static  void method_2908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNevent>*)o)->empty)());
  else   (((const ::std::vector<BNevent>*)o)->empty)();
}

static  void method_2909( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNevent>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2910( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNevent>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNevent>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNevent>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNevent>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2913( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNevent>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNevent>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2914( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNevent>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNevent>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNevent>*)o)->front)();
  else   (((::std::vector<BNevent>*)o)->front)();
}

static  void method_2916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNevent>*)o)->front)();
  else   (((const ::std::vector<BNevent>*)o)->front)();
}

static  void method_2917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNevent>*)o)->back)();
  else   (((::std::vector<BNevent>*)o)->back)();
}

static  void method_2918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNevent>*)o)->back)();
  else   (((const ::std::vector<BNevent>*)o)->back)();
}

static  void method_2919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNevent>*)o)->data)());
  else   (((::std::vector<BNevent>*)o)->data)();
}

static  void method_2920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNevent>*)o)->data)());
  else   (((const ::std::vector<BNevent>*)o)->data)();
}

static  void method_2921( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNevent>*)o)->push_back)(*(const ::BNevent*)arg[0]);
}

static  void method_2922( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNevent>*)o)->pop_back)();
}

static  void method_2923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >)((((::std::vector<BNevent>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >*)arg[0],
    *(const ::BNevent*)arg[1]));
  else   (((::std::vector<BNevent>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >*)arg[0],
    *(const ::BNevent*)arg[1]);
}

static  void method_2924( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNevent>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNevent*)arg[2]);
}

static  void method_2925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >)((((::std::vector<BNevent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >*)arg[0]));
  else   (((::std::vector<BNevent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >*)arg[0]);
}

static  void method_2926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >)((((::std::vector<BNevent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >*)arg[1]));
  else   (((::std::vector<BNevent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNevent*,std::vector<BNevent> >*)arg[1]);
}

static  void method_2927( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNevent>*)o)->swap)(*(::std::vector<BNevent>*)arg[0]);
}

static  void method_2928( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNevent>*)o)->clear)();
}

static void method_newdel_68( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNevent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNevent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNevent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNevent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNevent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNevent,std::allocator<BNevent> >")), ::Reflex::BaseOffset< ::std::vector<BNevent>,::std::_Vector_base<BNevent,std::allocator<BNevent> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNevent> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNevent> >::Generate();
}

//------Dictionary for class vector<BNevent,std::allocator<BNevent> > -------------------------------
void __std__vector_BNevent__db_datamem(Reflex::Class*);
void __std__vector_BNevent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNevent__datamem_bld(&__std__vector_BNevent__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNevent__funcmem_bld(&__std__vector_BNevent__db_funcmem);
void __std__vector_BNevent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNevent>"), typeid(::std::vector<BNevent>), sizeof(::std::vector<BNevent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1836, ::Reflex::BaseOffset< ::std::vector<BNevent>, ::std::_Vector_base<BNevent,std::allocator<BNevent> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_499, Reflex::Literal("std::vector<BNevent>::_Alloc_value_type"))
  .AddTypedef(type_1836, Reflex::Literal("std::vector<BNevent>::_Base"))
  .AddTypedef(type_2551, Reflex::Literal("std::vector<BNevent>::_Tp_alloc_type"))
  .AddTypedef(type_499, Reflex::Literal("std::vector<BNevent>::value_type"))
  .AddTypedef(type_2872, Reflex::Literal("std::vector<BNevent>::pointer"))
  .AddTypedef(type_2874, Reflex::Literal("std::vector<BNevent>::const_pointer"))
  .AddTypedef(type_2876, Reflex::Literal("std::vector<BNevent>::reference"))
  .AddTypedef(type_2878, Reflex::Literal("std::vector<BNevent>::const_reference"))
  .AddTypedef(type_2880, Reflex::Literal("std::vector<BNevent>::iterator"))
  .AddTypedef(type_2882, Reflex::Literal("std::vector<BNevent>::const_iterator"))
  .AddTypedef(type_2705, Reflex::Literal("std::vector<BNevent>::const_reverse_iterator"))
  .AddTypedef(type_2706, Reflex::Literal("std::vector<BNevent>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNevent>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNevent>::difference_type"))
  .AddTypedef(type_2551, Reflex::Literal("std::vector<BNevent>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2889, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13660), Reflex::Literal("vector"), constructor_2890, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_2878, type_13660), Reflex::Literal("vector"), constructor_2891, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13661), Reflex::Literal("vector"), constructor_2892, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2893, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_68, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNevent__funcmem_bld);
}

//------Delayed data member builder for class vector<BNevent,std::allocator<BNevent> > -------------------
void __std__vector_BNevent__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNevent,std::allocator<BNevent> > -------------------
void __std__vector_BNevent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13662, type_13661), Reflex::Literal("operator="), operator_2894, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_2878), Reflex::Literal("assign"), method_2895, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2880), Reflex::Literal("begin"), method_2896, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2882), Reflex::Literal("begin"), method_2897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2880), Reflex::Literal("end"), method_2898, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2882), Reflex::Literal("end"), method_2899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_2904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_2905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_499), Reflex::Literal("resize"), method_2906, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_2907, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_2908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_2909, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2876, type_2521), Reflex::Literal("operator[]"), operator_2910, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2878, type_2521), Reflex::Literal("operator[]"), operator_2911, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2876, type_2521), Reflex::Literal("at"), method_2913, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2878, type_2521), Reflex::Literal("at"), method_2914, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2876), Reflex::Literal("front"), method_2915, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2878), Reflex::Literal("front"), method_2916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2876), Reflex::Literal("back"), method_2917, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2878), Reflex::Literal("back"), method_2918, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2872), Reflex::Literal("data"), method_2919, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2874), Reflex::Literal("data"), method_2920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2878), Reflex::Literal("push_back"), method_2921, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_2922, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2880, type_2880, type_2878), Reflex::Literal("insert"), method_2923, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2880, type_2521, type_2878), Reflex::Literal("insert"), method_2924, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2880, type_2880), Reflex::Literal("erase"), method_2925, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2880, type_2880, type_2880), Reflex::Literal("erase"), method_2926, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_13662), Reflex::Literal("swap"), method_2927, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_2928, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BNmcparticle -------------------------------
static void destructor_3038(void*, void * o, const std::vector<void*>&, void *) {
(((::BNmcparticle*)o)->::BNmcparticle::~BNmcparticle)();
}
static  void operator_3039( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNmcparticle*)o)->operator=)(*(const ::BNmcparticle*)arg[0]);
  else   (((::BNmcparticle*)o)->operator=)(*(const ::BNmcparticle*)arg[0]);
}

static void constructor_3040( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNmcparticle(*(const ::BNmcparticle*)arg[0]);
  else ::new(mem) ::BNmcparticle(*(const ::BNmcparticle*)arg[0]);
}

static void constructor_3041( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNmcparticle(*(double*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::BNmcparticle(*(double*)arg[0],
      *(int*)arg[1]);
}

static void constructor_3042( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNmcparticle();
  else ::new(mem) ::BNmcparticle();
}

static void method_newdel_111( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNmcparticle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNmcparticle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNmcparticle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNmcparticle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNmcparticle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNmcparticle -------------------------------
void __BNmcparticle_db_datamem(Reflex::Class*);
void __BNmcparticle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNmcparticle_datamem_bld(&__BNmcparticle_db_datamem);
Reflex::GenreflexMemberBuilder __BNmcparticle_funcmem_bld(&__BNmcparticle_db_funcmem);
void __BNmcparticle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNmcparticle"), typeid(::BNmcparticle), sizeof(::BNmcparticle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNmcparticle"), destructor_3038, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6299, type_6301), Reflex::Literal("operator="), operator_3039, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6301), Reflex::Literal("BNmcparticle"), constructor_3040, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698, type_58), Reflex::Literal("BNmcparticle"), constructor_3041, 0, "v;c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNmcparticle"), constructor_3042, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_111, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNmcparticle_datamem_bld);
}

//------Delayed data member builder for class BNmcparticle -------------------
void __BNmcparticle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("energy"), OffsetOf(__shadow__::__BNmcparticle, energy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("et"), OffsetOf(__shadow__::__BNmcparticle, et), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pt"), OffsetOf(__shadow__::__BNmcparticle, pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("px"), OffsetOf(__shadow__::__BNmcparticle, px), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("py"), OffsetOf(__shadow__::__BNmcparticle, py), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pz"), OffsetOf(__shadow__::__BNmcparticle, pz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("phi"), OffsetOf(__shadow__::__BNmcparticle, phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eta"), OffsetOf(__shadow__::__BNmcparticle, eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("theta"), OffsetOf(__shadow__::__BNmcparticle, theta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mass"), OffsetOf(__shadow__::__BNmcparticle, mass), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("vx"), OffsetOf(__shadow__::__BNmcparticle, vx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("vy"), OffsetOf(__shadow__::__BNmcparticle, vy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("vz"), OffsetOf(__shadow__::__BNmcparticle, vz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("motherET"), OffsetOf(__shadow__::__BNmcparticle, motherET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("motherPT"), OffsetOf(__shadow__::__BNmcparticle, motherPT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("motherPhi"), OffsetOf(__shadow__::__BNmcparticle, motherPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("motherEta"), OffsetOf(__shadow__::__BNmcparticle, motherEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mother0ET"), OffsetOf(__shadow__::__BNmcparticle, mother0ET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mother0PT"), OffsetOf(__shadow__::__BNmcparticle, mother0PT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mother0Phi"), OffsetOf(__shadow__::__BNmcparticle, mother0Phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mother0Eta"), OffsetOf(__shadow__::__BNmcparticle, mother0Eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mother1ET"), OffsetOf(__shadow__::__BNmcparticle, mother1ET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mother1PT"), OffsetOf(__shadow__::__BNmcparticle, mother1PT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mother1Phi"), OffsetOf(__shadow__::__BNmcparticle, mother1Phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mother1Eta"), OffsetOf(__shadow__::__BNmcparticle, mother1Eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("daughter0ET"), OffsetOf(__shadow__::__BNmcparticle, daughter0ET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("daughter0PT"), OffsetOf(__shadow__::__BNmcparticle, daughter0PT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("daughter0Phi"), OffsetOf(__shadow__::__BNmcparticle, daughter0Phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("daughter0Eta"), OffsetOf(__shadow__::__BNmcparticle, daughter0Eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("daughter1ET"), OffsetOf(__shadow__::__BNmcparticle, daughter1ET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("daughter1PT"), OffsetOf(__shadow__::__BNmcparticle, daughter1PT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("daughter1Phi"), OffsetOf(__shadow__::__BNmcparticle, daughter1Phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("daughter1Eta"), OffsetOf(__shadow__::__BNmcparticle, daughter1Eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMotherET"), OffsetOf(__shadow__::__BNmcparticle, grandMotherET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMotherPT"), OffsetOf(__shadow__::__BNmcparticle, grandMotherPT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMotherPhi"), OffsetOf(__shadow__::__BNmcparticle, grandMotherPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMotherEta"), OffsetOf(__shadow__::__BNmcparticle, grandMotherEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother00ET"), OffsetOf(__shadow__::__BNmcparticle, grandMother00ET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother00PT"), OffsetOf(__shadow__::__BNmcparticle, grandMother00PT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother00Phi"), OffsetOf(__shadow__::__BNmcparticle, grandMother00Phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother00Eta"), OffsetOf(__shadow__::__BNmcparticle, grandMother00Eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother01ET"), OffsetOf(__shadow__::__BNmcparticle, grandMother01ET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother01PT"), OffsetOf(__shadow__::__BNmcparticle, grandMother01PT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother01Phi"), OffsetOf(__shadow__::__BNmcparticle, grandMother01Phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother01Eta"), OffsetOf(__shadow__::__BNmcparticle, grandMother01Eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother10ET"), OffsetOf(__shadow__::__BNmcparticle, grandMother10ET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother10PT"), OffsetOf(__shadow__::__BNmcparticle, grandMother10PT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother10Phi"), OffsetOf(__shadow__::__BNmcparticle, grandMother10Phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother10Eta"), OffsetOf(__shadow__::__BNmcparticle, grandMother10Eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother11ET"), OffsetOf(__shadow__::__BNmcparticle, grandMother11ET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother11PT"), OffsetOf(__shadow__::__BNmcparticle, grandMother11PT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother11Phi"), OffsetOf(__shadow__::__BNmcparticle, grandMother11Phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("grandMother11Eta"), OffsetOf(__shadow__::__BNmcparticle, grandMother11Eta), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("charge"), OffsetOf(__shadow__::__BNmcparticle, charge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("id"), OffsetOf(__shadow__::__BNmcparticle, id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("status"), OffsetOf(__shadow__::__BNmcparticle, status), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("motherId"), OffsetOf(__shadow__::__BNmcparticle, motherId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("motherCharge"), OffsetOf(__shadow__::__BNmcparticle, motherCharge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("mother0Id"), OffsetOf(__shadow__::__BNmcparticle, mother0Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("mother0Status"), OffsetOf(__shadow__::__BNmcparticle, mother0Status), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("mother0Charge"), OffsetOf(__shadow__::__BNmcparticle, mother0Charge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("mother1Id"), OffsetOf(__shadow__::__BNmcparticle, mother1Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("mother1Status"), OffsetOf(__shadow__::__BNmcparticle, mother1Status), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("mother1Charge"), OffsetOf(__shadow__::__BNmcparticle, mother1Charge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("daughter0Id"), OffsetOf(__shadow__::__BNmcparticle, daughter0Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("daughter0Status"), OffsetOf(__shadow__::__BNmcparticle, daughter0Status), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("daughter0Charge"), OffsetOf(__shadow__::__BNmcparticle, daughter0Charge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("daughter1Id"), OffsetOf(__shadow__::__BNmcparticle, daughter1Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("daughter1Status"), OffsetOf(__shadow__::__BNmcparticle, daughter1Status), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("daughter1Charge"), OffsetOf(__shadow__::__BNmcparticle, daughter1Charge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMotherId"), OffsetOf(__shadow__::__BNmcparticle, grandMotherId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMotherCharge"), OffsetOf(__shadow__::__BNmcparticle, grandMotherCharge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMother00Id"), OffsetOf(__shadow__::__BNmcparticle, grandMother00Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMother00Status"), OffsetOf(__shadow__::__BNmcparticle, grandMother00Status), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMother00Charge"), OffsetOf(__shadow__::__BNmcparticle, grandMother00Charge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMother01Id"), OffsetOf(__shadow__::__BNmcparticle, grandMother01Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMother01Status"), OffsetOf(__shadow__::__BNmcparticle, grandMother01Status), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMother01Charge"), OffsetOf(__shadow__::__BNmcparticle, grandMother01Charge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMother10Id"), OffsetOf(__shadow__::__BNmcparticle, grandMother10Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMother10Status"), OffsetOf(__shadow__::__BNmcparticle, grandMother10Status), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMother10Charge"), OffsetOf(__shadow__::__BNmcparticle, grandMother10Charge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMother11Id"), OffsetOf(__shadow__::__BNmcparticle, grandMother11Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMother11Status"), OffsetOf(__shadow__::__BNmcparticle, grandMother11Status), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("grandMother11Charge"), OffsetOf(__shadow__::__BNmcparticle, grandMother11Charge), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNmcparticle -------------------
void __BNmcparticle_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class BNskimbit -------------------------------
static void destructor_5151(void*, void * o, const std::vector<void*>&, void *) {
(((::BNskimbit*)o)->::BNskimbit::~BNskimbit)();
}
static  void operator_5152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNskimbit*)o)->operator=)(*(const ::BNskimbit*)arg[0]);
  else   (((::BNskimbit*)o)->operator=)(*(const ::BNskimbit*)arg[0]);
}

static void constructor_5153( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNskimbit(*(const ::BNskimbit*)arg[0]);
  else ::new(mem) ::BNskimbit(*(const ::BNskimbit*)arg[0]);
}

static void constructor_5154( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNskimbit(*(int*)arg[0]);
  else ::new(mem) ::BNskimbit(*(int*)arg[0]);
}

static void constructor_5155( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNskimbit();
  else ::new(mem) ::BNskimbit();
}

static void method_newdel_891( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNskimbit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNskimbit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNskimbit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNskimbit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNskimbit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNskimbit -------------------------------
void __BNskimbit_db_datamem(Reflex::Class*);
void __BNskimbit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNskimbit_datamem_bld(&__BNskimbit_db_datamem);
Reflex::GenreflexMemberBuilder __BNskimbit_funcmem_bld(&__BNskimbit_db_funcmem);
void __BNskimbit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNskimbit"), typeid(::BNskimbit), sizeof(::BNskimbit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNskimbit"), destructor_5151, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3054, type_3056), Reflex::Literal("operator="), operator_5152, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3056), Reflex::Literal("BNskimbit"), constructor_5153, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_58), Reflex::Literal("BNskimbit"), constructor_5154, 0, "c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNskimbit"), constructor_5155, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_891, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNskimbit_datamem_bld);
}

//------Delayed data member builder for class BNskimbit -------------------
void __BNskimbit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_58, Reflex::Literal("EG"), OffsetOf(__shadow__::__BNskimbit, EG), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("JetMETTau"), OffsetOf(__shadow__::__BNskimbit, JetMETTau), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HLT_Ele15_LW_L1R"), OffsetOf(__shadow__::__BNskimbit, HLT_Ele15_LW_L1R), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HLT_Jet15U"), OffsetOf(__shadow__::__BNskimbit, HLT_Jet15U), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HLT_Jet30U"), OffsetOf(__shadow__::__BNskimbit, HLT_Jet30U), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HLT_Jet50U"), OffsetOf(__shadow__::__BNskimbit, HLT_Jet50U), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HLT_Ele15_SW_L1R"), OffsetOf(__shadow__::__BNskimbit, HLT_Ele15_SW_L1R), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HLT_L1Jet15"), OffsetOf(__shadow__::__BNskimbit, HLT_L1Jet15), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HLT_Jet30"), OffsetOf(__shadow__::__BNskimbit, HLT_Jet30), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HLT_Jet50"), OffsetOf(__shadow__::__BNskimbit, HLT_Jet50), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("Ncalojet"), OffsetOf(__shadow__::__BNskimbit, Ncalojet), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("Npfjet"), OffsetOf(__shadow__::__BNskimbit, Npfjet), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("Ntcjet"), OffsetOf(__shadow__::__BNskimbit, Ntcjet), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("Nele"), OffsetOf(__shadow__::__BNskimbit, Nele), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("MET30"), OffsetOf(__shadow__::__BNskimbit, MET30), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("MET100"), OffsetOf(__shadow__::__BNskimbit, MET100), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("MET150"), OffsetOf(__shadow__::__BNskimbit, MET150), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("L1T_TechBit_032"), OffsetOf(__shadow__::__BNskimbit, L1T_TechBit_032), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("L1T_TechBit_033"), OffsetOf(__shadow__::__BNskimbit, L1T_TechBit_033), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("L1T_TechBit_040"), OffsetOf(__shadow__::__BNskimbit, L1T_TechBit_040), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("L1T_TechBit_041"), OffsetOf(__shadow__::__BNskimbit, L1T_TechBit_041), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("L1T_TechBit_032_to_043"), OffsetOf(__shadow__::__BNskimbit, L1T_TechBit_032_to_043), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("GoodVertex"), OffsetOf(__shadow__::__BNskimbit, GoodVertex), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("FilterOutScraping"), OffsetOf(__shadow__::__BNskimbit, FilterOutScraping), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("FilterOutScrapingFraction"), OffsetOf(__shadow__::__BNskimbit, FilterOutScrapingFraction), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNskimbit -------------------
void __BNskimbit_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BNskimbit,std::allocator<BNskimbit> > -------------------------------
static void constructor_3067( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNskimbit>();
  else ::new(mem) ::std::vector<BNskimbit>();
}

static void constructor_3068( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNskimbit>(*(const ::std::allocator<BNskimbit>*)arg[0]);
  else ::new(mem) ::std::vector<BNskimbit>(*(const ::std::allocator<BNskimbit>*)arg[0]);
}

static void constructor_3069( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNskimbit>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNskimbit>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNskimbit>(*(::std::size_t*)arg[0],
      *(const ::BNskimbit*)arg[1]);
  else ::new(mem) ::std::vector<BNskimbit>(*(::std::size_t*)arg[0],
      *(const ::BNskimbit*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNskimbit>(*(::std::size_t*)arg[0],
      *(const ::BNskimbit*)arg[1],
      *(const ::std::allocator<BNskimbit>*)arg[2]);
  else ::new(mem) ::std::vector<BNskimbit>(*(::std::size_t*)arg[0],
      *(const ::BNskimbit*)arg[1],
      *(const ::std::allocator<BNskimbit>*)arg[2]);
  }
}

static void constructor_3070( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNskimbit>(*(const ::std::vector<BNskimbit>*)arg[0]);
  else ::new(mem) ::std::vector<BNskimbit>(*(const ::std::vector<BNskimbit>*)arg[0]);
}

static void destructor_3071(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNskimbit>*)o)->::std::vector<BNskimbit>::~vector)();
}
static  void operator_3072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNskimbit>*)o)->operator=)(*(const ::std::vector<BNskimbit>*)arg[0]);
  else   (((::std::vector<BNskimbit>*)o)->operator=)(*(const ::std::vector<BNskimbit>*)arg[0]);
}

static  void method_3073( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNskimbit>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNskimbit*)arg[1]);
}

static  void method_3074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >)((((::std::vector<BNskimbit>*)o)->begin)());
  else   (((::std::vector<BNskimbit>*)o)->begin)();
}

static  void method_3075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNskimbit*,std::vector<BNskimbit> >)((((const ::std::vector<BNskimbit>*)o)->begin)());
  else   (((const ::std::vector<BNskimbit>*)o)->begin)();
}

static  void method_3076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >)((((::std::vector<BNskimbit>*)o)->end)());
  else   (((::std::vector<BNskimbit>*)o)->end)();
}

static  void method_3077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNskimbit*,std::vector<BNskimbit> >)((((const ::std::vector<BNskimbit>*)o)->end)());
  else   (((const ::std::vector<BNskimbit>*)o)->end)();
}

static  void method_3082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNskimbit>*)o)->size)());
  else   (((const ::std::vector<BNskimbit>*)o)->size)();
}

static  void method_3083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNskimbit>*)o)->max_size)());
  else   (((const ::std::vector<BNskimbit>*)o)->max_size)();
}

static  void method_3084( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNskimbit>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNskimbit>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNskimbit*)arg[1]);
  }
}

static  void method_3085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNskimbit>*)o)->capacity)());
  else   (((const ::std::vector<BNskimbit>*)o)->capacity)();
}

static  void method_3086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNskimbit>*)o)->empty)());
  else   (((const ::std::vector<BNskimbit>*)o)->empty)();
}

static  void method_3087( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNskimbit>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNskimbit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNskimbit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNskimbit>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNskimbit>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNskimbit>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNskimbit>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNskimbit>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNskimbit>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNskimbit>*)o)->front)();
  else   (((::std::vector<BNskimbit>*)o)->front)();
}

static  void method_3094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNskimbit>*)o)->front)();
  else   (((const ::std::vector<BNskimbit>*)o)->front)();
}

static  void method_3095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNskimbit>*)o)->back)();
  else   (((::std::vector<BNskimbit>*)o)->back)();
}

static  void method_3096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNskimbit>*)o)->back)();
  else   (((const ::std::vector<BNskimbit>*)o)->back)();
}

static  void method_3097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNskimbit>*)o)->data)());
  else   (((::std::vector<BNskimbit>*)o)->data)();
}

static  void method_3098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNskimbit>*)o)->data)());
  else   (((const ::std::vector<BNskimbit>*)o)->data)();
}

static  void method_3099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNskimbit>*)o)->push_back)(*(const ::BNskimbit*)arg[0]);
}

static  void method_3100( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNskimbit>*)o)->pop_back)();
}

static  void method_3101( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >)((((::std::vector<BNskimbit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >*)arg[0],
    *(const ::BNskimbit*)arg[1]));
  else   (((::std::vector<BNskimbit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >*)arg[0],
    *(const ::BNskimbit*)arg[1]);
}

static  void method_3102( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNskimbit>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNskimbit*)arg[2]);
}

static  void method_3103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >)((((::std::vector<BNskimbit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >*)arg[0]));
  else   (((::std::vector<BNskimbit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >*)arg[0]);
}

static  void method_3104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >)((((::std::vector<BNskimbit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >*)arg[1]));
  else   (((::std::vector<BNskimbit>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNskimbit*,std::vector<BNskimbit> >*)arg[1]);
}

static  void method_3105( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNskimbit>*)o)->swap)(*(::std::vector<BNskimbit>*)arg[0]);
}

static  void method_3106( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNskimbit>*)o)->clear)();
}

static void method_newdel_125( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNskimbit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNskimbit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNskimbit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNskimbit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNskimbit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNskimbit,std::allocator<BNskimbit> >")), ::Reflex::BaseOffset< ::std::vector<BNskimbit>,::std::_Vector_base<BNskimbit,std::allocator<BNskimbit> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNskimbit> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNskimbit> >::Generate();
}

//------Dictionary for class vector<BNskimbit,std::allocator<BNskimbit> > -------------------------------
void __std__vector_BNskimbit__db_datamem(Reflex::Class*);
void __std__vector_BNskimbit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNskimbit__datamem_bld(&__std__vector_BNskimbit__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNskimbit__funcmem_bld(&__std__vector_BNskimbit__db_funcmem);
void __std__vector_BNskimbit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNskimbit>"), typeid(::std::vector<BNskimbit>), sizeof(::std::vector<BNskimbit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1827, ::Reflex::BaseOffset< ::std::vector<BNskimbit>, ::std::_Vector_base<BNskimbit,std::allocator<BNskimbit> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_891, Reflex::Literal("std::vector<BNskimbit>::_Alloc_value_type"))
  .AddTypedef(type_1827, Reflex::Literal("std::vector<BNskimbit>::_Base"))
  .AddTypedef(type_2542, Reflex::Literal("std::vector<BNskimbit>::_Tp_alloc_type"))
  .AddTypedef(type_891, Reflex::Literal("std::vector<BNskimbit>::value_type"))
  .AddTypedef(type_3050, Reflex::Literal("std::vector<BNskimbit>::pointer"))
  .AddTypedef(type_3052, Reflex::Literal("std::vector<BNskimbit>::const_pointer"))
  .AddTypedef(type_3054, Reflex::Literal("std::vector<BNskimbit>::reference"))
  .AddTypedef(type_3056, Reflex::Literal("std::vector<BNskimbit>::const_reference"))
  .AddTypedef(type_3058, Reflex::Literal("std::vector<BNskimbit>::iterator"))
  .AddTypedef(type_3060, Reflex::Literal("std::vector<BNskimbit>::const_iterator"))
  .AddTypedef(type_2687, Reflex::Literal("std::vector<BNskimbit>::const_reverse_iterator"))
  .AddTypedef(type_2688, Reflex::Literal("std::vector<BNskimbit>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNskimbit>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNskimbit>::difference_type"))
  .AddTypedef(type_2542, Reflex::Literal("std::vector<BNskimbit>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3067, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13716), Reflex::Literal("vector"), constructor_3068, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_3056, type_13716), Reflex::Literal("vector"), constructor_3069, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13717), Reflex::Literal("vector"), constructor_3070, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3071, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_125, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNskimbit__funcmem_bld);
}

//------Delayed data member builder for class vector<BNskimbit,std::allocator<BNskimbit> > -------------------
void __std__vector_BNskimbit__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNskimbit,std::allocator<BNskimbit> > -------------------
void __std__vector_BNskimbit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13718, type_13717), Reflex::Literal("operator="), operator_3072, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_3056), Reflex::Literal("assign"), method_3073, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3058), Reflex::Literal("begin"), method_3074, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3060), Reflex::Literal("begin"), method_3075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3058), Reflex::Literal("end"), method_3076, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3060), Reflex::Literal("end"), method_3077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_3082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_3083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_891), Reflex::Literal("resize"), method_3084, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_3085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_3086, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_3087, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3054, type_2521), Reflex::Literal("operator[]"), operator_3088, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_2521), Reflex::Literal("operator[]"), operator_3089, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3054, type_2521), Reflex::Literal("at"), method_3091, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056, type_2521), Reflex::Literal("at"), method_3092, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3054), Reflex::Literal("front"), method_3093, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056), Reflex::Literal("front"), method_3094, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3054), Reflex::Literal("back"), method_3095, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3056), Reflex::Literal("back"), method_3096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3050), Reflex::Literal("data"), method_3097, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("data"), method_3098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_3056), Reflex::Literal("push_back"), method_3099, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_3100, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3058, type_3058, type_3056), Reflex::Literal("insert"), method_3101, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_3058, type_2521, type_3056), Reflex::Literal("insert"), method_3102, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3058, type_3058), Reflex::Literal("erase"), method_3103, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3058, type_3058, type_3058), Reflex::Literal("erase"), method_3104, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_13718), Reflex::Literal("swap"), method_3105, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_3106, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BNtrigobj -------------------------------
static void destructor_3351(void*, void * o, const std::vector<void*>&, void *) {
(((::BNtrigobj*)o)->::BNtrigobj::~BNtrigobj)();
}
static  void operator_3352( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNtrigobj*)o)->operator=)(*(const ::BNtrigobj*)arg[0]);
  else   (((::BNtrigobj*)o)->operator=)(*(const ::BNtrigobj*)arg[0]);
}

static void constructor_3353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNtrigobj(*(const ::BNtrigobj*)arg[0]);
  else ::new(mem) ::BNtrigobj(*(const ::BNtrigobj*)arg[0]);
}

static void constructor_3354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNtrigobj(*(double*)arg[0],
      *(int*)arg[1],
      *(::std::string*)arg[2]);
  else ::new(mem) ::BNtrigobj(*(double*)arg[0],
      *(int*)arg[1],
      *(::std::string*)arg[2]);
}

static void constructor_3355( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNtrigobj();
  else ::new(mem) ::BNtrigobj();
}

static void method_newdel_196( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNtrigobj >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNtrigobj >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNtrigobj >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNtrigobj >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNtrigobj >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNtrigobj -------------------------------
void __BNtrigobj_db_datamem(Reflex::Class*);
void __BNtrigobj_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNtrigobj_datamem_bld(&__BNtrigobj_db_datamem);
Reflex::GenreflexMemberBuilder __BNtrigobj_funcmem_bld(&__BNtrigobj_db_funcmem);
void __BNtrigobj_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNtrigobj"), typeid(::BNtrigobj), sizeof(::BNtrigobj), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNtrigobj"), destructor_3351, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3124, type_3126), Reflex::Literal("operator="), operator_3352, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3126), Reflex::Literal("BNtrigobj"), constructor_3353, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698, type_58, type_1866), Reflex::Literal("BNtrigobj"), constructor_3354, 0, "v;c;n", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNtrigobj"), constructor_3355, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_196, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNtrigobj_datamem_bld);
}

//------Delayed data member builder for class BNtrigobj -------------------
void __BNtrigobj_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("pt"), OffsetOf(__shadow__::__BNtrigobj, pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eta"), OffsetOf(__shadow__::__BNtrigobj, eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("phi"), OffsetOf(__shadow__::__BNtrigobj, phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("px"), OffsetOf(__shadow__::__BNtrigobj, px), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("py"), OffsetOf(__shadow__::__BNtrigobj, py), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pz"), OffsetOf(__shadow__::__BNtrigobj, pz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("et"), OffsetOf(__shadow__::__BNtrigobj, et), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("energy"), OffsetOf(__shadow__::__BNtrigobj, energy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("etTotal"), OffsetOf(__shadow__::__BNtrigobj, etTotal), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("id"), OffsetOf(__shadow__::__BNtrigobj, id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("charge"), OffsetOf(__shadow__::__BNtrigobj, charge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isIsolated"), OffsetOf(__shadow__::__BNtrigobj, isIsolated), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isMip"), OffsetOf(__shadow__::__BNtrigobj, isMip), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isForward"), OffsetOf(__shadow__::__BNtrigobj, isForward), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isRPC"), OffsetOf(__shadow__::__BNtrigobj, isRPC), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("bx"), OffsetOf(__shadow__::__BNtrigobj, bx), ::Reflex::PUBLIC)
  .AddDataMember(type_1866, Reflex::Literal("filter"), OffsetOf(__shadow__::__BNtrigobj, filter), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNtrigobj -------------------
void __BNtrigobj_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BNtrigobj,std::allocator<BNtrigobj> > -------------------------------
static void constructor_3137( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrigobj>();
  else ::new(mem) ::std::vector<BNtrigobj>();
}

static void constructor_3138( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrigobj>(*(const ::std::allocator<BNtrigobj>*)arg[0]);
  else ::new(mem) ::std::vector<BNtrigobj>(*(const ::std::allocator<BNtrigobj>*)arg[0]);
}

static void constructor_3139( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrigobj>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNtrigobj>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrigobj>(*(::std::size_t*)arg[0],
      *(const ::BNtrigobj*)arg[1]);
  else ::new(mem) ::std::vector<BNtrigobj>(*(::std::size_t*)arg[0],
      *(const ::BNtrigobj*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrigobj>(*(::std::size_t*)arg[0],
      *(const ::BNtrigobj*)arg[1],
      *(const ::std::allocator<BNtrigobj>*)arg[2]);
  else ::new(mem) ::std::vector<BNtrigobj>(*(::std::size_t*)arg[0],
      *(const ::BNtrigobj*)arg[1],
      *(const ::std::allocator<BNtrigobj>*)arg[2]);
  }
}

static void constructor_3140( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrigobj>(*(const ::std::vector<BNtrigobj>*)arg[0]);
  else ::new(mem) ::std::vector<BNtrigobj>(*(const ::std::vector<BNtrigobj>*)arg[0]);
}

static void destructor_3141(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNtrigobj>*)o)->::std::vector<BNtrigobj>::~vector)();
}
static  void operator_3142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrigobj>*)o)->operator=)(*(const ::std::vector<BNtrigobj>*)arg[0]);
  else   (((::std::vector<BNtrigobj>*)o)->operator=)(*(const ::std::vector<BNtrigobj>*)arg[0]);
}

static  void method_3143( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrigobj>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNtrigobj*)arg[1]);
}

static  void method_3144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >)((((::std::vector<BNtrigobj>*)o)->begin)());
  else   (((::std::vector<BNtrigobj>*)o)->begin)();
}

static  void method_3145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNtrigobj*,std::vector<BNtrigobj> >)((((const ::std::vector<BNtrigobj>*)o)->begin)());
  else   (((const ::std::vector<BNtrigobj>*)o)->begin)();
}

static  void method_3146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >)((((::std::vector<BNtrigobj>*)o)->end)());
  else   (((::std::vector<BNtrigobj>*)o)->end)();
}

static  void method_3147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNtrigobj*,std::vector<BNtrigobj> >)((((const ::std::vector<BNtrigobj>*)o)->end)());
  else   (((const ::std::vector<BNtrigobj>*)o)->end)();
}

static  void method_3152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNtrigobj>*)o)->size)());
  else   (((const ::std::vector<BNtrigobj>*)o)->size)();
}

static  void method_3153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNtrigobj>*)o)->max_size)());
  else   (((const ::std::vector<BNtrigobj>*)o)->max_size)();
}

static  void method_3154( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNtrigobj>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNtrigobj>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNtrigobj*)arg[1]);
  }
}

static  void method_3155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNtrigobj>*)o)->capacity)());
  else   (((const ::std::vector<BNtrigobj>*)o)->capacity)();
}

static  void method_3156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNtrigobj>*)o)->empty)());
  else   (((const ::std::vector<BNtrigobj>*)o)->empty)();
}

static  void method_3157( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrigobj>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrigobj>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNtrigobj>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3159( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtrigobj>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNtrigobj>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrigobj>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNtrigobj>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtrigobj>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNtrigobj>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrigobj>*)o)->front)();
  else   (((::std::vector<BNtrigobj>*)o)->front)();
}

static  void method_3164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtrigobj>*)o)->front)();
  else   (((const ::std::vector<BNtrigobj>*)o)->front)();
}

static  void method_3165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrigobj>*)o)->back)();
  else   (((::std::vector<BNtrigobj>*)o)->back)();
}

static  void method_3166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtrigobj>*)o)->back)();
  else   (((const ::std::vector<BNtrigobj>*)o)->back)();
}

static  void method_3167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNtrigobj>*)o)->data)());
  else   (((::std::vector<BNtrigobj>*)o)->data)();
}

static  void method_3168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNtrigobj>*)o)->data)());
  else   (((const ::std::vector<BNtrigobj>*)o)->data)();
}

static  void method_3169( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrigobj>*)o)->push_back)(*(const ::BNtrigobj*)arg[0]);
}

static  void method_3170( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNtrigobj>*)o)->pop_back)();
}

static  void method_3171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >)((((::std::vector<BNtrigobj>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >*)arg[0],
    *(const ::BNtrigobj*)arg[1]));
  else   (((::std::vector<BNtrigobj>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >*)arg[0],
    *(const ::BNtrigobj*)arg[1]);
}

static  void method_3172( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrigobj>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNtrigobj*)arg[2]);
}

static  void method_3173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >)((((::std::vector<BNtrigobj>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >*)arg[0]));
  else   (((::std::vector<BNtrigobj>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >*)arg[0]);
}

static  void method_3174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >)((((::std::vector<BNtrigobj>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >*)arg[1]));
  else   (((::std::vector<BNtrigobj>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNtrigobj*,std::vector<BNtrigobj> >*)arg[1]);
}

static  void method_3175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrigobj>*)o)->swap)(*(::std::vector<BNtrigobj>*)arg[0]);
}

static  void method_3176( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNtrigobj>*)o)->clear)();
}

static void method_newdel_140( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrigobj> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrigobj> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrigobj> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrigobj> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrigobj> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNtrigobj,std::allocator<BNtrigobj> >")), ::Reflex::BaseOffset< ::std::vector<BNtrigobj>,::std::_Vector_base<BNtrigobj,std::allocator<BNtrigobj> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNtrigobj> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNtrigobj> >::Generate();
}

//------Dictionary for class vector<BNtrigobj,std::allocator<BNtrigobj> > -------------------------------
void __std__vector_BNtrigobj__db_datamem(Reflex::Class*);
void __std__vector_BNtrigobj__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNtrigobj__datamem_bld(&__std__vector_BNtrigobj__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNtrigobj__funcmem_bld(&__std__vector_BNtrigobj__db_funcmem);
void __std__vector_BNtrigobj__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNtrigobj>"), typeid(::std::vector<BNtrigobj>), sizeof(::std::vector<BNtrigobj>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1826, ::Reflex::BaseOffset< ::std::vector<BNtrigobj>, ::std::_Vector_base<BNtrigobj,std::allocator<BNtrigobj> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_196, Reflex::Literal("std::vector<BNtrigobj>::_Alloc_value_type"))
  .AddTypedef(type_1826, Reflex::Literal("std::vector<BNtrigobj>::_Base"))
  .AddTypedef(type_2541, Reflex::Literal("std::vector<BNtrigobj>::_Tp_alloc_type"))
  .AddTypedef(type_196, Reflex::Literal("std::vector<BNtrigobj>::value_type"))
  .AddTypedef(type_3120, Reflex::Literal("std::vector<BNtrigobj>::pointer"))
  .AddTypedef(type_3122, Reflex::Literal("std::vector<BNtrigobj>::const_pointer"))
  .AddTypedef(type_3124, Reflex::Literal("std::vector<BNtrigobj>::reference"))
  .AddTypedef(type_3126, Reflex::Literal("std::vector<BNtrigobj>::const_reference"))
  .AddTypedef(type_3128, Reflex::Literal("std::vector<BNtrigobj>::iterator"))
  .AddTypedef(type_3130, Reflex::Literal("std::vector<BNtrigobj>::const_iterator"))
  .AddTypedef(type_2685, Reflex::Literal("std::vector<BNtrigobj>::const_reverse_iterator"))
  .AddTypedef(type_2686, Reflex::Literal("std::vector<BNtrigobj>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNtrigobj>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNtrigobj>::difference_type"))
  .AddTypedef(type_2541, Reflex::Literal("std::vector<BNtrigobj>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3137, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13721), Reflex::Literal("vector"), constructor_3138, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_3126, type_13721), Reflex::Literal("vector"), constructor_3139, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13722), Reflex::Literal("vector"), constructor_3140, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3141, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_140, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNtrigobj__funcmem_bld);
}

//------Delayed data member builder for class vector<BNtrigobj,std::allocator<BNtrigobj> > -------------------
void __std__vector_BNtrigobj__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNtrigobj,std::allocator<BNtrigobj> > -------------------
void __std__vector_BNtrigobj__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13723, type_13722), Reflex::Literal("operator="), operator_3142, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_3126), Reflex::Literal("assign"), method_3143, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3128), Reflex::Literal("begin"), method_3144, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3130), Reflex::Literal("begin"), method_3145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3128), Reflex::Literal("end"), method_3146, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3130), Reflex::Literal("end"), method_3147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_3152, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_3153, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_196), Reflex::Literal("resize"), method_3154, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_3155, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_3156, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_3157, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3124, type_2521), Reflex::Literal("operator[]"), operator_3158, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3126, type_2521), Reflex::Literal("operator[]"), operator_3159, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3124, type_2521), Reflex::Literal("at"), method_3161, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3126, type_2521), Reflex::Literal("at"), method_3162, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3124), Reflex::Literal("front"), method_3163, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3126), Reflex::Literal("front"), method_3164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3124), Reflex::Literal("back"), method_3165, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3126), Reflex::Literal("back"), method_3166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3120), Reflex::Literal("data"), method_3167, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3122), Reflex::Literal("data"), method_3168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_3126), Reflex::Literal("push_back"), method_3169, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_3170, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3128, type_3128, type_3126), Reflex::Literal("insert"), method_3171, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_3128, type_2521, type_3126), Reflex::Literal("insert"), method_3172, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3128, type_3128), Reflex::Literal("erase"), method_3173, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3128, type_3128, type_3128), Reflex::Literal("erase"), method_3174, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_13723), Reflex::Literal("swap"), method_3175, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_3176, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BNtrack -------------------------------
static void destructor_5729(void*, void * o, const std::vector<void*>&, void *) {
(((::BNtrack*)o)->::BNtrack::~BNtrack)();
}
static  void operator_5730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNtrack*)o)->operator=)(*(const ::BNtrack*)arg[0]);
  else   (((::BNtrack*)o)->operator=)(*(const ::BNtrack*)arg[0]);
}

static void constructor_5731( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNtrack(*(const ::BNtrack*)arg[0]);
  else ::new(mem) ::BNtrack(*(const ::BNtrack*)arg[0]);
}

static void constructor_5732( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNtrack(*(double*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::BNtrack(*(double*)arg[0],
      *(int*)arg[1]);
}

static void constructor_5733( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNtrack();
  else ::new(mem) ::BNtrack();
}

static void method_newdel_1488( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNtrack >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNtrack >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNtrack >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNtrack >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNtrack >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNtrack -------------------------------
void __BNtrack_db_datamem(Reflex::Class*);
void __BNtrack_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNtrack_datamem_bld(&__BNtrack_db_datamem);
Reflex::GenreflexMemberBuilder __BNtrack_funcmem_bld(&__BNtrack_db_funcmem);
void __BNtrack_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNtrack"), typeid(::BNtrack), sizeof(::BNtrack), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNtrack"), destructor_5729, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3203, type_3205), Reflex::Literal("operator="), operator_5730, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3205), Reflex::Literal("BNtrack"), constructor_5731, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698, type_58), Reflex::Literal("BNtrack"), constructor_5732, 0, "v;c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNtrack"), constructor_5733, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1488, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNtrack_datamem_bld);
}

//------Delayed data member builder for class BNtrack -------------------
void __BNtrack_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("pt"), OffsetOf(__shadow__::__BNtrack, pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ptError"), OffsetOf(__shadow__::__BNtrack, ptError), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("px"), OffsetOf(__shadow__::__BNtrack, px), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("py"), OffsetOf(__shadow__::__BNtrack, py), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pz"), OffsetOf(__shadow__::__BNtrack, pz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("phi"), OffsetOf(__shadow__::__BNtrack, phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eta"), OffsetOf(__shadow__::__BNtrack, eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("theta"), OffsetOf(__shadow__::__BNtrack, theta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("normChi2"), OffsetOf(__shadow__::__BNtrack, normChi2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("dZ"), OffsetOf(__shadow__::__BNtrack, dZ), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("d0"), OffsetOf(__shadow__::__BNtrack, d0), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("d0err"), OffsetOf(__shadow__::__BNtrack, d0err), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("vx"), OffsetOf(__shadow__::__BNtrack, vx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("vy"), OffsetOf(__shadow__::__BNtrack, vy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("vz"), OffsetOf(__shadow__::__BNtrack, vz), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("charge"), OffsetOf(__shadow__::__BNtrack, charge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numValidHits"), OffsetOf(__shadow__::__BNtrack, numValidHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isHighPurity"), OffsetOf(__shadow__::__BNtrack, isHighPurity), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("nHitsMissingOuter"), OffsetOf(__shadow__::__BNtrack, nHitsMissingOuter), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("nHitsMissingInner"), OffsetOf(__shadow__::__BNtrack, nHitsMissingInner), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("nHitsMissingMiddle"), OffsetOf(__shadow__::__BNtrack, nHitsMissingMiddle), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("layersWithMeasurement"), OffsetOf(__shadow__::__BNtrack, layersWithMeasurement), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfHits"), OffsetOf(__shadow__::__BNtrack, numberOfHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfLostHits"), OffsetOf(__shadow__::__BNtrack, numberOfLostHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfValidPixelHits"), OffsetOf(__shadow__::__BNtrack, numberOfValidPixelHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfValidStripHits"), OffsetOf(__shadow__::__BNtrack, numberOfValidStripHits), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("lastHitOuterRadius"), OffsetOf(__shadow__::__BNtrack, lastHitOuterRadius), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("lastHitOuterEta"), OffsetOf(__shadow__::__BNtrack, lastHitOuterEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("lastHitOuterTheta"), OffsetOf(__shadow__::__BNtrack, lastHitOuterTheta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("lastHitOuterPhi"), OffsetOf(__shadow__::__BNtrack, lastHitOuterPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloEMDeltaRp3"), OffsetOf(__shadow__::__BNtrack, caloEMDeltaRp3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloHadDeltaRp3"), OffsetOf(__shadow__::__BNtrack, caloHadDeltaRp3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloEMDeltaRp4"), OffsetOf(__shadow__::__BNtrack, caloEMDeltaRp4), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloHadDeltaRp4"), OffsetOf(__shadow__::__BNtrack, caloHadDeltaRp4), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloEMDeltaRp5"), OffsetOf(__shadow__::__BNtrack, caloEMDeltaRp5), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloHadDeltaRp5"), OffsetOf(__shadow__::__BNtrack, caloHadDeltaRp5), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("depTrkRp3"), OffsetOf(__shadow__::__BNtrack, depTrkRp3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("depEcalRp3"), OffsetOf(__shadow__::__BNtrack, depEcalRp3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("depHcalRp3"), OffsetOf(__shadow__::__BNtrack, depHcalRp3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("depHoRp3"), OffsetOf(__shadow__::__BNtrack, depHoRp3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("nTracksRp3"), OffsetOf(__shadow__::__BNtrack, nTracksRp3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("trackerVetoPtRp3"), OffsetOf(__shadow__::__BNtrack, trackerVetoPtRp3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("emVetoEtRp3"), OffsetOf(__shadow__::__BNtrack, emVetoEtRp3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hadVetoEtRp3"), OffsetOf(__shadow__::__BNtrack, hadVetoEtRp3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hoVetoEtRp3"), OffsetOf(__shadow__::__BNtrack, hoVetoEtRp3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("depTrkRp5"), OffsetOf(__shadow__::__BNtrack, depTrkRp5), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("depEcalRp5"), OffsetOf(__shadow__::__BNtrack, depEcalRp5), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("depHcalRp5"), OffsetOf(__shadow__::__BNtrack, depHcalRp5), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("depHoRp5"), OffsetOf(__shadow__::__BNtrack, depHoRp5), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("nTracksRp5"), OffsetOf(__shadow__::__BNtrack, nTracksRp5), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("trackerVetoPtRp5"), OffsetOf(__shadow__::__BNtrack, trackerVetoPtRp5), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("emVetoEtRp5"), OffsetOf(__shadow__::__BNtrack, emVetoEtRp5), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hadVetoEtRp5"), OffsetOf(__shadow__::__BNtrack, hadVetoEtRp5), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hoVetoEtRp5"), OffsetOf(__shadow__::__BNtrack, hoVetoEtRp5), ::Reflex::PUBLIC)
  .AddDataMember(type_2317, Reflex::Literal("subDetIdHits"), OffsetOf(__shadow__::__BNtrack, subDetIdHits), ::Reflex::PUBLIC)
  .AddDataMember(type_2317, Reflex::Literal("rawDetIdHits"), OffsetOf(__shadow__::__BNtrack, rawDetIdHits), ::Reflex::PUBLIC)
  .AddDataMember(type_2318, Reflex::Literal("isValidHits"), OffsetOf(__shadow__::__BNtrack, isValidHits), ::Reflex::PUBLIC)
  .AddDataMember(type_2316, Reflex::Literal("modulePerpHits"), OffsetOf(__shadow__::__BNtrack, modulePerpHits), ::Reflex::PUBLIC)
  .AddDataMember(type_2316, Reflex::Literal("moduleZHits"), OffsetOf(__shadow__::__BNtrack, moduleZHits), ::Reflex::PUBLIC)
  .AddDataMember(type_2316, Reflex::Literal("modulePhiHits"), OffsetOf(__shadow__::__BNtrack, modulePhiHits), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNtrack -------------------
void __BNtrack_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BNtrack,std::allocator<BNtrack> > -------------------------------
static void constructor_3216( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrack>();
  else ::new(mem) ::std::vector<BNtrack>();
}

static void constructor_3217( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrack>(*(const ::std::allocator<BNtrack>*)arg[0]);
  else ::new(mem) ::std::vector<BNtrack>(*(const ::std::allocator<BNtrack>*)arg[0]);
}

static void constructor_3218( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrack>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNtrack>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrack>(*(::std::size_t*)arg[0],
      *(const ::BNtrack*)arg[1]);
  else ::new(mem) ::std::vector<BNtrack>(*(::std::size_t*)arg[0],
      *(const ::BNtrack*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrack>(*(::std::size_t*)arg[0],
      *(const ::BNtrack*)arg[1],
      *(const ::std::allocator<BNtrack>*)arg[2]);
  else ::new(mem) ::std::vector<BNtrack>(*(::std::size_t*)arg[0],
      *(const ::BNtrack*)arg[1],
      *(const ::std::allocator<BNtrack>*)arg[2]);
  }
}

static void constructor_3219( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrack>(*(const ::std::vector<BNtrack>*)arg[0]);
  else ::new(mem) ::std::vector<BNtrack>(*(const ::std::vector<BNtrack>*)arg[0]);
}

static void destructor_3220(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNtrack>*)o)->::std::vector<BNtrack>::~vector)();
}
static  void operator_3221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrack>*)o)->operator=)(*(const ::std::vector<BNtrack>*)arg[0]);
  else   (((::std::vector<BNtrack>*)o)->operator=)(*(const ::std::vector<BNtrack>*)arg[0]);
}

static  void method_3222( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrack>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNtrack*)arg[1]);
}

static  void method_3223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >)((((::std::vector<BNtrack>*)o)->begin)());
  else   (((::std::vector<BNtrack>*)o)->begin)();
}

static  void method_3224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNtrack*,std::vector<BNtrack> >)((((const ::std::vector<BNtrack>*)o)->begin)());
  else   (((const ::std::vector<BNtrack>*)o)->begin)();
}

static  void method_3225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >)((((::std::vector<BNtrack>*)o)->end)());
  else   (((::std::vector<BNtrack>*)o)->end)();
}

static  void method_3226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNtrack*,std::vector<BNtrack> >)((((const ::std::vector<BNtrack>*)o)->end)());
  else   (((const ::std::vector<BNtrack>*)o)->end)();
}

static  void method_3231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNtrack>*)o)->size)());
  else   (((const ::std::vector<BNtrack>*)o)->size)();
}

static  void method_3232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNtrack>*)o)->max_size)());
  else   (((const ::std::vector<BNtrack>*)o)->max_size)();
}

static  void method_3233( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNtrack>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNtrack>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNtrack*)arg[1]);
  }
}

static  void method_3234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNtrack>*)o)->capacity)());
  else   (((const ::std::vector<BNtrack>*)o)->capacity)();
}

static  void method_3235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNtrack>*)o)->empty)());
  else   (((const ::std::vector<BNtrack>*)o)->empty)();
}

static  void method_3236( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrack>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3237( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrack>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNtrack>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3238( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtrack>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNtrack>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrack>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNtrack>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtrack>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNtrack>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrack>*)o)->front)();
  else   (((::std::vector<BNtrack>*)o)->front)();
}

static  void method_3243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtrack>*)o)->front)();
  else   (((const ::std::vector<BNtrack>*)o)->front)();
}

static  void method_3244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrack>*)o)->back)();
  else   (((::std::vector<BNtrack>*)o)->back)();
}

static  void method_3245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtrack>*)o)->back)();
  else   (((const ::std::vector<BNtrack>*)o)->back)();
}

static  void method_3246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNtrack>*)o)->data)());
  else   (((::std::vector<BNtrack>*)o)->data)();
}

static  void method_3247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNtrack>*)o)->data)());
  else   (((const ::std::vector<BNtrack>*)o)->data)();
}

static  void method_3248( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrack>*)o)->push_back)(*(const ::BNtrack*)arg[0]);
}

static  void method_3249( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNtrack>*)o)->pop_back)();
}

static  void method_3250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >)((((::std::vector<BNtrack>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >*)arg[0],
    *(const ::BNtrack*)arg[1]));
  else   (((::std::vector<BNtrack>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >*)arg[0],
    *(const ::BNtrack*)arg[1]);
}

static  void method_3251( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrack>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNtrack*)arg[2]);
}

static  void method_3252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >)((((::std::vector<BNtrack>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >*)arg[0]));
  else   (((::std::vector<BNtrack>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >*)arg[0]);
}

static  void method_3253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >)((((::std::vector<BNtrack>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >*)arg[1]));
  else   (((::std::vector<BNtrack>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNtrack*,std::vector<BNtrack> >*)arg[1]);
}

static  void method_3254( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrack>*)o)->swap)(*(::std::vector<BNtrack>*)arg[0]);
}

static  void method_3255( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNtrack>*)o)->clear)();
}

static void method_newdel_171( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrack> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrack> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrack> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrack> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrack> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNtrack,std::allocator<BNtrack> >")), ::Reflex::BaseOffset< ::std::vector<BNtrack>,::std::_Vector_base<BNtrack,std::allocator<BNtrack> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x16( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNtrack> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNtrack> >::Generate();
}

//------Dictionary for class vector<BNtrack,std::allocator<BNtrack> > -------------------------------
void __std__vector_BNtrack__db_datamem(Reflex::Class*);
void __std__vector_BNtrack__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNtrack__datamem_bld(&__std__vector_BNtrack__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNtrack__funcmem_bld(&__std__vector_BNtrack__db_funcmem);
void __std__vector_BNtrack__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNtrack>"), typeid(::std::vector<BNtrack>), sizeof(::std::vector<BNtrack>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1829, ::Reflex::BaseOffset< ::std::vector<BNtrack>, ::std::_Vector_base<BNtrack,std::allocator<BNtrack> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1488, Reflex::Literal("std::vector<BNtrack>::_Alloc_value_type"))
  .AddTypedef(type_1829, Reflex::Literal("std::vector<BNtrack>::_Base"))
  .AddTypedef(type_2544, Reflex::Literal("std::vector<BNtrack>::_Tp_alloc_type"))
  .AddTypedef(type_1488, Reflex::Literal("std::vector<BNtrack>::value_type"))
  .AddTypedef(type_3199, Reflex::Literal("std::vector<BNtrack>::pointer"))
  .AddTypedef(type_3201, Reflex::Literal("std::vector<BNtrack>::const_pointer"))
  .AddTypedef(type_3203, Reflex::Literal("std::vector<BNtrack>::reference"))
  .AddTypedef(type_3205, Reflex::Literal("std::vector<BNtrack>::const_reference"))
  .AddTypedef(type_3207, Reflex::Literal("std::vector<BNtrack>::iterator"))
  .AddTypedef(type_3209, Reflex::Literal("std::vector<BNtrack>::const_iterator"))
  .AddTypedef(type_2691, Reflex::Literal("std::vector<BNtrack>::const_reverse_iterator"))
  .AddTypedef(type_2692, Reflex::Literal("std::vector<BNtrack>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNtrack>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNtrack>::difference_type"))
  .AddTypedef(type_2544, Reflex::Literal("std::vector<BNtrack>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3216, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13731), Reflex::Literal("vector"), constructor_3217, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_3205, type_13731), Reflex::Literal("vector"), constructor_3218, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13732), Reflex::Literal("vector"), constructor_3219, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3220, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_171, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x16, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNtrack__funcmem_bld);
}

//------Delayed data member builder for class vector<BNtrack,std::allocator<BNtrack> > -------------------
void __std__vector_BNtrack__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNtrack,std::allocator<BNtrack> > -------------------
void __std__vector_BNtrack__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13733, type_13732), Reflex::Literal("operator="), operator_3221, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_3205), Reflex::Literal("assign"), method_3222, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3207), Reflex::Literal("begin"), method_3223, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3209), Reflex::Literal("begin"), method_3224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3207), Reflex::Literal("end"), method_3225, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3209), Reflex::Literal("end"), method_3226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_3231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_3232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_1488), Reflex::Literal("resize"), method_3233, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_3234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_3235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_3236, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3203, type_2521), Reflex::Literal("operator[]"), operator_3237, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3205, type_2521), Reflex::Literal("operator[]"), operator_3238, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3203, type_2521), Reflex::Literal("at"), method_3240, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3205, type_2521), Reflex::Literal("at"), method_3241, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3203), Reflex::Literal("front"), method_3242, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3205), Reflex::Literal("front"), method_3243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3203), Reflex::Literal("back"), method_3244, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3205), Reflex::Literal("back"), method_3245, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3199), Reflex::Literal("data"), method_3246, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3201), Reflex::Literal("data"), method_3247, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_3205), Reflex::Literal("push_back"), method_3248, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_3249, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3207, type_3207, type_3205), Reflex::Literal("insert"), method_3250, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_3207, type_2521, type_3205), Reflex::Literal("insert"), method_3251, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3207, type_3207), Reflex::Literal("erase"), method_3252, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3207, type_3207, type_3207), Reflex::Literal("erase"), method_3253, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_13733), Reflex::Literal("swap"), method_3254, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_3255, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BNtrigger -------------------------------
static void destructor_5012(void*, void * o, const std::vector<void*>&, void *) {
(((::BNtrigger*)o)->::BNtrigger::~BNtrigger)();
}
static  void operator_5013( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNtrigger*)o)->operator=)(*(const ::BNtrigger*)arg[0]);
  else   (((::BNtrigger*)o)->operator=)(*(const ::BNtrigger*)arg[0]);
}

static void constructor_5014( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNtrigger(*(const ::BNtrigger*)arg[0]);
  else ::new(mem) ::BNtrigger(*(const ::BNtrigger*)arg[0]);
}

static void constructor_5015( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNtrigger(*(int*)arg[0],
      *(::std::string*)arg[1]);
  else ::new(mem) ::BNtrigger(*(int*)arg[0],
      *(::std::string*)arg[1]);
}

static void constructor_5016( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNtrigger();
  else ::new(mem) ::BNtrigger();
}

static void method_newdel_796( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNtrigger >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNtrigger >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNtrigger >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNtrigger >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNtrigger >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNtrigger -------------------------------
void __BNtrigger_db_datamem(Reflex::Class*);
void __BNtrigger_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNtrigger_datamem_bld(&__BNtrigger_db_datamem);
Reflex::GenreflexMemberBuilder __BNtrigger_funcmem_bld(&__BNtrigger_db_funcmem);
void __BNtrigger_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNtrigger"), typeid(::BNtrigger), sizeof(::BNtrigger), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNtrigger"), destructor_5012, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3275, type_3277), Reflex::Literal("operator="), operator_5013, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3277), Reflex::Literal("BNtrigger"), constructor_5014, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_58, type_1866), Reflex::Literal("BNtrigger"), constructor_5015, 0, "c;n", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNtrigger"), constructor_5016, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_796, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNtrigger_datamem_bld);
}

//------Delayed data member builder for class BNtrigger -------------------
void __BNtrigger_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_58, Reflex::Literal("pass"), OffsetOf(__shadow__::__BNtrigger, pass), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("prescale"), OffsetOf(__shadow__::__BNtrigger, prescale), ::Reflex::PUBLIC)
  .AddDataMember(type_1866, Reflex::Literal("name"), OffsetOf(__shadow__::__BNtrigger, name), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNtrigger -------------------
void __BNtrigger_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BNtrigger,std::allocator<BNtrigger> > -------------------------------
static void constructor_3288( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrigger>();
  else ::new(mem) ::std::vector<BNtrigger>();
}

static void constructor_3289( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrigger>(*(const ::std::allocator<BNtrigger>*)arg[0]);
  else ::new(mem) ::std::vector<BNtrigger>(*(const ::std::allocator<BNtrigger>*)arg[0]);
}

static void constructor_3290( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrigger>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNtrigger>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrigger>(*(::std::size_t*)arg[0],
      *(const ::BNtrigger*)arg[1]);
  else ::new(mem) ::std::vector<BNtrigger>(*(::std::size_t*)arg[0],
      *(const ::BNtrigger*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrigger>(*(::std::size_t*)arg[0],
      *(const ::BNtrigger*)arg[1],
      *(const ::std::allocator<BNtrigger>*)arg[2]);
  else ::new(mem) ::std::vector<BNtrigger>(*(::std::size_t*)arg[0],
      *(const ::BNtrigger*)arg[1],
      *(const ::std::allocator<BNtrigger>*)arg[2]);
  }
}

static void constructor_3291( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtrigger>(*(const ::std::vector<BNtrigger>*)arg[0]);
  else ::new(mem) ::std::vector<BNtrigger>(*(const ::std::vector<BNtrigger>*)arg[0]);
}

static void destructor_3292(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNtrigger>*)o)->::std::vector<BNtrigger>::~vector)();
}
static  void operator_3293( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrigger>*)o)->operator=)(*(const ::std::vector<BNtrigger>*)arg[0]);
  else   (((::std::vector<BNtrigger>*)o)->operator=)(*(const ::std::vector<BNtrigger>*)arg[0]);
}

static  void method_3294( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrigger>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNtrigger*)arg[1]);
}

static  void method_3295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >)((((::std::vector<BNtrigger>*)o)->begin)());
  else   (((::std::vector<BNtrigger>*)o)->begin)();
}

static  void method_3296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNtrigger*,std::vector<BNtrigger> >)((((const ::std::vector<BNtrigger>*)o)->begin)());
  else   (((const ::std::vector<BNtrigger>*)o)->begin)();
}

static  void method_3297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >)((((::std::vector<BNtrigger>*)o)->end)());
  else   (((::std::vector<BNtrigger>*)o)->end)();
}

static  void method_3298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNtrigger*,std::vector<BNtrigger> >)((((const ::std::vector<BNtrigger>*)o)->end)());
  else   (((const ::std::vector<BNtrigger>*)o)->end)();
}

static  void method_3303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNtrigger>*)o)->size)());
  else   (((const ::std::vector<BNtrigger>*)o)->size)();
}

static  void method_3304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNtrigger>*)o)->max_size)());
  else   (((const ::std::vector<BNtrigger>*)o)->max_size)();
}

static  void method_3305( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNtrigger>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNtrigger>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNtrigger*)arg[1]);
  }
}

static  void method_3306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNtrigger>*)o)->capacity)());
  else   (((const ::std::vector<BNtrigger>*)o)->capacity)();
}

static  void method_3307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNtrigger>*)o)->empty)());
  else   (((const ::std::vector<BNtrigger>*)o)->empty)();
}

static  void method_3308( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrigger>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3309( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrigger>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNtrigger>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3310( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtrigger>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNtrigger>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3312( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrigger>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNtrigger>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3313( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtrigger>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNtrigger>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrigger>*)o)->front)();
  else   (((::std::vector<BNtrigger>*)o)->front)();
}

static  void method_3315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtrigger>*)o)->front)();
  else   (((const ::std::vector<BNtrigger>*)o)->front)();
}

static  void method_3316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtrigger>*)o)->back)();
  else   (((::std::vector<BNtrigger>*)o)->back)();
}

static  void method_3317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtrigger>*)o)->back)();
  else   (((const ::std::vector<BNtrigger>*)o)->back)();
}

static  void method_3318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNtrigger>*)o)->data)());
  else   (((::std::vector<BNtrigger>*)o)->data)();
}

static  void method_3319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNtrigger>*)o)->data)());
  else   (((const ::std::vector<BNtrigger>*)o)->data)();
}

static  void method_3320( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrigger>*)o)->push_back)(*(const ::BNtrigger*)arg[0]);
}

static  void method_3321( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNtrigger>*)o)->pop_back)();
}

static  void method_3322( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >)((((::std::vector<BNtrigger>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >*)arg[0],
    *(const ::BNtrigger*)arg[1]));
  else   (((::std::vector<BNtrigger>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >*)arg[0],
    *(const ::BNtrigger*)arg[1]);
}

static  void method_3323( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrigger>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNtrigger*)arg[2]);
}

static  void method_3324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >)((((::std::vector<BNtrigger>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >*)arg[0]));
  else   (((::std::vector<BNtrigger>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >*)arg[0]);
}

static  void method_3325( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >)((((::std::vector<BNtrigger>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >*)arg[1]));
  else   (((::std::vector<BNtrigger>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNtrigger*,std::vector<BNtrigger> >*)arg[1]);
}

static  void method_3326( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtrigger>*)o)->swap)(*(::std::vector<BNtrigger>*)arg[0]);
}

static  void method_3327( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNtrigger>*)o)->clear)();
}

static void method_newdel_186( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrigger> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrigger> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrigger> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrigger> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNtrigger> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNtrigger,std::allocator<BNtrigger> >")), ::Reflex::BaseOffset< ::std::vector<BNtrigger>,::std::_Vector_base<BNtrigger,std::allocator<BNtrigger> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNtrigger> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNtrigger> >::Generate();
}

//------Dictionary for class vector<BNtrigger,std::allocator<BNtrigger> > -------------------------------
void __std__vector_BNtrigger__db_datamem(Reflex::Class*);
void __std__vector_BNtrigger__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNtrigger__datamem_bld(&__std__vector_BNtrigger__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNtrigger__funcmem_bld(&__std__vector_BNtrigger__db_funcmem);
void __std__vector_BNtrigger__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNtrigger>"), typeid(::std::vector<BNtrigger>), sizeof(::std::vector<BNtrigger>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1828, ::Reflex::BaseOffset< ::std::vector<BNtrigger>, ::std::_Vector_base<BNtrigger,std::allocator<BNtrigger> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_796, Reflex::Literal("std::vector<BNtrigger>::_Alloc_value_type"))
  .AddTypedef(type_1828, Reflex::Literal("std::vector<BNtrigger>::_Base"))
  .AddTypedef(type_2543, Reflex::Literal("std::vector<BNtrigger>::_Tp_alloc_type"))
  .AddTypedef(type_796, Reflex::Literal("std::vector<BNtrigger>::value_type"))
  .AddTypedef(type_3271, Reflex::Literal("std::vector<BNtrigger>::pointer"))
  .AddTypedef(type_3273, Reflex::Literal("std::vector<BNtrigger>::const_pointer"))
  .AddTypedef(type_3275, Reflex::Literal("std::vector<BNtrigger>::reference"))
  .AddTypedef(type_3277, Reflex::Literal("std::vector<BNtrigger>::const_reference"))
  .AddTypedef(type_3279, Reflex::Literal("std::vector<BNtrigger>::iterator"))
  .AddTypedef(type_3281, Reflex::Literal("std::vector<BNtrigger>::const_iterator"))
  .AddTypedef(type_2689, Reflex::Literal("std::vector<BNtrigger>::const_reverse_iterator"))
  .AddTypedef(type_2690, Reflex::Literal("std::vector<BNtrigger>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNtrigger>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNtrigger>::difference_type"))
  .AddTypedef(type_2543, Reflex::Literal("std::vector<BNtrigger>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3288, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13735), Reflex::Literal("vector"), constructor_3289, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_3277, type_13735), Reflex::Literal("vector"), constructor_3290, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13736), Reflex::Literal("vector"), constructor_3291, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3292, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_186, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNtrigger__funcmem_bld);
}

//------Delayed data member builder for class vector<BNtrigger,std::allocator<BNtrigger> > -------------------
void __std__vector_BNtrigger__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNtrigger,std::allocator<BNtrigger> > -------------------
void __std__vector_BNtrigger__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13737, type_13736), Reflex::Literal("operator="), operator_3293, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_3277), Reflex::Literal("assign"), method_3294, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3279), Reflex::Literal("begin"), method_3295, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3281), Reflex::Literal("begin"), method_3296, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3279), Reflex::Literal("end"), method_3297, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3281), Reflex::Literal("end"), method_3298, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_3303, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_3304, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_796), Reflex::Literal("resize"), method_3305, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_3306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_3307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_3308, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3275, type_2521), Reflex::Literal("operator[]"), operator_3309, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3277, type_2521), Reflex::Literal("operator[]"), operator_3310, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3275, type_2521), Reflex::Literal("at"), method_3312, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3277, type_2521), Reflex::Literal("at"), method_3313, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3275), Reflex::Literal("front"), method_3314, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3277), Reflex::Literal("front"), method_3315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3275), Reflex::Literal("back"), method_3316, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3277), Reflex::Literal("back"), method_3317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3271), Reflex::Literal("data"), method_3318, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3273), Reflex::Literal("data"), method_3319, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_3277), Reflex::Literal("push_back"), method_3320, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_3321, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3279, type_3279, type_3277), Reflex::Literal("insert"), method_3322, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_3279, type_2521, type_3277), Reflex::Literal("insert"), method_3323, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3279, type_3279), Reflex::Literal("erase"), method_3324, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3279, type_3279, type_3279), Reflex::Literal("erase"), method_3325, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_13737), Reflex::Literal("swap"), method_3326, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_3327, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BNjet -------------------------------
static void destructor_4713(void*, void * o, const std::vector<void*>&, void *) {
(((::BNjet*)o)->::BNjet::~BNjet)();
}
static  void operator_4714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNjet*)o)->operator=)(*(const ::BNjet*)arg[0]);
  else   (((::BNjet*)o)->operator=)(*(const ::BNjet*)arg[0]);
}

static void constructor_4715( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNjet(*(const ::BNjet*)arg[0]);
  else ::new(mem) ::BNjet(*(const ::BNjet*)arg[0]);
}

static void constructor_4716( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNjet(*(double*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::BNjet(*(double*)arg[0],
      *(int*)arg[1]);
}

static void constructor_4717( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNjet();
  else ::new(mem) ::BNjet();
}

static void method_newdel_508( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNjet >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNjet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNjet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNjet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNjet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNjet -------------------------------
void __BNjet_db_datamem(Reflex::Class*);
void __BNjet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNjet_datamem_bld(&__BNjet_db_datamem);
Reflex::GenreflexMemberBuilder __BNjet_funcmem_bld(&__BNjet_db_funcmem);
void __BNjet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNjet"), typeid(::BNjet), sizeof(::BNjet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNjet"), destructor_4713, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3380, type_3382), Reflex::Literal("operator="), operator_4714, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3382), Reflex::Literal("BNjet"), constructor_4715, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698, type_58), Reflex::Literal("BNjet"), constructor_4716, 0, "v;c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNjet"), constructor_4717, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_508, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNjet_datamem_bld);
}

//------Delayed data member builder for class BNjet -------------------
void __BNjet_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("energy"), OffsetOf(__shadow__::__BNjet, energy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("et"), OffsetOf(__shadow__::__BNjet, et), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pt"), OffsetOf(__shadow__::__BNjet, pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("px"), OffsetOf(__shadow__::__BNjet, px), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("py"), OffsetOf(__shadow__::__BNjet, py), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pz"), OffsetOf(__shadow__::__BNjet, pz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("phi"), OffsetOf(__shadow__::__BNjet, phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eta"), OffsetOf(__shadow__::__BNjet, eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("theta"), OffsetOf(__shadow__::__BNjet, theta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("Upt"), OffsetOf(__shadow__::__BNjet, Upt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("Uenergy"), OffsetOf(__shadow__::__BNjet, Uenergy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("L2pt"), OffsetOf(__shadow__::__BNjet, L2pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("L2L3pt"), OffsetOf(__shadow__::__BNjet, L2L3pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("L2L3respt"), OffsetOf(__shadow__::__BNjet, L2L3respt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("respt"), OffsetOf(__shadow__::__BNjet, respt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("EMfrac"), OffsetOf(__shadow__::__BNjet, EMfrac), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("Hadfrac"), OffsetOf(__shadow__::__BNjet, Hadfrac), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("charge"), OffsetOf(__shadow__::__BNjet, charge), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("jetChargeRelativePtWeighted"), OffsetOf(__shadow__::__BNjet, jetChargeRelativePtWeighted), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mass"), OffsetOf(__shadow__::__BNjet, mass), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("area"), OffsetOf(__shadow__::__BNjet, area), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("fHPD"), OffsetOf(__shadow__::__BNjet, fHPD), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("approximatefHPD"), OffsetOf(__shadow__::__BNjet, approximatefHPD), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genPartonET"), OffsetOf(__shadow__::__BNjet, genPartonET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genPartonPT"), OffsetOf(__shadow__::__BNjet, genPartonPT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genPartonEta"), OffsetOf(__shadow__::__BNjet, genPartonEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genPartonPhi"), OffsetOf(__shadow__::__BNjet, genPartonPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genJetET"), OffsetOf(__shadow__::__BNjet, genJetET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genJetPT"), OffsetOf(__shadow__::__BNjet, genJetPT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genJetEta"), OffsetOf(__shadow__::__BNjet, genJetEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genJetPhi"), OffsetOf(__shadow__::__BNjet, genJetPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagTChighPur"), OffsetOf(__shadow__::__BNjet, btagTChighPur), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagTChighEff"), OffsetOf(__shadow__::__BNjet, btagTChighEff), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagJetProb"), OffsetOf(__shadow__::__BNjet, btagJetProb), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagJetBProb"), OffsetOf(__shadow__::__BNjet, btagJetBProb), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagSoftEle"), OffsetOf(__shadow__::__BNjet, btagSoftEle), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagSoftMuon"), OffsetOf(__shadow__::__BNjet, btagSoftMuon), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagSoftMuonNoIP"), OffsetOf(__shadow__::__BNjet, btagSoftMuonNoIP), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagSecVertex"), OffsetOf(__shadow__::__BNjet, btagSecVertex), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagSecVertexHighEff"), OffsetOf(__shadow__::__BNjet, btagSecVertexHighEff), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagSecVertexHighPur"), OffsetOf(__shadow__::__BNjet, btagSecVertexHighPur), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagCombinedSecVertex"), OffsetOf(__shadow__::__BNjet, btagCombinedSecVertex), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagCombinedSecVertexMVA"), OffsetOf(__shadow__::__BNjet, btagCombinedSecVertexMVA), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagSoftMuonByPt"), OffsetOf(__shadow__::__BNjet, btagSoftMuonByPt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagSoftMuonByIP3"), OffsetOf(__shadow__::__BNjet, btagSoftMuonByIP3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagSoftElectronByPt"), OffsetOf(__shadow__::__BNjet, btagSoftElectronByPt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("btagSoftElectronByIP3"), OffsetOf(__shadow__::__BNjet, btagSoftElectronByIP3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("n90Hits"), OffsetOf(__shadow__::__BNjet, n90Hits), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hitsInN90"), OffsetOf(__shadow__::__BNjet, hitsInN90), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("chargedHadronEnergyFraction"), OffsetOf(__shadow__::__BNjet, chargedHadronEnergyFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("neutralHadronEnergyFraction"), OffsetOf(__shadow__::__BNjet, neutralHadronEnergyFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("chargedEmEnergyFraction"), OffsetOf(__shadow__::__BNjet, chargedEmEnergyFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("neutralEmEnergyFraction"), OffsetOf(__shadow__::__BNjet, neutralEmEnergyFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("fLong"), OffsetOf(__shadow__::__BNjet, fLong), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("fShort"), OffsetOf(__shadow__::__BNjet, fShort), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("etaetaMoment"), OffsetOf(__shadow__::__BNjet, etaetaMoment), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("phiphiMoment"), OffsetOf(__shadow__::__BNjet, phiphiMoment), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("JESunc"), OffsetOf(__shadow__::__BNjet, JESunc), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("JECuncUp"), OffsetOf(__shadow__::__BNjet, JECuncUp), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("JECuncDown"), OffsetOf(__shadow__::__BNjet, JECuncDown), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("puJetMVA_full"), OffsetOf(__shadow__::__BNjet, puJetMVA_full), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("puJetMVA_simple"), OffsetOf(__shadow__::__BNjet, puJetMVA_simple), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("puJetMVA_cutbased"), OffsetOf(__shadow__::__BNjet, puJetMVA_cutbased), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("dZ"), OffsetOf(__shadow__::__BNjet, dZ), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("dR2Mean"), OffsetOf(__shadow__::__BNjet, dR2Mean), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("dRMean"), OffsetOf(__shadow__::__BNjet, dRMean), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("frac01"), OffsetOf(__shadow__::__BNjet, frac01), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("frac02"), OffsetOf(__shadow__::__BNjet, frac02), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("frac03"), OffsetOf(__shadow__::__BNjet, frac03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("frac04"), OffsetOf(__shadow__::__BNjet, frac04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("frac05"), OffsetOf(__shadow__::__BNjet, frac05), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("frac06"), OffsetOf(__shadow__::__BNjet, frac06), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("frac07"), OffsetOf(__shadow__::__BNjet, frac07), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("beta"), OffsetOf(__shadow__::__BNjet, beta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("betaStar"), OffsetOf(__shadow__::__BNjet, betaStar), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("betaClassic"), OffsetOf(__shadow__::__BNjet, betaClassic), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("betaStarClassic"), OffsetOf(__shadow__::__BNjet, betaStarClassic), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ptD"), OffsetOf(__shadow__::__BNjet, ptD), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("nvtx"), OffsetOf(__shadow__::__BNjet, nvtx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("d0"), OffsetOf(__shadow__::__BNjet, d0), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadCandPt"), OffsetOf(__shadow__::__BNjet, leadCandPt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadCandVx"), OffsetOf(__shadow__::__BNjet, leadCandVx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadCandVy"), OffsetOf(__shadow__::__BNjet, leadCandVy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadCandVz"), OffsetOf(__shadow__::__BNjet, leadCandVz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadCandDistFromPV"), OffsetOf(__shadow__::__BNjet, leadCandDistFromPV), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isCorrected"), OffsetOf(__shadow__::__BNjet, isCorrected), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("flavour"), OffsetOf(__shadow__::__BNjet, flavour), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("Nconst"), OffsetOf(__shadow__::__BNjet, Nconst), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("jetIDMinimal"), OffsetOf(__shadow__::__BNjet, jetIDMinimal), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("jetIDLooseAOD"), OffsetOf(__shadow__::__BNjet, jetIDLooseAOD), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("jetIDLoose"), OffsetOf(__shadow__::__BNjet, jetIDLoose), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("jetIDTight"), OffsetOf(__shadow__::__BNjet, jetIDTight), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genPartonId"), OffsetOf(__shadow__::__BNjet, genPartonId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genPartonMotherId"), OffsetOf(__shadow__::__BNjet, genPartonMotherId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genPartonMother0Id"), OffsetOf(__shadow__::__BNjet, genPartonMother0Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genPartonMother1Id"), OffsetOf(__shadow__::__BNjet, genPartonMother1Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genPartonGrandMotherId"), OffsetOf(__shadow__::__BNjet, genPartonGrandMotherId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genPartonGrandMother00Id"), OffsetOf(__shadow__::__BNjet, genPartonGrandMother00Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genPartonGrandMother01Id"), OffsetOf(__shadow__::__BNjet, genPartonGrandMother01Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genPartonGrandMother10Id"), OffsetOf(__shadow__::__BNjet, genPartonGrandMother10Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genPartonGrandMother11Id"), OffsetOf(__shadow__::__BNjet, genPartonGrandMother11Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("chargedMultiplicity"), OffsetOf(__shadow__::__BNjet, chargedMultiplicity), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("neutralMultiplicity"), OffsetOf(__shadow__::__BNjet, neutralMultiplicity), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("nconstituents"), OffsetOf(__shadow__::__BNjet, nconstituents), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("nHit"), OffsetOf(__shadow__::__BNjet, nHit), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("puJetId_full"), OffsetOf(__shadow__::__BNjet, puJetId_full), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("puJetId_simple"), OffsetOf(__shadow__::__BNjet, puJetId_simple), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("puJetId_cutbased"), OffsetOf(__shadow__::__BNjet, puJetId_cutbased), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("puJetId_tight_full"), OffsetOf(__shadow__::__BNjet, puJetId_tight_full), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("puJetId_tight_simple"), OffsetOf(__shadow__::__BNjet, puJetId_tight_simple), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("puJetId_tight_cutbased"), OffsetOf(__shadow__::__BNjet, puJetId_tight_cutbased), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("puJetId_medium_full"), OffsetOf(__shadow__::__BNjet, puJetId_medium_full), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("puJetId_medium_simple"), OffsetOf(__shadow__::__BNjet, puJetId_medium_simple), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("puJetId_medium_cutbased"), OffsetOf(__shadow__::__BNjet, puJetId_medium_cutbased), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("puJetId_loose_full"), OffsetOf(__shadow__::__BNjet, puJetId_loose_full), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("puJetId_loose_simple"), OffsetOf(__shadow__::__BNjet, puJetId_loose_simple), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("puJetId_loose_cutbased"), OffsetOf(__shadow__::__BNjet, puJetId_loose_cutbased), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("QGMLP"), OffsetOf(__shadow__::__BNjet, QGMLP), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("QGLD"), OffsetOf(__shadow__::__BNjet, QGLD), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNjet -------------------
void __BNjet_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BNjet,std::allocator<BNjet> > -------------------------------
static void constructor_3393( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNjet>();
  else ::new(mem) ::std::vector<BNjet>();
}

static void constructor_3394( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNjet>(*(const ::std::allocator<BNjet>*)arg[0]);
  else ::new(mem) ::std::vector<BNjet>(*(const ::std::allocator<BNjet>*)arg[0]);
}

static void constructor_3395( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNjet>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNjet>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNjet>(*(::std::size_t*)arg[0],
      *(const ::BNjet*)arg[1]);
  else ::new(mem) ::std::vector<BNjet>(*(::std::size_t*)arg[0],
      *(const ::BNjet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNjet>(*(::std::size_t*)arg[0],
      *(const ::BNjet*)arg[1],
      *(const ::std::allocator<BNjet>*)arg[2]);
  else ::new(mem) ::std::vector<BNjet>(*(::std::size_t*)arg[0],
      *(const ::BNjet*)arg[1],
      *(const ::std::allocator<BNjet>*)arg[2]);
  }
}

static void constructor_3396( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNjet>(*(const ::std::vector<BNjet>*)arg[0]);
  else ::new(mem) ::std::vector<BNjet>(*(const ::std::vector<BNjet>*)arg[0]);
}

static void destructor_3397(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNjet>*)o)->::std::vector<BNjet>::~vector)();
}
static  void operator_3398( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNjet>*)o)->operator=)(*(const ::std::vector<BNjet>*)arg[0]);
  else   (((::std::vector<BNjet>*)o)->operator=)(*(const ::std::vector<BNjet>*)arg[0]);
}

static  void method_3399( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNjet>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNjet*)arg[1]);
}

static  void method_3400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >)((((::std::vector<BNjet>*)o)->begin)());
  else   (((::std::vector<BNjet>*)o)->begin)();
}

static  void method_3401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNjet*,std::vector<BNjet> >)((((const ::std::vector<BNjet>*)o)->begin)());
  else   (((const ::std::vector<BNjet>*)o)->begin)();
}

static  void method_3402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >)((((::std::vector<BNjet>*)o)->end)());
  else   (((::std::vector<BNjet>*)o)->end)();
}

static  void method_3403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNjet*,std::vector<BNjet> >)((((const ::std::vector<BNjet>*)o)->end)());
  else   (((const ::std::vector<BNjet>*)o)->end)();
}

static  void method_3408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNjet>*)o)->size)());
  else   (((const ::std::vector<BNjet>*)o)->size)();
}

static  void method_3409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNjet>*)o)->max_size)());
  else   (((const ::std::vector<BNjet>*)o)->max_size)();
}

static  void method_3410( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNjet>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNjet>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNjet*)arg[1]);
  }
}

static  void method_3411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNjet>*)o)->capacity)());
  else   (((const ::std::vector<BNjet>*)o)->capacity)();
}

static  void method_3412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNjet>*)o)->empty)());
  else   (((const ::std::vector<BNjet>*)o)->empty)();
}

static  void method_3413( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNjet>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNjet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNjet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNjet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNjet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3417( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNjet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNjet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3418( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNjet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNjet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNjet>*)o)->front)();
  else   (((::std::vector<BNjet>*)o)->front)();
}

static  void method_3420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNjet>*)o)->front)();
  else   (((const ::std::vector<BNjet>*)o)->front)();
}

static  void method_3421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNjet>*)o)->back)();
  else   (((::std::vector<BNjet>*)o)->back)();
}

static  void method_3422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNjet>*)o)->back)();
  else   (((const ::std::vector<BNjet>*)o)->back)();
}

static  void method_3423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNjet>*)o)->data)());
  else   (((::std::vector<BNjet>*)o)->data)();
}

static  void method_3424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNjet>*)o)->data)());
  else   (((const ::std::vector<BNjet>*)o)->data)();
}

static  void method_3425( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNjet>*)o)->push_back)(*(const ::BNjet*)arg[0]);
}

static  void method_3426( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNjet>*)o)->pop_back)();
}

static  void method_3427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >)((((::std::vector<BNjet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >*)arg[0],
    *(const ::BNjet*)arg[1]));
  else   (((::std::vector<BNjet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >*)arg[0],
    *(const ::BNjet*)arg[1]);
}

static  void method_3428( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNjet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNjet*)arg[2]);
}

static  void method_3429( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >)((((::std::vector<BNjet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >*)arg[0]));
  else   (((::std::vector<BNjet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >*)arg[0]);
}

static  void method_3430( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >)((((::std::vector<BNjet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >*)arg[1]));
  else   (((::std::vector<BNjet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNjet*,std::vector<BNjet> >*)arg[1]);
}

static  void method_3431( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNjet>*)o)->swap)(*(::std::vector<BNjet>*)arg[0]);
}

static  void method_3432( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNjet>*)o)->clear)();
}

static void method_newdel_236( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNjet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNjet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNjet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNjet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNjet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNjet,std::allocator<BNjet> >")), ::Reflex::BaseOffset< ::std::vector<BNjet>,::std::_Vector_base<BNjet,std::allocator<BNjet> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNjet> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNjet> >::Generate();
}

//------Dictionary for class vector<BNjet,std::allocator<BNjet> > -------------------------------
void __std__vector_BNjet__db_datamem(Reflex::Class*);
void __std__vector_BNjet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNjet__datamem_bld(&__std__vector_BNjet__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNjet__funcmem_bld(&__std__vector_BNjet__db_funcmem);
void __std__vector_BNjet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNjet>"), typeid(::std::vector<BNjet>), sizeof(::std::vector<BNjet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1837, ::Reflex::BaseOffset< ::std::vector<BNjet>, ::std::_Vector_base<BNjet,std::allocator<BNjet> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_508, Reflex::Literal("std::vector<BNjet>::_Alloc_value_type"))
  .AddTypedef(type_1837, Reflex::Literal("std::vector<BNjet>::_Base"))
  .AddTypedef(type_2552, Reflex::Literal("std::vector<BNjet>::_Tp_alloc_type"))
  .AddTypedef(type_508, Reflex::Literal("std::vector<BNjet>::value_type"))
  .AddTypedef(type_3376, Reflex::Literal("std::vector<BNjet>::pointer"))
  .AddTypedef(type_3378, Reflex::Literal("std::vector<BNjet>::const_pointer"))
  .AddTypedef(type_3380, Reflex::Literal("std::vector<BNjet>::reference"))
  .AddTypedef(type_3382, Reflex::Literal("std::vector<BNjet>::const_reference"))
  .AddTypedef(type_3384, Reflex::Literal("std::vector<BNjet>::iterator"))
  .AddTypedef(type_3386, Reflex::Literal("std::vector<BNjet>::const_iterator"))
  .AddTypedef(type_2707, Reflex::Literal("std::vector<BNjet>::const_reverse_iterator"))
  .AddTypedef(type_2708, Reflex::Literal("std::vector<BNjet>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNjet>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNjet>::difference_type"))
  .AddTypedef(type_2552, Reflex::Literal("std::vector<BNjet>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3393, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13743), Reflex::Literal("vector"), constructor_3394, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_3382, type_13743), Reflex::Literal("vector"), constructor_3395, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13744), Reflex::Literal("vector"), constructor_3396, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3397, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_236, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNjet__funcmem_bld);
}

//------Delayed data member builder for class vector<BNjet,std::allocator<BNjet> > -------------------
void __std__vector_BNjet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNjet,std::allocator<BNjet> > -------------------
void __std__vector_BNjet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13745, type_13744), Reflex::Literal("operator="), operator_3398, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_3382), Reflex::Literal("assign"), method_3399, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3384), Reflex::Literal("begin"), method_3400, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3386), Reflex::Literal("begin"), method_3401, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3384), Reflex::Literal("end"), method_3402, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3386), Reflex::Literal("end"), method_3403, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_3408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_3409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_508), Reflex::Literal("resize"), method_3410, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_3411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_3412, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_3413, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3380, type_2521), Reflex::Literal("operator[]"), operator_3414, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3382, type_2521), Reflex::Literal("operator[]"), operator_3415, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3380, type_2521), Reflex::Literal("at"), method_3417, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3382, type_2521), Reflex::Literal("at"), method_3418, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3380), Reflex::Literal("front"), method_3419, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3382), Reflex::Literal("front"), method_3420, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3380), Reflex::Literal("back"), method_3421, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3382), Reflex::Literal("back"), method_3422, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3376), Reflex::Literal("data"), method_3423, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3378), Reflex::Literal("data"), method_3424, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_3382), Reflex::Literal("push_back"), method_3425, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_3426, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3384, type_3384, type_3382), Reflex::Literal("insert"), method_3427, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_3384, type_2521, type_3382), Reflex::Literal("insert"), method_3428, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3384, type_3384), Reflex::Literal("erase"), method_3429, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3384, type_3384, type_3384), Reflex::Literal("erase"), method_3430, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_13745), Reflex::Literal("swap"), method_3431, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_3432, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BNsupercluster -------------------------------
static void destructor_3956(void*, void * o, const std::vector<void*>&, void *) {
(((::BNsupercluster*)o)->::BNsupercluster::~BNsupercluster)();
}
static  void operator_3957( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNsupercluster*)o)->operator=)(*(const ::BNsupercluster*)arg[0]);
  else   (((::BNsupercluster*)o)->operator=)(*(const ::BNsupercluster*)arg[0]);
}

static void constructor_3958( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNsupercluster(*(const ::BNsupercluster*)arg[0]);
  else ::new(mem) ::BNsupercluster(*(const ::BNsupercluster*)arg[0]);
}

static void constructor_3959( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNsupercluster(*(double*)arg[0]);
  else ::new(mem) ::BNsupercluster(*(double*)arg[0]);
}

static void constructor_3960( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNsupercluster();
  else ::new(mem) ::BNsupercluster();
}

static void method_newdel_281( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNsupercluster >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNsupercluster >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNsupercluster >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNsupercluster >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNsupercluster >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNsupercluster -------------------------------
void __BNsupercluster_db_datamem(Reflex::Class*);
void __BNsupercluster_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNsupercluster_datamem_bld(&__BNsupercluster_db_datamem);
Reflex::GenreflexMemberBuilder __BNsupercluster_funcmem_bld(&__BNsupercluster_db_funcmem);
void __BNsupercluster_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNsupercluster"), typeid(::BNsupercluster), sizeof(::BNsupercluster), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNsupercluster"), destructor_3956, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4847, type_4849), Reflex::Literal("operator="), operator_3957, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4849), Reflex::Literal("BNsupercluster"), constructor_3958, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698), Reflex::Literal("BNsupercluster"), constructor_3959, 0, "v", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNsupercluster"), constructor_3960, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_281, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNsupercluster_datamem_bld);
}

//------Delayed data member builder for class BNsupercluster -------------------
void __BNsupercluster_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("energy"), OffsetOf(__shadow__::__BNsupercluster, energy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("et"), OffsetOf(__shadow__::__BNsupercluster, et), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ex"), OffsetOf(__shadow__::__BNsupercluster, ex), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ey"), OffsetOf(__shadow__::__BNsupercluster, ey), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ez"), OffsetOf(__shadow__::__BNsupercluster, ez), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("phi"), OffsetOf(__shadow__::__BNsupercluster, phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eta"), OffsetOf(__shadow__::__BNsupercluster, eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("theta"), OffsetOf(__shadow__::__BNsupercluster, theta), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNsupercluster -------------------
void __BNsupercluster_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class SampleProd -------------------------------
static void destructor_5043(void*, void * o, const std::vector<void*>&, void *) {
(((::SampleProd*)o)->::SampleProd::~SampleProd)();
}
static  void operator_5044( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SampleProd*)o)->operator=)(*(const ::SampleProd*)arg[0]);
  else   (((::SampleProd*)o)->operator=)(*(const ::SampleProd*)arg[0]);
}

static void constructor_5045( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SampleProd(*(const ::SampleProd*)arg[0]);
  else ::new(mem) ::SampleProd(*(const ::SampleProd*)arg[0]);
}

static void constructor_5046( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SampleProd(*(float*)arg[0]);
  else ::new(mem) ::SampleProd(*(float*)arg[0]);
}

static void constructor_5047( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SampleProd();
  else ::new(mem) ::SampleProd();
}

static void method_newdel_843( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SampleProd >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SampleProd >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SampleProd >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SampleProd >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SampleProd >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SampleProd -------------------------------
void __SampleProd_db_datamem(Reflex::Class*);
void __SampleProd_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SampleProd_datamem_bld(&__SampleProd_db_datamem);
Reflex::GenreflexMemberBuilder __SampleProd_funcmem_bld(&__SampleProd_db_funcmem);
void __SampleProd_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SampleProd"), typeid(::SampleProd), sizeof(::SampleProd), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SampleProd"), destructor_5043, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3971, type_3973), Reflex::Literal("operator="), operator_5044, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3973), Reflex::Literal("SampleProd"), constructor_5045, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_685), Reflex::Literal("SampleProd"), constructor_5046, 0, "v", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SampleProd"), constructor_5047, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_843, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SampleProd_datamem_bld);
}

//------Delayed data member builder for class SampleProd -------------------
void __SampleProd_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_685, Reflex::Literal("et_"), OffsetOf(__shadow__::__SampleProd, et_), ::Reflex::PUBLIC)
  .AddDataMember(type_685, Reflex::Literal("pt_"), OffsetOf(__shadow__::__SampleProd, pt_), ::Reflex::PUBLIC)
  .AddDataMember(type_685, Reflex::Literal("px_"), OffsetOf(__shadow__::__SampleProd, px_), ::Reflex::PUBLIC)
  .AddDataMember(type_685, Reflex::Literal("py_"), OffsetOf(__shadow__::__SampleProd, py_), ::Reflex::PUBLIC)
  .AddDataMember(type_685, Reflex::Literal("pz_"), OffsetOf(__shadow__::__SampleProd, pz_), ::Reflex::PUBLIC)
  .AddDataMember(type_685, Reflex::Literal("phi_"), OffsetOf(__shadow__::__SampleProd, phi_), ::Reflex::PUBLIC)
  .AddDataMember(type_685, Reflex::Literal("eta_"), OffsetOf(__shadow__::__SampleProd, eta_), ::Reflex::PUBLIC)
  .AddDataMember(type_685, Reflex::Literal("theta_"), OffsetOf(__shadow__::__SampleProd, theta_), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class SampleProd -------------------
void __SampleProd_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<SampleProd,std::allocator<SampleProd> > -------------------------------
static void constructor_3984( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SampleProd>();
  else ::new(mem) ::std::vector<SampleProd>();
}

static void constructor_3985( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SampleProd>(*(const ::std::allocator<SampleProd>*)arg[0]);
  else ::new(mem) ::std::vector<SampleProd>(*(const ::std::allocator<SampleProd>*)arg[0]);
}

static void constructor_3986( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SampleProd>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SampleProd>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SampleProd>(*(::std::size_t*)arg[0],
      *(const ::SampleProd*)arg[1]);
  else ::new(mem) ::std::vector<SampleProd>(*(::std::size_t*)arg[0],
      *(const ::SampleProd*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SampleProd>(*(::std::size_t*)arg[0],
      *(const ::SampleProd*)arg[1],
      *(const ::std::allocator<SampleProd>*)arg[2]);
  else ::new(mem) ::std::vector<SampleProd>(*(::std::size_t*)arg[0],
      *(const ::SampleProd*)arg[1],
      *(const ::std::allocator<SampleProd>*)arg[2]);
  }
}

static void constructor_3987( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SampleProd>(*(const ::std::vector<SampleProd>*)arg[0]);
  else ::new(mem) ::std::vector<SampleProd>(*(const ::std::vector<SampleProd>*)arg[0]);
}

static void destructor_3988(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SampleProd>*)o)->::std::vector<SampleProd>::~vector)();
}
static  void operator_3989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SampleProd>*)o)->operator=)(*(const ::std::vector<SampleProd>*)arg[0]);
  else   (((::std::vector<SampleProd>*)o)->operator=)(*(const ::std::vector<SampleProd>*)arg[0]);
}

static  void method_3990( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SampleProd>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SampleProd*)arg[1]);
}

static  void method_3991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >)((((::std::vector<SampleProd>*)o)->begin)());
  else   (((::std::vector<SampleProd>*)o)->begin)();
}

static  void method_3992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SampleProd*,std::vector<SampleProd> >)((((const ::std::vector<SampleProd>*)o)->begin)());
  else   (((const ::std::vector<SampleProd>*)o)->begin)();
}

static  void method_3993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >)((((::std::vector<SampleProd>*)o)->end)());
  else   (((::std::vector<SampleProd>*)o)->end)();
}

static  void method_3994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SampleProd*,std::vector<SampleProd> >)((((const ::std::vector<SampleProd>*)o)->end)());
  else   (((const ::std::vector<SampleProd>*)o)->end)();
}

static  void method_3999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SampleProd>*)o)->size)());
  else   (((const ::std::vector<SampleProd>*)o)->size)();
}

static  void method_4000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SampleProd>*)o)->max_size)());
  else   (((const ::std::vector<SampleProd>*)o)->max_size)();
}

static  void method_4001( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SampleProd>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SampleProd>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SampleProd*)arg[1]);
  }
}

static  void method_4002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SampleProd>*)o)->capacity)());
  else   (((const ::std::vector<SampleProd>*)o)->capacity)();
}

static  void method_4003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SampleProd>*)o)->empty)());
  else   (((const ::std::vector<SampleProd>*)o)->empty)();
}

static  void method_4004( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SampleProd>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4005( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SampleProd>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SampleProd>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4006( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SampleProd>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SampleProd>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SampleProd>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SampleProd>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SampleProd>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SampleProd>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SampleProd>*)o)->front)();
  else   (((::std::vector<SampleProd>*)o)->front)();
}

static  void method_4011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SampleProd>*)o)->front)();
  else   (((const ::std::vector<SampleProd>*)o)->front)();
}

static  void method_4012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SampleProd>*)o)->back)();
  else   (((::std::vector<SampleProd>*)o)->back)();
}

static  void method_4013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SampleProd>*)o)->back)();
  else   (((const ::std::vector<SampleProd>*)o)->back)();
}

static  void method_4014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SampleProd>*)o)->data)());
  else   (((::std::vector<SampleProd>*)o)->data)();
}

static  void method_4015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SampleProd>*)o)->data)());
  else   (((const ::std::vector<SampleProd>*)o)->data)();
}

static  void method_4016( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SampleProd>*)o)->push_back)(*(const ::SampleProd*)arg[0]);
}

static  void method_4017( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SampleProd>*)o)->pop_back)();
}

static  void method_4018( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >)((((::std::vector<SampleProd>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >*)arg[0],
    *(const ::SampleProd*)arg[1]));
  else   (((::std::vector<SampleProd>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >*)arg[0],
    *(const ::SampleProd*)arg[1]);
}

static  void method_4019( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SampleProd>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SampleProd*)arg[2]);
}

static  void method_4020( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >)((((::std::vector<SampleProd>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >*)arg[0]));
  else   (((::std::vector<SampleProd>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >*)arg[0]);
}

static  void method_4021( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >)((((::std::vector<SampleProd>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >*)arg[1]));
  else   (((::std::vector<SampleProd>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SampleProd*,std::vector<SampleProd> >*)arg[1]);
}

static  void method_4022( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SampleProd>*)o)->swap)(*(::std::vector<SampleProd>*)arg[0]);
}

static  void method_4023( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SampleProd>*)o)->clear)();
}

static void method_newdel_288( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SampleProd> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SampleProd> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SampleProd> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SampleProd> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SampleProd> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SampleProd,std::allocator<SampleProd> >")), ::Reflex::BaseOffset< ::std::vector<SampleProd>,::std::_Vector_base<SampleProd,std::allocator<SampleProd> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x29( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SampleProd> >::Generate();
  else ::Reflex::Proxy< ::std::vector<SampleProd> >::Generate();
}

//------Dictionary for class vector<SampleProd,std::allocator<SampleProd> > -------------------------------
void __std__vector_SampleProd__db_datamem(Reflex::Class*);
void __std__vector_SampleProd__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SampleProd__datamem_bld(&__std__vector_SampleProd__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SampleProd__funcmem_bld(&__std__vector_SampleProd__db_funcmem);
void __std__vector_SampleProd__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SampleProd>"), typeid(::std::vector<SampleProd>), sizeof(::std::vector<SampleProd>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1841, ::Reflex::BaseOffset< ::std::vector<SampleProd>, ::std::_Vector_base<SampleProd,std::allocator<SampleProd> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_843, Reflex::Literal("std::vector<SampleProd>::_Alloc_value_type"))
  .AddTypedef(type_1841, Reflex::Literal("std::vector<SampleProd>::_Base"))
  .AddTypedef(type_2556, Reflex::Literal("std::vector<SampleProd>::_Tp_alloc_type"))
  .AddTypedef(type_843, Reflex::Literal("std::vector<SampleProd>::value_type"))
  .AddTypedef(type_3967, Reflex::Literal("std::vector<SampleProd>::pointer"))
  .AddTypedef(type_3969, Reflex::Literal("std::vector<SampleProd>::const_pointer"))
  .AddTypedef(type_3971, Reflex::Literal("std::vector<SampleProd>::reference"))
  .AddTypedef(type_3973, Reflex::Literal("std::vector<SampleProd>::const_reference"))
  .AddTypedef(type_3975, Reflex::Literal("std::vector<SampleProd>::iterator"))
  .AddTypedef(type_3977, Reflex::Literal("std::vector<SampleProd>::const_iterator"))
  .AddTypedef(type_2715, Reflex::Literal("std::vector<SampleProd>::const_reverse_iterator"))
  .AddTypedef(type_2716, Reflex::Literal("std::vector<SampleProd>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<SampleProd>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<SampleProd>::difference_type"))
  .AddTypedef(type_2556, Reflex::Literal("std::vector<SampleProd>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3984, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16404), Reflex::Literal("vector"), constructor_3985, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_3973, type_16404), Reflex::Literal("vector"), constructor_3986, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16405), Reflex::Literal("vector"), constructor_3987, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3988, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_288, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x29, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SampleProd__funcmem_bld);
}

//------Delayed data member builder for class vector<SampleProd,std::allocator<SampleProd> > -------------------
void __std__vector_SampleProd__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SampleProd,std::allocator<SampleProd> > -------------------
void __std__vector_SampleProd__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16406, type_16405), Reflex::Literal("operator="), operator_3989, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_3973), Reflex::Literal("assign"), method_3990, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3975), Reflex::Literal("begin"), method_3991, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3977), Reflex::Literal("begin"), method_3992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3975), Reflex::Literal("end"), method_3993, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3977), Reflex::Literal("end"), method_3994, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_3999, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_4000, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_843), Reflex::Literal("resize"), method_4001, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_4002, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_4003, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_4004, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3971, type_2521), Reflex::Literal("operator[]"), operator_4005, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3973, type_2521), Reflex::Literal("operator[]"), operator_4006, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3971, type_2521), Reflex::Literal("at"), method_4008, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3973, type_2521), Reflex::Literal("at"), method_4009, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3971), Reflex::Literal("front"), method_4010, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3973), Reflex::Literal("front"), method_4011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3971), Reflex::Literal("back"), method_4012, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3973), Reflex::Literal("back"), method_4013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3967), Reflex::Literal("data"), method_4014, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3969), Reflex::Literal("data"), method_4015, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_3973), Reflex::Literal("push_back"), method_4016, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_4017, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3975, type_3975, type_3973), Reflex::Literal("insert"), method_4018, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_3975, type_2521, type_3973), Reflex::Literal("insert"), method_4019, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3975, type_3975), Reflex::Literal("erase"), method_4020, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3975, type_3975, type_3975), Reflex::Literal("erase"), method_4021, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_16406), Reflex::Literal("swap"), method_4022, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_4023, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BNmuon -------------------------------
static void destructor_4282(void*, void * o, const std::vector<void*>&, void *) {
(((::BNmuon*)o)->::BNmuon::~BNmuon)();
}
static  void operator_4283( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNmuon*)o)->operator=)(*(const ::BNmuon*)arg[0]);
  else   (((::BNmuon*)o)->operator=)(*(const ::BNmuon*)arg[0]);
}

static void constructor_4284( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNmuon(*(const ::BNmuon*)arg[0]);
  else ::new(mem) ::BNmuon(*(const ::BNmuon*)arg[0]);
}

static void constructor_4285( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNmuon(*(double*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::BNmuon(*(double*)arg[0],
      *(int*)arg[1]);
}

static void constructor_4286( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNmuon();
  else ::new(mem) ::BNmuon();
}

static void method_newdel_336( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNmuon >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNmuon >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNmuon >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNmuon >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNmuon >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x31( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("BNlepton")), ::Reflex::BaseOffset< ::BNmuon,::BNlepton >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class BNmuon -------------------------------
void __BNmuon_db_datamem(Reflex::Class*);
void __BNmuon_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNmuon_datamem_bld(&__BNmuon_db_datamem);
Reflex::GenreflexMemberBuilder __BNmuon_funcmem_bld(&__BNmuon_db_funcmem);
void __BNmuon_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNmuon"), typeid(::BNmuon), sizeof(::BNmuon), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddBase(type_1092, ::Reflex::BaseOffset< ::BNmuon, ::BNlepton >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNmuon"), destructor_4282, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4311, type_4313), Reflex::Literal("operator="), operator_4283, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4313), Reflex::Literal("BNmuon"), constructor_4284, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698, type_58), Reflex::Literal("BNmuon"), constructor_4285, 0, "v;c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNmuon"), constructor_4286, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_336, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x31, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNmuon_datamem_bld);
}

//------Delayed data member builder for class BNmuon -------------------
void __BNmuon_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("trackVetoIsoDR03"), OffsetOf(__shadow__::__BNmuon, trackVetoIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ecalVetoIsoDR03"), OffsetOf(__shadow__::__BNmuon, ecalVetoIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalVetoIsoDR03"), OffsetOf(__shadow__::__BNmuon, hcalVetoIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloVetoIsoDR03"), OffsetOf(__shadow__::__BNmuon, caloVetoIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("trackIsoDR05"), OffsetOf(__shadow__::__BNmuon, trackIsoDR05), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ecalIsoDR05"), OffsetOf(__shadow__::__BNmuon, ecalIsoDR05), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalIsoDR05"), OffsetOf(__shadow__::__BNmuon, hcalIsoDR05), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloIsoDR05"), OffsetOf(__shadow__::__BNmuon, caloIsoDR05), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("trackVetoIsoDR05"), OffsetOf(__shadow__::__BNmuon, trackVetoIsoDR05), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ecalVetoIsoDR05"), OffsetOf(__shadow__::__BNmuon, ecalVetoIsoDR05), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalVetoIsoDR05"), OffsetOf(__shadow__::__BNmuon, hcalVetoIsoDR05), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloVetoIsoDR05"), OffsetOf(__shadow__::__BNmuon, caloVetoIsoDR05), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalE"), OffsetOf(__shadow__::__BNmuon, hcalE), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ecalE"), OffsetOf(__shadow__::__BNmuon, ecalE), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("samNormChi2"), OffsetOf(__shadow__::__BNmuon, samNormChi2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("samPT"), OffsetOf(__shadow__::__BNmuon, samPT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("samEta"), OffsetOf(__shadow__::__BNmuon, samEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("samPhi"), OffsetOf(__shadow__::__BNmuon, samPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("samDZ"), OffsetOf(__shadow__::__BNmuon, samDZ), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("samDZerr"), OffsetOf(__shadow__::__BNmuon, samDZerr), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("samD0"), OffsetOf(__shadow__::__BNmuon, samD0), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("samD0bs"), OffsetOf(__shadow__::__BNmuon, samD0bs), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("samD0err"), OffsetOf(__shadow__::__BNmuon, samD0err), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("comNormChi2"), OffsetOf(__shadow__::__BNmuon, comNormChi2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("comPT"), OffsetOf(__shadow__::__BNmuon, comPT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("comEta"), OffsetOf(__shadow__::__BNmuon, comEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("comPhi"), OffsetOf(__shadow__::__BNmuon, comPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("comDZ"), OffsetOf(__shadow__::__BNmuon, comDZ), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("comDZerr"), OffsetOf(__shadow__::__BNmuon, comDZerr), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("comD0"), OffsetOf(__shadow__::__BNmuon, comD0), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("comD0bs"), OffsetOf(__shadow__::__BNmuon, comD0bs), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("comD0err"), OffsetOf(__shadow__::__BNmuon, comD0err), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("isolationR03emVetoEt"), OffsetOf(__shadow__::__BNmuon, isolationR03emVetoEt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("isolationR03hadVetoEt"), OffsetOf(__shadow__::__BNmuon, isolationR03hadVetoEt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("normalizedChi2"), OffsetOf(__shadow__::__BNmuon, normalizedChi2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("dVzPVz"), OffsetOf(__shadow__::__BNmuon, dVzPVz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("dB"), OffsetOf(__shadow__::__BNmuon, dB), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ptErr"), OffsetOf(__shadow__::__BNmuon, ptErr), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("innerTrackNormChi2"), OffsetOf(__shadow__::__BNmuon, innerTrackNormChi2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfIsoR03SumChargedHadronPt"), OffsetOf(__shadow__::__BNmuon, pfIsoR03SumChargedHadronPt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfIsoR03SumNeutralHadronEt"), OffsetOf(__shadow__::__BNmuon, pfIsoR03SumNeutralHadronEt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfIsoR03SumPhotonEt"), OffsetOf(__shadow__::__BNmuon, pfIsoR03SumPhotonEt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfIsoR03SumPUPt"), OffsetOf(__shadow__::__BNmuon, pfIsoR03SumPUPt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfIsoR04SumChargedHadronPt"), OffsetOf(__shadow__::__BNmuon, pfIsoR04SumChargedHadronPt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfIsoR04SumNeutralHadronEt"), OffsetOf(__shadow__::__BNmuon, pfIsoR04SumNeutralHadronEt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfIsoR04SumPhotonEt"), OffsetOf(__shadow__::__BNmuon, pfIsoR04SumPhotonEt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfIsoR04SumPUPt"), OffsetOf(__shadow__::__BNmuon, pfIsoR04SumPUPt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("timeAtIpInOut"), OffsetOf(__shadow__::__BNmuon, timeAtIpInOut), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("timeAtIpInOutErr"), OffsetOf(__shadow__::__BNmuon, timeAtIpInOutErr), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("timeAtIpOutIn"), OffsetOf(__shadow__::__BNmuon, timeAtIpOutIn), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("timeAtIpOutInErr"), OffsetOf(__shadow__::__BNmuon, timeAtIpOutInErr), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ecal_time"), OffsetOf(__shadow__::__BNmuon, ecal_time), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcal_time"), OffsetOf(__shadow__::__BNmuon, hcal_time), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ecal_timeError"), OffsetOf(__shadow__::__BNmuon, ecal_timeError), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcal_timeError"), OffsetOf(__shadow__::__BNmuon, hcal_timeError), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("energy_ecal"), OffsetOf(__shadow__::__BNmuon, energy_ecal), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("energy_hcal"), OffsetOf(__shadow__::__BNmuon, energy_hcal), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("e3x3_ecal"), OffsetOf(__shadow__::__BNmuon, e3x3_ecal), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("e3x3_hcal"), OffsetOf(__shadow__::__BNmuon, e3x3_hcal), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("energyMax_ecal"), OffsetOf(__shadow__::__BNmuon, energyMax_ecal), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("energyMax_hcal"), OffsetOf(__shadow__::__BNmuon, energyMax_hcal), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("IDGMPTight"), OffsetOf(__shadow__::__BNmuon, IDGMPTight), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("tkNumValidHits"), OffsetOf(__shadow__::__BNmuon, tkNumValidHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("samNumValidHits"), OffsetOf(__shadow__::__BNmuon, samNumValidHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("samCharge"), OffsetOf(__shadow__::__BNmuon, samCharge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("comNumValidHits"), OffsetOf(__shadow__::__BNmuon, comNumValidHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("comCharge"), OffsetOf(__shadow__::__BNmuon, comCharge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isPFMuon"), OffsetOf(__shadow__::__BNmuon, isPFMuon), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isGoodMuon_1StationTight"), OffsetOf(__shadow__::__BNmuon, isGoodMuon_1StationTight), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isGlobalMuon"), OffsetOf(__shadow__::__BNmuon, isGlobalMuon), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isTrackerMuon"), OffsetOf(__shadow__::__BNmuon, isTrackerMuon), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isStandAloneMuon"), OffsetOf(__shadow__::__BNmuon, isStandAloneMuon), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isGlobalMuonPromptTight"), OffsetOf(__shadow__::__BNmuon, isGlobalMuonPromptTight), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfValidMuonHits"), OffsetOf(__shadow__::__BNmuon, numberOfValidMuonHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfValidTrackerHits"), OffsetOf(__shadow__::__BNmuon, numberOfValidTrackerHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfLayersWithMeasurement"), OffsetOf(__shadow__::__BNmuon, numberOfLayersWithMeasurement), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("pixelLayersWithMeasurement"), OffsetOf(__shadow__::__BNmuon, pixelLayersWithMeasurement), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfMatches"), OffsetOf(__shadow__::__BNmuon, numberOfMatches), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfValidTrackerHitsInnerTrack"), OffsetOf(__shadow__::__BNmuon, numberOfValidTrackerHitsInnerTrack), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfValidPixelHits"), OffsetOf(__shadow__::__BNmuon, numberOfValidPixelHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfMatchedStations"), OffsetOf(__shadow__::__BNmuon, numberOfMatchedStations), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("time_ndof"), OffsetOf(__shadow__::__BNmuon, time_ndof), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("innerTrackPt"), OffsetOf(__shadow__::__BNmuon, innerTrackPt), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("innerTrackPtError"), OffsetOf(__shadow__::__BNmuon, innerTrackPtError), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNmuon -------------------
void __BNmuon_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BNmuon,std::allocator<BNmuon> > -------------------------------
static void constructor_4324( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmuon>();
  else ::new(mem) ::std::vector<BNmuon>();
}

static void constructor_4325( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmuon>(*(const ::std::allocator<BNmuon>*)arg[0]);
  else ::new(mem) ::std::vector<BNmuon>(*(const ::std::allocator<BNmuon>*)arg[0]);
}

static void constructor_4326( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmuon>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNmuon>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmuon>(*(::std::size_t*)arg[0],
      *(const ::BNmuon*)arg[1]);
  else ::new(mem) ::std::vector<BNmuon>(*(::std::size_t*)arg[0],
      *(const ::BNmuon*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmuon>(*(::std::size_t*)arg[0],
      *(const ::BNmuon*)arg[1],
      *(const ::std::allocator<BNmuon>*)arg[2]);
  else ::new(mem) ::std::vector<BNmuon>(*(::std::size_t*)arg[0],
      *(const ::BNmuon*)arg[1],
      *(const ::std::allocator<BNmuon>*)arg[2]);
  }
}

static void constructor_4327( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmuon>(*(const ::std::vector<BNmuon>*)arg[0]);
  else ::new(mem) ::std::vector<BNmuon>(*(const ::std::vector<BNmuon>*)arg[0]);
}

static void destructor_4328(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNmuon>*)o)->::std::vector<BNmuon>::~vector)();
}
static  void operator_4329( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmuon>*)o)->operator=)(*(const ::std::vector<BNmuon>*)arg[0]);
  else   (((::std::vector<BNmuon>*)o)->operator=)(*(const ::std::vector<BNmuon>*)arg[0]);
}

static  void method_4330( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmuon>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNmuon*)arg[1]);
}

static  void method_4331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >)((((::std::vector<BNmuon>*)o)->begin)());
  else   (((::std::vector<BNmuon>*)o)->begin)();
}

static  void method_4332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNmuon*,std::vector<BNmuon> >)((((const ::std::vector<BNmuon>*)o)->begin)());
  else   (((const ::std::vector<BNmuon>*)o)->begin)();
}

static  void method_4333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >)((((::std::vector<BNmuon>*)o)->end)());
  else   (((::std::vector<BNmuon>*)o)->end)();
}

static  void method_4334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNmuon*,std::vector<BNmuon> >)((((const ::std::vector<BNmuon>*)o)->end)());
  else   (((const ::std::vector<BNmuon>*)o)->end)();
}

static  void method_4339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNmuon>*)o)->size)());
  else   (((const ::std::vector<BNmuon>*)o)->size)();
}

static  void method_4340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNmuon>*)o)->max_size)());
  else   (((const ::std::vector<BNmuon>*)o)->max_size)();
}

static  void method_4341( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNmuon>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNmuon>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNmuon*)arg[1]);
  }
}

static  void method_4342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNmuon>*)o)->capacity)());
  else   (((const ::std::vector<BNmuon>*)o)->capacity)();
}

static  void method_4343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNmuon>*)o)->empty)());
  else   (((const ::std::vector<BNmuon>*)o)->empty)();
}

static  void method_4344( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmuon>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmuon>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNmuon>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNmuon>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNmuon>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4348( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmuon>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNmuon>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4349( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNmuon>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNmuon>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmuon>*)o)->front)();
  else   (((::std::vector<BNmuon>*)o)->front)();
}

static  void method_4351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNmuon>*)o)->front)();
  else   (((const ::std::vector<BNmuon>*)o)->front)();
}

static  void method_4352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmuon>*)o)->back)();
  else   (((::std::vector<BNmuon>*)o)->back)();
}

static  void method_4353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNmuon>*)o)->back)();
  else   (((const ::std::vector<BNmuon>*)o)->back)();
}

static  void method_4354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNmuon>*)o)->data)());
  else   (((::std::vector<BNmuon>*)o)->data)();
}

static  void method_4355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNmuon>*)o)->data)());
  else   (((const ::std::vector<BNmuon>*)o)->data)();
}

static  void method_4356( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmuon>*)o)->push_back)(*(const ::BNmuon*)arg[0]);
}

static  void method_4357( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNmuon>*)o)->pop_back)();
}

static  void method_4358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >)((((::std::vector<BNmuon>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >*)arg[0],
    *(const ::BNmuon*)arg[1]));
  else   (((::std::vector<BNmuon>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >*)arg[0],
    *(const ::BNmuon*)arg[1]);
}

static  void method_4359( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmuon>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNmuon*)arg[2]);
}

static  void method_4360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >)((((::std::vector<BNmuon>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >*)arg[0]));
  else   (((::std::vector<BNmuon>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >*)arg[0]);
}

static  void method_4361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >)((((::std::vector<BNmuon>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >*)arg[1]));
  else   (((::std::vector<BNmuon>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNmuon*,std::vector<BNmuon> >*)arg[1]);
}

static  void method_4362( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmuon>*)o)->swap)(*(::std::vector<BNmuon>*)arg[0]);
}

static  void method_4363( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNmuon>*)o)->clear)();
}

static void method_newdel_377( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNmuon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNmuon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNmuon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNmuon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNmuon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNmuon,std::allocator<BNmuon> >")), ::Reflex::BaseOffset< ::std::vector<BNmuon>,::std::_Vector_base<BNmuon,std::allocator<BNmuon> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x34( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNmuon> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNmuon> >::Generate();
}

//------Dictionary for class vector<BNmuon,std::allocator<BNmuon> > -------------------------------
void __std__vector_BNmuon__db_datamem(Reflex::Class*);
void __std__vector_BNmuon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNmuon__datamem_bld(&__std__vector_BNmuon__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNmuon__funcmem_bld(&__std__vector_BNmuon__db_funcmem);
void __std__vector_BNmuon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNmuon>"), typeid(::std::vector<BNmuon>), sizeof(::std::vector<BNmuon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1833, ::Reflex::BaseOffset< ::std::vector<BNmuon>, ::std::_Vector_base<BNmuon,std::allocator<BNmuon> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_336, Reflex::Literal("std::vector<BNmuon>::_Alloc_value_type"))
  .AddTypedef(type_1833, Reflex::Literal("std::vector<BNmuon>::_Base"))
  .AddTypedef(type_2548, Reflex::Literal("std::vector<BNmuon>::_Tp_alloc_type"))
  .AddTypedef(type_336, Reflex::Literal("std::vector<BNmuon>::value_type"))
  .AddTypedef(type_4307, Reflex::Literal("std::vector<BNmuon>::pointer"))
  .AddTypedef(type_4309, Reflex::Literal("std::vector<BNmuon>::const_pointer"))
  .AddTypedef(type_4311, Reflex::Literal("std::vector<BNmuon>::reference"))
  .AddTypedef(type_4313, Reflex::Literal("std::vector<BNmuon>::const_reference"))
  .AddTypedef(type_4315, Reflex::Literal("std::vector<BNmuon>::iterator"))
  .AddTypedef(type_4317, Reflex::Literal("std::vector<BNmuon>::const_iterator"))
  .AddTypedef(type_2699, Reflex::Literal("std::vector<BNmuon>::const_reverse_iterator"))
  .AddTypedef(type_2700, Reflex::Literal("std::vector<BNmuon>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNmuon>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNmuon>::difference_type"))
  .AddTypedef(type_2548, Reflex::Literal("std::vector<BNmuon>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4324, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17594), Reflex::Literal("vector"), constructor_4325, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_4313, type_17594), Reflex::Literal("vector"), constructor_4326, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17595), Reflex::Literal("vector"), constructor_4327, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4328, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_377, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x34, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNmuon__funcmem_bld);
}

//------Delayed data member builder for class vector<BNmuon,std::allocator<BNmuon> > -------------------
void __std__vector_BNmuon__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNmuon,std::allocator<BNmuon> > -------------------
void __std__vector_BNmuon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17596, type_17595), Reflex::Literal("operator="), operator_4329, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_4313), Reflex::Literal("assign"), method_4330, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4315), Reflex::Literal("begin"), method_4331, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4317), Reflex::Literal("begin"), method_4332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4315), Reflex::Literal("end"), method_4333, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4317), Reflex::Literal("end"), method_4334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_4339, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_4340, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_336), Reflex::Literal("resize"), method_4341, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_4342, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_4343, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_4344, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4311, type_2521), Reflex::Literal("operator[]"), operator_4345, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4313, type_2521), Reflex::Literal("operator[]"), operator_4346, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4311, type_2521), Reflex::Literal("at"), method_4348, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4313, type_2521), Reflex::Literal("at"), method_4349, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4311), Reflex::Literal("front"), method_4350, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4313), Reflex::Literal("front"), method_4351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4311), Reflex::Literal("back"), method_4352, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4313), Reflex::Literal("back"), method_4353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4307), Reflex::Literal("data"), method_4354, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4309), Reflex::Literal("data"), method_4355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4313), Reflex::Literal("push_back"), method_4356, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_4357, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4315, type_4315, type_4313), Reflex::Literal("insert"), method_4358, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4315, type_2521, type_4313), Reflex::Literal("insert"), method_4359, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4315, type_4315), Reflex::Literal("erase"), method_4360, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4315, type_4315, type_4315), Reflex::Literal("erase"), method_4361, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17596), Reflex::Literal("swap"), method_4362, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_4363, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BNelectron -------------------------------
static void destructor_5828(void*, void * o, const std::vector<void*>&, void *) {
(((::BNelectron*)o)->::BNelectron::~BNelectron)();
}
static  void operator_5829( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNelectron*)o)->operator=)(*(const ::BNelectron*)arg[0]);
  else   (((::BNelectron*)o)->operator=)(*(const ::BNelectron*)arg[0]);
}

static void constructor_5830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNelectron(*(const ::BNelectron*)arg[0]);
  else ::new(mem) ::BNelectron(*(const ::BNelectron*)arg[0]);
}

static void constructor_5831( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNelectron(*(double*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::BNelectron(*(double*)arg[0],
      *(int*)arg[1]);
}

static void constructor_5832( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNelectron();
  else ::new(mem) ::BNelectron();
}

static void method_newdel_1510( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNelectron >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNelectron >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNelectron >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNelectron >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNelectron >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x36( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("BNlepton")), ::Reflex::BaseOffset< ::BNelectron,::BNlepton >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class BNelectron -------------------------------
void __BNelectron_db_datamem(Reflex::Class*);
void __BNelectron_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNelectron_datamem_bld(&__BNelectron_db_datamem);
Reflex::GenreflexMemberBuilder __BNelectron_funcmem_bld(&__BNelectron_db_funcmem);
void __BNelectron_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNelectron"), typeid(::BNelectron), sizeof(::BNelectron), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddBase(type_1092, ::Reflex::BaseOffset< ::BNelectron, ::BNlepton >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNelectron"), destructor_5828, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4779, type_4781), Reflex::Literal("operator="), operator_5829, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4781), Reflex::Literal("BNelectron"), constructor_5830, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698, type_58), Reflex::Literal("BNelectron"), constructor_5831, 0, "v;c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNelectron"), constructor_5832, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1510, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNelectron_datamem_bld);
}

//------Delayed data member builder for class BNelectron -------------------
void __BNelectron_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("gsfEt"), OffsetOf(__shadow__::__BNelectron, gsfEt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pIn"), OffsetOf(__shadow__::__BNelectron, pIn), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pOut"), OffsetOf(__shadow__::__BNelectron, pOut), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("EscOverPin"), OffsetOf(__shadow__::__BNelectron, EscOverPin), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("EseedOverPout"), OffsetOf(__shadow__::__BNelectron, EseedOverPout), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hadOverEm"), OffsetOf(__shadow__::__BNelectron, hadOverEm), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalIsoDR03depth1"), OffsetOf(__shadow__::__BNelectron, hcalIsoDR03depth1), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalIsoDR03depth2"), OffsetOf(__shadow__::__BNelectron, hcalIsoDR03depth2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("trackIsoDR04"), OffsetOf(__shadow__::__BNelectron, trackIsoDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ecalIsoDR04"), OffsetOf(__shadow__::__BNelectron, ecalIsoDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalIsoDR04"), OffsetOf(__shadow__::__BNelectron, hcalIsoDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalIsoDR04depth1"), OffsetOf(__shadow__::__BNelectron, hcalIsoDR04depth1), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalIsoDR04depth2"), OffsetOf(__shadow__::__BNelectron, hcalIsoDR04depth2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloIsoDR04"), OffsetOf(__shadow__::__BNelectron, caloIsoDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("fbrem"), OffsetOf(__shadow__::__BNelectron, fbrem), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("absInvEMinusInvPin"), OffsetOf(__shadow__::__BNelectron, absInvEMinusInvPin), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("delPhiIn"), OffsetOf(__shadow__::__BNelectron, delPhiIn), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("delEtaIn"), OffsetOf(__shadow__::__BNelectron, delEtaIn), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scEnergy"), OffsetOf(__shadow__::__BNelectron, scEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scRawEnergy"), OffsetOf(__shadow__::__BNelectron, scRawEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scSigmaEtaEta"), OffsetOf(__shadow__::__BNelectron, scSigmaEtaEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scSigmaIEtaIEta"), OffsetOf(__shadow__::__BNelectron, scSigmaIEtaIEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scE1x5"), OffsetOf(__shadow__::__BNelectron, scE1x5), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scE2x5Max"), OffsetOf(__shadow__::__BNelectron, scE2x5Max), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scE5x5"), OffsetOf(__shadow__::__BNelectron, scE5x5), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scEt"), OffsetOf(__shadow__::__BNelectron, scEt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scEta"), OffsetOf(__shadow__::__BNelectron, scEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scPhi"), OffsetOf(__shadow__::__BNelectron, scPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scZ"), OffsetOf(__shadow__::__BNelectron, scZ), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mva"), OffsetOf(__shadow__::__BNelectron, mva), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mvaTrigV0"), OffsetOf(__shadow__::__BNelectron, mvaTrigV0), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mvaNonTrigV0"), OffsetOf(__shadow__::__BNelectron, mvaNonTrigV0), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("dist"), OffsetOf(__shadow__::__BNelectron, dist), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("dcot"), OffsetOf(__shadow__::__BNelectron, dcot), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("convradius"), OffsetOf(__shadow__::__BNelectron, convradius), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("convPointX"), OffsetOf(__shadow__::__BNelectron, convPointX), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("convPointY"), OffsetOf(__shadow__::__BNelectron, convPointY), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("convPointZ"), OffsetOf(__shadow__::__BNelectron, convPointZ), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eMax"), OffsetOf(__shadow__::__BNelectron, eMax), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eLeft"), OffsetOf(__shadow__::__BNelectron, eLeft), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eRight"), OffsetOf(__shadow__::__BNelectron, eRight), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eTop"), OffsetOf(__shadow__::__BNelectron, eTop), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eBottom"), OffsetOf(__shadow__::__BNelectron, eBottom), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("e3x3"), OffsetOf(__shadow__::__BNelectron, e3x3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("swissCross"), OffsetOf(__shadow__::__BNelectron, swissCross), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("seedEnergy"), OffsetOf(__shadow__::__BNelectron, seedEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("seedTime"), OffsetOf(__shadow__::__BNelectron, seedTime), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("swissCrossNoI85"), OffsetOf(__shadow__::__BNelectron, swissCrossNoI85), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("swissCrossI85"), OffsetOf(__shadow__::__BNelectron, swissCrossI85), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("E2overE9NoI85"), OffsetOf(__shadow__::__BNelectron, E2overE9NoI85), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("E2overE9I85"), OffsetOf(__shadow__::__BNelectron, E2overE9I85), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("classification"), OffsetOf(__shadow__::__BNelectron, classification), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genGrandMother11Id"), OffsetOf(__shadow__::__BNelectron, genGrandMother11Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numClusters"), OffsetOf(__shadow__::__BNelectron, numClusters), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("tkNumValidHits"), OffsetOf(__shadow__::__BNelectron, tkNumValidHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("gsfCharge"), OffsetOf(__shadow__::__BNelectron, gsfCharge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isEB"), OffsetOf(__shadow__::__BNelectron, isEB), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isEE"), OffsetOf(__shadow__::__BNelectron, isEE), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isGap"), OffsetOf(__shadow__::__BNelectron, isGap), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isEBEEGap"), OffsetOf(__shadow__::__BNelectron, isEBEEGap), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isEBGap"), OffsetOf(__shadow__::__BNelectron, isEBGap), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isEEGap"), OffsetOf(__shadow__::__BNelectron, isEEGap), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isEcalDriven"), OffsetOf(__shadow__::__BNelectron, isEcalDriven), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isTrackerDriven"), OffsetOf(__shadow__::__BNelectron, isTrackerDriven), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfLostHits"), OffsetOf(__shadow__::__BNelectron, numberOfLostHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfExpectedInnerHits"), OffsetOf(__shadow__::__BNelectron, numberOfExpectedInnerHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfValidPixelHits"), OffsetOf(__shadow__::__BNelectron, numberOfValidPixelHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfValidPixelBarrelHits"), OffsetOf(__shadow__::__BNelectron, numberOfValidPixelBarrelHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numberOfValidPixelEndcapHits"), OffsetOf(__shadow__::__BNelectron, numberOfValidPixelEndcapHits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isHEEP"), OffsetOf(__shadow__::__BNelectron, isHEEP), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isHEEPnoEt"), OffsetOf(__shadow__::__BNelectron, isHEEPnoEt), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("seedRecoFlag"), OffsetOf(__shadow__::__BNelectron, seedRecoFlag), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidRobustHighEnergy"), OffsetOf(__shadow__::__BNelectron, eidRobustHighEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidRobustLoose"), OffsetOf(__shadow__::__BNelectron, eidRobustLoose), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidRobustTight"), OffsetOf(__shadow__::__BNelectron, eidRobustTight), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidLoose"), OffsetOf(__shadow__::__BNelectron, eidLoose), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidTight"), OffsetOf(__shadow__::__BNelectron, eidTight), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidVeryLooseMC"), OffsetOf(__shadow__::__BNelectron, eidVeryLooseMC), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidLooseMC"), OffsetOf(__shadow__::__BNelectron, eidLooseMC), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidMediumMC"), OffsetOf(__shadow__::__BNelectron, eidMediumMC), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidTightMC"), OffsetOf(__shadow__::__BNelectron, eidTightMC), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidSuperTightMC"), OffsetOf(__shadow__::__BNelectron, eidSuperTightMC), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidHyperTight1MC"), OffsetOf(__shadow__::__BNelectron, eidHyperTight1MC), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidHyperTight2MC"), OffsetOf(__shadow__::__BNelectron, eidHyperTight2MC), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidHyperTight3MC"), OffsetOf(__shadow__::__BNelectron, eidHyperTight3MC), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("eidHyperTight4MC"), OffsetOf(__shadow__::__BNelectron, eidHyperTight4MC), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("passConvVeto"), OffsetOf(__shadow__::__BNelectron, passConvVeto), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isGsfCtfScPixChargeConsistent"), OffsetOf(__shadow__::__BNelectron, isGsfCtfScPixChargeConsistent), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNelectron -------------------
void __BNelectron_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BNelectron,std::allocator<BNelectron> > -------------------------------
static void constructor_4792( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNelectron>();
  else ::new(mem) ::std::vector<BNelectron>();
}

static void constructor_4793( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNelectron>(*(const ::std::allocator<BNelectron>*)arg[0]);
  else ::new(mem) ::std::vector<BNelectron>(*(const ::std::allocator<BNelectron>*)arg[0]);
}

static void constructor_4794( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNelectron>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNelectron>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNelectron>(*(::std::size_t*)arg[0],
      *(const ::BNelectron*)arg[1]);
  else ::new(mem) ::std::vector<BNelectron>(*(::std::size_t*)arg[0],
      *(const ::BNelectron*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNelectron>(*(::std::size_t*)arg[0],
      *(const ::BNelectron*)arg[1],
      *(const ::std::allocator<BNelectron>*)arg[2]);
  else ::new(mem) ::std::vector<BNelectron>(*(::std::size_t*)arg[0],
      *(const ::BNelectron*)arg[1],
      *(const ::std::allocator<BNelectron>*)arg[2]);
  }
}

static void constructor_4795( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNelectron>(*(const ::std::vector<BNelectron>*)arg[0]);
  else ::new(mem) ::std::vector<BNelectron>(*(const ::std::vector<BNelectron>*)arg[0]);
}

static void destructor_4796(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNelectron>*)o)->::std::vector<BNelectron>::~vector)();
}
static  void operator_4797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNelectron>*)o)->operator=)(*(const ::std::vector<BNelectron>*)arg[0]);
  else   (((::std::vector<BNelectron>*)o)->operator=)(*(const ::std::vector<BNelectron>*)arg[0]);
}

static  void method_4798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNelectron>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNelectron*)arg[1]);
}

static  void method_4799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >)((((::std::vector<BNelectron>*)o)->begin)());
  else   (((::std::vector<BNelectron>*)o)->begin)();
}

static  void method_4800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNelectron*,std::vector<BNelectron> >)((((const ::std::vector<BNelectron>*)o)->begin)());
  else   (((const ::std::vector<BNelectron>*)o)->begin)();
}

static  void method_4801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >)((((::std::vector<BNelectron>*)o)->end)());
  else   (((::std::vector<BNelectron>*)o)->end)();
}

static  void method_4802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNelectron*,std::vector<BNelectron> >)((((const ::std::vector<BNelectron>*)o)->end)());
  else   (((const ::std::vector<BNelectron>*)o)->end)();
}

static  void method_4807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNelectron>*)o)->size)());
  else   (((const ::std::vector<BNelectron>*)o)->size)();
}

static  void method_4808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNelectron>*)o)->max_size)());
  else   (((const ::std::vector<BNelectron>*)o)->max_size)();
}

static  void method_4809( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNelectron>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNelectron>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNelectron*)arg[1]);
  }
}

static  void method_4810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNelectron>*)o)->capacity)());
  else   (((const ::std::vector<BNelectron>*)o)->capacity)();
}

static  void method_4811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNelectron>*)o)->empty)());
  else   (((const ::std::vector<BNelectron>*)o)->empty)();
}

static  void method_4812( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNelectron>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNelectron>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNelectron>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNelectron>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNelectron>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4816( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNelectron>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNelectron>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4817( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNelectron>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNelectron>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNelectron>*)o)->front)();
  else   (((::std::vector<BNelectron>*)o)->front)();
}

static  void method_4819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNelectron>*)o)->front)();
  else   (((const ::std::vector<BNelectron>*)o)->front)();
}

static  void method_4820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNelectron>*)o)->back)();
  else   (((::std::vector<BNelectron>*)o)->back)();
}

static  void method_4821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNelectron>*)o)->back)();
  else   (((const ::std::vector<BNelectron>*)o)->back)();
}

static  void method_4822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNelectron>*)o)->data)());
  else   (((::std::vector<BNelectron>*)o)->data)();
}

static  void method_4823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNelectron>*)o)->data)());
  else   (((const ::std::vector<BNelectron>*)o)->data)();
}

static  void method_4824( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNelectron>*)o)->push_back)(*(const ::BNelectron*)arg[0]);
}

static  void method_4825( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNelectron>*)o)->pop_back)();
}

static  void method_4826( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >)((((::std::vector<BNelectron>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >*)arg[0],
    *(const ::BNelectron*)arg[1]));
  else   (((::std::vector<BNelectron>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >*)arg[0],
    *(const ::BNelectron*)arg[1]);
}

static  void method_4827( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNelectron>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNelectron*)arg[2]);
}

static  void method_4828( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >)((((::std::vector<BNelectron>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >*)arg[0]));
  else   (((::std::vector<BNelectron>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >*)arg[0]);
}

static  void method_4829( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >)((((::std::vector<BNelectron>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >*)arg[1]));
  else   (((::std::vector<BNelectron>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNelectron*,std::vector<BNelectron> >*)arg[1]);
}

static  void method_4830( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNelectron>*)o)->swap)(*(::std::vector<BNelectron>*)arg[0]);
}

static  void method_4831( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNelectron>*)o)->clear)();
}

static void method_newdel_549( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNelectron> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNelectron> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNelectron> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNelectron> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNelectron> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x38( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNelectron,std::allocator<BNelectron> >")), ::Reflex::BaseOffset< ::std::vector<BNelectron>,::std::_Vector_base<BNelectron,std::allocator<BNelectron> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNelectron> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNelectron> >::Generate();
}

//------Dictionary for class vector<BNelectron,std::allocator<BNelectron> > -------------------------------
void __std__vector_BNelectron__db_datamem(Reflex::Class*);
void __std__vector_BNelectron__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNelectron__datamem_bld(&__std__vector_BNelectron__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNelectron__funcmem_bld(&__std__vector_BNelectron__db_funcmem);
void __std__vector_BNelectron__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNelectron>"), typeid(::std::vector<BNelectron>), sizeof(::std::vector<BNelectron>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1839, ::Reflex::BaseOffset< ::std::vector<BNelectron>, ::std::_Vector_base<BNelectron,std::allocator<BNelectron> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1510, Reflex::Literal("std::vector<BNelectron>::_Alloc_value_type"))
  .AddTypedef(type_1839, Reflex::Literal("std::vector<BNelectron>::_Base"))
  .AddTypedef(type_2554, Reflex::Literal("std::vector<BNelectron>::_Tp_alloc_type"))
  .AddTypedef(type_1510, Reflex::Literal("std::vector<BNelectron>::value_type"))
  .AddTypedef(type_4775, Reflex::Literal("std::vector<BNelectron>::pointer"))
  .AddTypedef(type_4777, Reflex::Literal("std::vector<BNelectron>::const_pointer"))
  .AddTypedef(type_4779, Reflex::Literal("std::vector<BNelectron>::reference"))
  .AddTypedef(type_4781, Reflex::Literal("std::vector<BNelectron>::const_reference"))
  .AddTypedef(type_4783, Reflex::Literal("std::vector<BNelectron>::iterator"))
  .AddTypedef(type_4785, Reflex::Literal("std::vector<BNelectron>::const_iterator"))
  .AddTypedef(type_2711, Reflex::Literal("std::vector<BNelectron>::const_reverse_iterator"))
  .AddTypedef(type_2712, Reflex::Literal("std::vector<BNelectron>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNelectron>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNelectron>::difference_type"))
  .AddTypedef(type_2554, Reflex::Literal("std::vector<BNelectron>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4792, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17777), Reflex::Literal("vector"), constructor_4793, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_4781, type_17777), Reflex::Literal("vector"), constructor_4794, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17778), Reflex::Literal("vector"), constructor_4795, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4796, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_549, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x38, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNelectron__funcmem_bld);
}

//------Delayed data member builder for class vector<BNelectron,std::allocator<BNelectron> > -------------------
void __std__vector_BNelectron__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNelectron,std::allocator<BNelectron> > -------------------
void __std__vector_BNelectron__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17779, type_17778), Reflex::Literal("operator="), operator_4797, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_4781), Reflex::Literal("assign"), method_4798, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4783), Reflex::Literal("begin"), method_4799, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4785), Reflex::Literal("begin"), method_4800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4783), Reflex::Literal("end"), method_4801, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4785), Reflex::Literal("end"), method_4802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_4807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_4808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_1510), Reflex::Literal("resize"), method_4809, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_4810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_4811, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_4812, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4779, type_2521), Reflex::Literal("operator[]"), operator_4813, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4781, type_2521), Reflex::Literal("operator[]"), operator_4814, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4779, type_2521), Reflex::Literal("at"), method_4816, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4781, type_2521), Reflex::Literal("at"), method_4817, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4779), Reflex::Literal("front"), method_4818, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4781), Reflex::Literal("front"), method_4819, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4779), Reflex::Literal("back"), method_4820, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4781), Reflex::Literal("back"), method_4821, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4775), Reflex::Literal("data"), method_4822, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4777), Reflex::Literal("data"), method_4823, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4781), Reflex::Literal("push_back"), method_4824, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_4825, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4783, type_4783, type_4781), Reflex::Literal("insert"), method_4826, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4783, type_2521, type_4781), Reflex::Literal("insert"), method_4827, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4783, type_4783), Reflex::Literal("erase"), method_4828, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4783, type_4783, type_4783), Reflex::Literal("erase"), method_4829, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17779), Reflex::Literal("swap"), method_4830, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_4831, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<BNsupercluster,std::allocator<BNsupercluster> > -------------------------------
static void constructor_4860( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNsupercluster>();
  else ::new(mem) ::std::vector<BNsupercluster>();
}

static void constructor_4861( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNsupercluster>(*(const ::std::allocator<BNsupercluster>*)arg[0]);
  else ::new(mem) ::std::vector<BNsupercluster>(*(const ::std::allocator<BNsupercluster>*)arg[0]);
}

static void constructor_4862( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNsupercluster>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNsupercluster>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNsupercluster>(*(::std::size_t*)arg[0],
      *(const ::BNsupercluster*)arg[1]);
  else ::new(mem) ::std::vector<BNsupercluster>(*(::std::size_t*)arg[0],
      *(const ::BNsupercluster*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNsupercluster>(*(::std::size_t*)arg[0],
      *(const ::BNsupercluster*)arg[1],
      *(const ::std::allocator<BNsupercluster>*)arg[2]);
  else ::new(mem) ::std::vector<BNsupercluster>(*(::std::size_t*)arg[0],
      *(const ::BNsupercluster*)arg[1],
      *(const ::std::allocator<BNsupercluster>*)arg[2]);
  }
}

static void constructor_4863( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNsupercluster>(*(const ::std::vector<BNsupercluster>*)arg[0]);
  else ::new(mem) ::std::vector<BNsupercluster>(*(const ::std::vector<BNsupercluster>*)arg[0]);
}

static void destructor_4864(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNsupercluster>*)o)->::std::vector<BNsupercluster>::~vector)();
}
static  void operator_4865( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNsupercluster>*)o)->operator=)(*(const ::std::vector<BNsupercluster>*)arg[0]);
  else   (((::std::vector<BNsupercluster>*)o)->operator=)(*(const ::std::vector<BNsupercluster>*)arg[0]);
}

static  void method_4866( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNsupercluster>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNsupercluster*)arg[1]);
}

static  void method_4867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >)((((::std::vector<BNsupercluster>*)o)->begin)());
  else   (((::std::vector<BNsupercluster>*)o)->begin)();
}

static  void method_4868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNsupercluster*,std::vector<BNsupercluster> >)((((const ::std::vector<BNsupercluster>*)o)->begin)());
  else   (((const ::std::vector<BNsupercluster>*)o)->begin)();
}

static  void method_4869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >)((((::std::vector<BNsupercluster>*)o)->end)());
  else   (((::std::vector<BNsupercluster>*)o)->end)();
}

static  void method_4870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNsupercluster*,std::vector<BNsupercluster> >)((((const ::std::vector<BNsupercluster>*)o)->end)());
  else   (((const ::std::vector<BNsupercluster>*)o)->end)();
}

static  void method_4875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNsupercluster>*)o)->size)());
  else   (((const ::std::vector<BNsupercluster>*)o)->size)();
}

static  void method_4876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNsupercluster>*)o)->max_size)());
  else   (((const ::std::vector<BNsupercluster>*)o)->max_size)();
}

static  void method_4877( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNsupercluster>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNsupercluster>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNsupercluster*)arg[1]);
  }
}

static  void method_4878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNsupercluster>*)o)->capacity)());
  else   (((const ::std::vector<BNsupercluster>*)o)->capacity)();
}

static  void method_4879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNsupercluster>*)o)->empty)());
  else   (((const ::std::vector<BNsupercluster>*)o)->empty)();
}

static  void method_4880( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNsupercluster>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNsupercluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNsupercluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNsupercluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNsupercluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4884( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNsupercluster>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNsupercluster>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNsupercluster>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNsupercluster>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNsupercluster>*)o)->front)();
  else   (((::std::vector<BNsupercluster>*)o)->front)();
}

static  void method_4887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNsupercluster>*)o)->front)();
  else   (((const ::std::vector<BNsupercluster>*)o)->front)();
}

static  void method_4888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNsupercluster>*)o)->back)();
  else   (((::std::vector<BNsupercluster>*)o)->back)();
}

static  void method_4889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNsupercluster>*)o)->back)();
  else   (((const ::std::vector<BNsupercluster>*)o)->back)();
}

static  void method_4890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNsupercluster>*)o)->data)());
  else   (((::std::vector<BNsupercluster>*)o)->data)();
}

static  void method_4891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNsupercluster>*)o)->data)());
  else   (((const ::std::vector<BNsupercluster>*)o)->data)();
}

static  void method_4892( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNsupercluster>*)o)->push_back)(*(const ::BNsupercluster*)arg[0]);
}

static  void method_4893( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNsupercluster>*)o)->pop_back)();
}

static  void method_4894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >)((((::std::vector<BNsupercluster>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >*)arg[0],
    *(const ::BNsupercluster*)arg[1]));
  else   (((::std::vector<BNsupercluster>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >*)arg[0],
    *(const ::BNsupercluster*)arg[1]);
}

static  void method_4895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNsupercluster>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNsupercluster*)arg[2]);
}

static  void method_4896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >)((((::std::vector<BNsupercluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >*)arg[0]));
  else   (((::std::vector<BNsupercluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >*)arg[0]);
}

static  void method_4897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >)((((::std::vector<BNsupercluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >*)arg[1]));
  else   (((::std::vector<BNsupercluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNsupercluster*,std::vector<BNsupercluster> >*)arg[1]);
}

static  void method_4898( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNsupercluster>*)o)->swap)(*(::std::vector<BNsupercluster>*)arg[0]);
}

static  void method_4899( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNsupercluster>*)o)->clear)();
}

static void method_newdel_576( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNsupercluster> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNsupercluster> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNsupercluster> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNsupercluster> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNsupercluster> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x41( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNsupercluster,std::allocator<BNsupercluster> >")), ::Reflex::BaseOffset< ::std::vector<BNsupercluster>,::std::_Vector_base<BNsupercluster,std::allocator<BNsupercluster> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNsupercluster> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNsupercluster> >::Generate();
}

//------Dictionary for class vector<BNsupercluster,std::allocator<BNsupercluster> > -------------------------------
void __std__vector_BNsupercluster__db_datamem(Reflex::Class*);
void __std__vector_BNsupercluster__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNsupercluster__datamem_bld(&__std__vector_BNsupercluster__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNsupercluster__funcmem_bld(&__std__vector_BNsupercluster__db_funcmem);
void __std__vector_BNsupercluster__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNsupercluster>"), typeid(::std::vector<BNsupercluster>), sizeof(::std::vector<BNsupercluster>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1830, ::Reflex::BaseOffset< ::std::vector<BNsupercluster>, ::std::_Vector_base<BNsupercluster,std::allocator<BNsupercluster> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_281, Reflex::Literal("std::vector<BNsupercluster>::_Alloc_value_type"))
  .AddTypedef(type_1830, Reflex::Literal("std::vector<BNsupercluster>::_Base"))
  .AddTypedef(type_2545, Reflex::Literal("std::vector<BNsupercluster>::_Tp_alloc_type"))
  .AddTypedef(type_281, Reflex::Literal("std::vector<BNsupercluster>::value_type"))
  .AddTypedef(type_4843, Reflex::Literal("std::vector<BNsupercluster>::pointer"))
  .AddTypedef(type_4845, Reflex::Literal("std::vector<BNsupercluster>::const_pointer"))
  .AddTypedef(type_4847, Reflex::Literal("std::vector<BNsupercluster>::reference"))
  .AddTypedef(type_4849, Reflex::Literal("std::vector<BNsupercluster>::const_reference"))
  .AddTypedef(type_4851, Reflex::Literal("std::vector<BNsupercluster>::iterator"))
  .AddTypedef(type_4853, Reflex::Literal("std::vector<BNsupercluster>::const_iterator"))
  .AddTypedef(type_2693, Reflex::Literal("std::vector<BNsupercluster>::const_reverse_iterator"))
  .AddTypedef(type_2694, Reflex::Literal("std::vector<BNsupercluster>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNsupercluster>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNsupercluster>::difference_type"))
  .AddTypedef(type_2545, Reflex::Literal("std::vector<BNsupercluster>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4860, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17781), Reflex::Literal("vector"), constructor_4861, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_4849, type_17781), Reflex::Literal("vector"), constructor_4862, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17782), Reflex::Literal("vector"), constructor_4863, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4864, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_576, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x41, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNsupercluster__funcmem_bld);
}

//------Delayed data member builder for class vector<BNsupercluster,std::allocator<BNsupercluster> > -------------------
void __std__vector_BNsupercluster__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNsupercluster,std::allocator<BNsupercluster> > -------------------
void __std__vector_BNsupercluster__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17783, type_17782), Reflex::Literal("operator="), operator_4865, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_4849), Reflex::Literal("assign"), method_4866, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4851), Reflex::Literal("begin"), method_4867, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4853), Reflex::Literal("begin"), method_4868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4851), Reflex::Literal("end"), method_4869, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4853), Reflex::Literal("end"), method_4870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_4875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_4876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_281), Reflex::Literal("resize"), method_4877, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_4878, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_4879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_4880, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4847, type_2521), Reflex::Literal("operator[]"), operator_4881, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4849, type_2521), Reflex::Literal("operator[]"), operator_4882, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4847, type_2521), Reflex::Literal("at"), method_4884, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4849, type_2521), Reflex::Literal("at"), method_4885, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4847), Reflex::Literal("front"), method_4886, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4849), Reflex::Literal("front"), method_4887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4847), Reflex::Literal("back"), method_4888, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4849), Reflex::Literal("back"), method_4889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4843), Reflex::Literal("data"), method_4890, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4845), Reflex::Literal("data"), method_4891, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4849), Reflex::Literal("push_back"), method_4892, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_4893, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4851, type_4851, type_4849), Reflex::Literal("insert"), method_4894, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4851, type_2521, type_4849), Reflex::Literal("insert"), method_4895, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4851, type_4851), Reflex::Literal("erase"), method_4896, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4851, type_4851, type_4851), Reflex::Literal("erase"), method_4897, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17783), Reflex::Literal("swap"), method_4898, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_4899, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BNgenjet -------------------------------
static void destructor_6379(void*, void * o, const std::vector<void*>&, void *) {
(((::BNgenjet*)o)->::BNgenjet::~BNgenjet)();
}
static  void operator_6380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNgenjet*)o)->operator=)(*(const ::BNgenjet*)arg[0]);
  else   (((::BNgenjet*)o)->operator=)(*(const ::BNgenjet*)arg[0]);
}

static void constructor_6381( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNgenjet(*(const ::BNgenjet*)arg[0]);
  else ::new(mem) ::BNgenjet(*(const ::BNgenjet*)arg[0]);
}

static void constructor_6382( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNgenjet(*(double*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::BNgenjet(*(double*)arg[0],
      *(int*)arg[1]);
}

static void constructor_6383( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNgenjet();
  else ::new(mem) ::BNgenjet();
}

static void method_newdel_1748( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNgenjet >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNgenjet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNgenjet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNgenjet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNgenjet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNgenjet -------------------------------
void __BNgenjet_db_datamem(Reflex::Class*);
void __BNgenjet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNgenjet_datamem_bld(&__BNgenjet_db_datamem);
Reflex::GenreflexMemberBuilder __BNgenjet_funcmem_bld(&__BNgenjet_db_funcmem);
void __BNgenjet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNgenjet"), typeid(::BNgenjet), sizeof(::BNgenjet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNgenjet"), destructor_6379, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4941, type_4943), Reflex::Literal("operator="), operator_6380, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4943), Reflex::Literal("BNgenjet"), constructor_6381, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698, type_58), Reflex::Literal("BNgenjet"), constructor_6382, 0, "v;c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNgenjet"), constructor_6383, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1748, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNgenjet_datamem_bld);
}

//------Delayed data member builder for class BNgenjet -------------------
void __BNgenjet_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("pt"), OffsetOf(__shadow__::__BNgenjet, pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eta"), OffsetOf(__shadow__::__BNgenjet, eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("phi"), OffsetOf(__shadow__::__BNgenjet, phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("px"), OffsetOf(__shadow__::__BNgenjet, px), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("py"), OffsetOf(__shadow__::__BNgenjet, py), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pz"), OffsetOf(__shadow__::__BNgenjet, pz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("et"), OffsetOf(__shadow__::__BNgenjet, et), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("energy"), OffsetOf(__shadow__::__BNgenjet, energy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mass"), OffsetOf(__shadow__::__BNgenjet, mass), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("emEnergy"), OffsetOf(__shadow__::__BNgenjet, emEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hadEnergy"), OffsetOf(__shadow__::__BNgenjet, hadEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("invisibleEnergy"), OffsetOf(__shadow__::__BNgenjet, invisibleEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("auxiliaryEnergy"), OffsetOf(__shadow__::__BNgenjet, auxiliaryEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("charge"), OffsetOf(__shadow__::__BNgenjet, charge), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNgenjet -------------------
void __BNgenjet_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BNgenjet,std::allocator<BNgenjet> > -------------------------------
static void constructor_4954( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNgenjet>();
  else ::new(mem) ::std::vector<BNgenjet>();
}

static void constructor_4955( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNgenjet>(*(const ::std::allocator<BNgenjet>*)arg[0]);
  else ::new(mem) ::std::vector<BNgenjet>(*(const ::std::allocator<BNgenjet>*)arg[0]);
}

static void constructor_4956( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNgenjet>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNgenjet>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNgenjet>(*(::std::size_t*)arg[0],
      *(const ::BNgenjet*)arg[1]);
  else ::new(mem) ::std::vector<BNgenjet>(*(::std::size_t*)arg[0],
      *(const ::BNgenjet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNgenjet>(*(::std::size_t*)arg[0],
      *(const ::BNgenjet*)arg[1],
      *(const ::std::allocator<BNgenjet>*)arg[2]);
  else ::new(mem) ::std::vector<BNgenjet>(*(::std::size_t*)arg[0],
      *(const ::BNgenjet*)arg[1],
      *(const ::std::allocator<BNgenjet>*)arg[2]);
  }
}

static void constructor_4957( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNgenjet>(*(const ::std::vector<BNgenjet>*)arg[0]);
  else ::new(mem) ::std::vector<BNgenjet>(*(const ::std::vector<BNgenjet>*)arg[0]);
}

static void destructor_4958(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNgenjet>*)o)->::std::vector<BNgenjet>::~vector)();
}
static  void operator_4959( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNgenjet>*)o)->operator=)(*(const ::std::vector<BNgenjet>*)arg[0]);
  else   (((::std::vector<BNgenjet>*)o)->operator=)(*(const ::std::vector<BNgenjet>*)arg[0]);
}

static  void method_4960( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNgenjet>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNgenjet*)arg[1]);
}

static  void method_4961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >)((((::std::vector<BNgenjet>*)o)->begin)());
  else   (((::std::vector<BNgenjet>*)o)->begin)();
}

static  void method_4962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNgenjet*,std::vector<BNgenjet> >)((((const ::std::vector<BNgenjet>*)o)->begin)());
  else   (((const ::std::vector<BNgenjet>*)o)->begin)();
}

static  void method_4963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >)((((::std::vector<BNgenjet>*)o)->end)());
  else   (((::std::vector<BNgenjet>*)o)->end)();
}

static  void method_4964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNgenjet*,std::vector<BNgenjet> >)((((const ::std::vector<BNgenjet>*)o)->end)());
  else   (((const ::std::vector<BNgenjet>*)o)->end)();
}

static  void method_4969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNgenjet>*)o)->size)());
  else   (((const ::std::vector<BNgenjet>*)o)->size)();
}

static  void method_4970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNgenjet>*)o)->max_size)());
  else   (((const ::std::vector<BNgenjet>*)o)->max_size)();
}

static  void method_4971( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNgenjet>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNgenjet>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNgenjet*)arg[1]);
  }
}

static  void method_4972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNgenjet>*)o)->capacity)());
  else   (((const ::std::vector<BNgenjet>*)o)->capacity)();
}

static  void method_4973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNgenjet>*)o)->empty)());
  else   (((const ::std::vector<BNgenjet>*)o)->empty)();
}

static  void method_4974( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNgenjet>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNgenjet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNgenjet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNgenjet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNgenjet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNgenjet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNgenjet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNgenjet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNgenjet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNgenjet>*)o)->front)();
  else   (((::std::vector<BNgenjet>*)o)->front)();
}

static  void method_4981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNgenjet>*)o)->front)();
  else   (((const ::std::vector<BNgenjet>*)o)->front)();
}

static  void method_4982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNgenjet>*)o)->back)();
  else   (((::std::vector<BNgenjet>*)o)->back)();
}

static  void method_4983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNgenjet>*)o)->back)();
  else   (((const ::std::vector<BNgenjet>*)o)->back)();
}

static  void method_4984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNgenjet>*)o)->data)());
  else   (((::std::vector<BNgenjet>*)o)->data)();
}

static  void method_4985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNgenjet>*)o)->data)());
  else   (((const ::std::vector<BNgenjet>*)o)->data)();
}

static  void method_4986( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNgenjet>*)o)->push_back)(*(const ::BNgenjet*)arg[0]);
}

static  void method_4987( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNgenjet>*)o)->pop_back)();
}

static  void method_4988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >)((((::std::vector<BNgenjet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >*)arg[0],
    *(const ::BNgenjet*)arg[1]));
  else   (((::std::vector<BNgenjet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >*)arg[0],
    *(const ::BNgenjet*)arg[1]);
}

static  void method_4989( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNgenjet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNgenjet*)arg[2]);
}

static  void method_4990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >)((((::std::vector<BNgenjet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >*)arg[0]));
  else   (((::std::vector<BNgenjet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >*)arg[0]);
}

static  void method_4991( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >)((((::std::vector<BNgenjet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >*)arg[1]));
  else   (((::std::vector<BNgenjet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNgenjet*,std::vector<BNgenjet> >*)arg[1]);
}

static  void method_4992( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNgenjet>*)o)->swap)(*(::std::vector<BNgenjet>*)arg[0]);
}

static  void method_4993( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNgenjet>*)o)->clear)();
}

static void method_newdel_760( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNgenjet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNgenjet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNgenjet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNgenjet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNgenjet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x45( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNgenjet,std::allocator<BNgenjet> >")), ::Reflex::BaseOffset< ::std::vector<BNgenjet>,::std::_Vector_base<BNgenjet,std::allocator<BNgenjet> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNgenjet> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNgenjet> >::Generate();
}

//------Dictionary for class vector<BNgenjet,std::allocator<BNgenjet> > -------------------------------
void __std__vector_BNgenjet__db_datamem(Reflex::Class*);
void __std__vector_BNgenjet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNgenjet__datamem_bld(&__std__vector_BNgenjet__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNgenjet__funcmem_bld(&__std__vector_BNgenjet__db_funcmem);
void __std__vector_BNgenjet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNgenjet>"), typeid(::std::vector<BNgenjet>), sizeof(::std::vector<BNgenjet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1824, ::Reflex::BaseOffset< ::std::vector<BNgenjet>, ::std::_Vector_base<BNgenjet,std::allocator<BNgenjet> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1748, Reflex::Literal("std::vector<BNgenjet>::_Alloc_value_type"))
  .AddTypedef(type_1824, Reflex::Literal("std::vector<BNgenjet>::_Base"))
  .AddTypedef(type_2539, Reflex::Literal("std::vector<BNgenjet>::_Tp_alloc_type"))
  .AddTypedef(type_1748, Reflex::Literal("std::vector<BNgenjet>::value_type"))
  .AddTypedef(type_4937, Reflex::Literal("std::vector<BNgenjet>::pointer"))
  .AddTypedef(type_4939, Reflex::Literal("std::vector<BNgenjet>::const_pointer"))
  .AddTypedef(type_4941, Reflex::Literal("std::vector<BNgenjet>::reference"))
  .AddTypedef(type_4943, Reflex::Literal("std::vector<BNgenjet>::const_reference"))
  .AddTypedef(type_4945, Reflex::Literal("std::vector<BNgenjet>::iterator"))
  .AddTypedef(type_4947, Reflex::Literal("std::vector<BNgenjet>::const_iterator"))
  .AddTypedef(type_2681, Reflex::Literal("std::vector<BNgenjet>::const_reverse_iterator"))
  .AddTypedef(type_2682, Reflex::Literal("std::vector<BNgenjet>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNgenjet>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNgenjet>::difference_type"))
  .AddTypedef(type_2539, Reflex::Literal("std::vector<BNgenjet>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4954, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17795), Reflex::Literal("vector"), constructor_4955, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_4943, type_17795), Reflex::Literal("vector"), constructor_4956, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17796), Reflex::Literal("vector"), constructor_4957, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4958, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_760, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x45, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNgenjet__funcmem_bld);
}

//------Delayed data member builder for class vector<BNgenjet,std::allocator<BNgenjet> > -------------------
void __std__vector_BNgenjet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNgenjet,std::allocator<BNgenjet> > -------------------
void __std__vector_BNgenjet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17797, type_17796), Reflex::Literal("operator="), operator_4959, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_4943), Reflex::Literal("assign"), method_4960, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4945), Reflex::Literal("begin"), method_4961, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4947), Reflex::Literal("begin"), method_4962, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4945), Reflex::Literal("end"), method_4963, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4947), Reflex::Literal("end"), method_4964, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_4969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_4970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_1748), Reflex::Literal("resize"), method_4971, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_4972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_4973, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_4974, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4941, type_2521), Reflex::Literal("operator[]"), operator_4975, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4943, type_2521), Reflex::Literal("operator[]"), operator_4976, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4941, type_2521), Reflex::Literal("at"), method_4978, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4943, type_2521), Reflex::Literal("at"), method_4979, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4941), Reflex::Literal("front"), method_4980, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4943), Reflex::Literal("front"), method_4981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4941), Reflex::Literal("back"), method_4982, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4943), Reflex::Literal("back"), method_4983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4937), Reflex::Literal("data"), method_4984, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4939), Reflex::Literal("data"), method_4985, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4943), Reflex::Literal("push_back"), method_4986, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_4987, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4945, type_4945, type_4943), Reflex::Literal("insert"), method_4988, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4945, type_2521, type_4943), Reflex::Literal("insert"), method_4989, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4945, type_4945), Reflex::Literal("erase"), method_4990, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4945, type_4945, type_4945), Reflex::Literal("erase"), method_4991, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17797), Reflex::Literal("swap"), method_4992, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_4993, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BNmet -------------------------------
static void destructor_5118(void*, void * o, const std::vector<void*>&, void *) {
(((::BNmet*)o)->::BNmet::~BNmet)();
}
static  void operator_5119( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNmet*)o)->operator=)(*(const ::BNmet*)arg[0]);
  else   (((::BNmet*)o)->operator=)(*(const ::BNmet*)arg[0]);
}

static void constructor_5120( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNmet(*(const ::BNmet*)arg[0]);
  else ::new(mem) ::BNmet(*(const ::BNmet*)arg[0]);
}

static void constructor_5121( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNmet(*(double*)arg[0]);
  else ::new(mem) ::BNmet(*(double*)arg[0]);
}

static void constructor_5122( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNmet();
  else ::new(mem) ::BNmet();
}

static void method_newdel_868( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNmet >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNmet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNmet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNmet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNmet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNmet -------------------------------
void __BNmet_db_datamem(Reflex::Class*);
void __BNmet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNmet_datamem_bld(&__BNmet_db_datamem);
Reflex::GenreflexMemberBuilder __BNmet_funcmem_bld(&__BNmet_db_funcmem);
void __BNmet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNmet"), typeid(::BNmet), sizeof(::BNmet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNmet"), destructor_5118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6003, type_6005), Reflex::Literal("operator="), operator_5119, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6005), Reflex::Literal("BNmet"), constructor_5120, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698), Reflex::Literal("BNmet"), constructor_5121, 0, "v", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNmet"), constructor_5122, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_868, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNmet_datamem_bld);
}

//------Delayed data member builder for class BNmet -------------------
void __BNmet_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("energy"), OffsetOf(__shadow__::__BNmet, energy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("et"), OffsetOf(__shadow__::__BNmet, et), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pt"), OffsetOf(__shadow__::__BNmet, pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("px"), OffsetOf(__shadow__::__BNmet, px), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("py"), OffsetOf(__shadow__::__BNmet, py), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eta"), OffsetOf(__shadow__::__BNmet, eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("phi"), OffsetOf(__shadow__::__BNmet, phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("Upt"), OffsetOf(__shadow__::__BNmet, Upt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("Uphi"), OffsetOf(__shadow__::__BNmet, Uphi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("NeutralEMFraction"), OffsetOf(__shadow__::__BNmet, NeutralEMFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("NeutralHadEtFraction"), OffsetOf(__shadow__::__BNmet, NeutralHadEtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ChargedEMEtFraction"), OffsetOf(__shadow__::__BNmet, ChargedEMEtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ChargedHadEtFraction"), OffsetOf(__shadow__::__BNmet, ChargedHadEtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("MuonEtFraction"), OffsetOf(__shadow__::__BNmet, MuonEtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("Type6EtFraction"), OffsetOf(__shadow__::__BNmet, Type6EtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("Type7EtFraction"), OffsetOf(__shadow__::__BNmet, Type7EtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genPT"), OffsetOf(__shadow__::__BNmet, genPT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genPhi"), OffsetOf(__shadow__::__BNmet, genPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("muonCorEx"), OffsetOf(__shadow__::__BNmet, muonCorEx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("muonCorEy"), OffsetOf(__shadow__::__BNmet, muonCorEy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("jet20CorEx"), OffsetOf(__shadow__::__BNmet, jet20CorEx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("jet20CorEy"), OffsetOf(__shadow__::__BNmet, jet20CorEy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("jet1CorEx"), OffsetOf(__shadow__::__BNmet, jet1CorEx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("jet1CorEy"), OffsetOf(__shadow__::__BNmet, jet1CorEy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("sumET"), OffsetOf(__shadow__::__BNmet, sumET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("corSumET"), OffsetOf(__shadow__::__BNmet, corSumET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("mEtSig"), OffsetOf(__shadow__::__BNmet, mEtSig), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("metSignificance"), OffsetOf(__shadow__::__BNmet, metSignificance), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("significance"), OffsetOf(__shadow__::__BNmet, significance), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("sigmaX2"), OffsetOf(__shadow__::__BNmet, sigmaX2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("sigmaY2"), OffsetOf(__shadow__::__BNmet, sigmaY2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("sigmaXY"), OffsetOf(__shadow__::__BNmet, sigmaXY), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("sigmaYX"), OffsetOf(__shadow__::__BNmet, sigmaYX), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("maxEtInEmTowers"), OffsetOf(__shadow__::__BNmet, maxEtInEmTowers), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("emEtFraction"), OffsetOf(__shadow__::__BNmet, emEtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("emEtInEB"), OffsetOf(__shadow__::__BNmet, emEtInEB), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("emEtInEE"), OffsetOf(__shadow__::__BNmet, emEtInEE), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("emEtInHF"), OffsetOf(__shadow__::__BNmet, emEtInHF), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("maxEtInHadTowers"), OffsetOf(__shadow__::__BNmet, maxEtInHadTowers), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hadEtFraction"), OffsetOf(__shadow__::__BNmet, hadEtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hadEtInHB"), OffsetOf(__shadow__::__BNmet, hadEtInHB), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hadEtInHE"), OffsetOf(__shadow__::__BNmet, hadEtInHE), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hadEtInHF"), OffsetOf(__shadow__::__BNmet, hadEtInHF), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hadEtInHO"), OffsetOf(__shadow__::__BNmet, hadEtInHO), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("UDeltaPx"), OffsetOf(__shadow__::__BNmet, UDeltaPx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("UDeltaPy"), OffsetOf(__shadow__::__BNmet, UDeltaPy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("UDeltaP"), OffsetOf(__shadow__::__BNmet, UDeltaP), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("Uscale"), OffsetOf(__shadow__::__BNmet, Uscale), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("type2corPx"), OffsetOf(__shadow__::__BNmet, type2corPx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("type2corPy"), OffsetOf(__shadow__::__BNmet, type2corPy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("T2pt"), OffsetOf(__shadow__::__BNmet, T2pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("T2px"), OffsetOf(__shadow__::__BNmet, T2px), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("T2py"), OffsetOf(__shadow__::__BNmet, T2py), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("T2phi"), OffsetOf(__shadow__::__BNmet, T2phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("T2sumET"), OffsetOf(__shadow__::__BNmet, T2sumET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfT1jet1pt"), OffsetOf(__shadow__::__BNmet, pfT1jet1pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfT1jet1phi"), OffsetOf(__shadow__::__BNmet, pfT1jet1phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfT1jet6pt"), OffsetOf(__shadow__::__BNmet, pfT1jet6pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfT1jet6phi"), OffsetOf(__shadow__::__BNmet, pfT1jet6phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfT1jet10pt"), OffsetOf(__shadow__::__BNmet, pfT1jet10pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pfT1jet10phi"), OffsetOf(__shadow__::__BNmet, pfT1jet10phi), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNmet -------------------
void __BNmet_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class BNphoton -------------------------------
static void destructor_5234(void*, void * o, const std::vector<void*>&, void *) {
(((::BNphoton*)o)->::BNphoton::~BNphoton)();
}
static  void operator_5235( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNphoton*)o)->operator=)(*(const ::BNphoton*)arg[0]);
  else   (((::BNphoton*)o)->operator=)(*(const ::BNphoton*)arg[0]);
}

static void constructor_5236( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNphoton(*(const ::BNphoton*)arg[0]);
  else ::new(mem) ::BNphoton(*(const ::BNphoton*)arg[0]);
}

static void constructor_5237( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNphoton(*(double*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::BNphoton(*(double*)arg[0],
      *(int*)arg[1]);
}

static void constructor_5238( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNphoton();
  else ::new(mem) ::BNphoton();
}

static void method_newdel_1001( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNphoton >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNphoton >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNphoton >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNphoton >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNphoton >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNphoton -------------------------------
void __BNphoton_db_datamem(Reflex::Class*);
void __BNphoton_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNphoton_datamem_bld(&__BNphoton_db_datamem);
Reflex::GenreflexMemberBuilder __BNphoton_funcmem_bld(&__BNphoton_db_funcmem);
void __BNphoton_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNphoton"), typeid(::BNphoton), sizeof(::BNphoton), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNphoton"), destructor_5234, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5371, type_5373), Reflex::Literal("operator="), operator_5235, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5373), Reflex::Literal("BNphoton"), constructor_5236, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698, type_58), Reflex::Literal("BNphoton"), constructor_5237, 0, "v;c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNphoton"), constructor_5238, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1001, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNphoton_datamem_bld);
}

//------Delayed data member builder for class BNphoton -------------------
void __BNphoton_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("energy"), OffsetOf(__shadow__::__BNphoton, energy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("et"), OffsetOf(__shadow__::__BNphoton, et), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pt"), OffsetOf(__shadow__::__BNphoton, pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("px"), OffsetOf(__shadow__::__BNphoton, px), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("py"), OffsetOf(__shadow__::__BNphoton, py), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pz"), OffsetOf(__shadow__::__BNphoton, pz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("phi"), OffsetOf(__shadow__::__BNphoton, phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eta"), OffsetOf(__shadow__::__BNphoton, eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("theta"), OffsetOf(__shadow__::__BNphoton, theta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("trackIso"), OffsetOf(__shadow__::__BNphoton, trackIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ecalIso"), OffsetOf(__shadow__::__BNphoton, ecalIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalIso"), OffsetOf(__shadow__::__BNphoton, hcalIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloIso"), OffsetOf(__shadow__::__BNphoton, caloIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("trackIsoHollowConeDR03"), OffsetOf(__shadow__::__BNphoton, trackIsoHollowConeDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("trackIsoSolidConeDR03"), OffsetOf(__shadow__::__BNphoton, trackIsoSolidConeDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ecalIsoDR03"), OffsetOf(__shadow__::__BNphoton, ecalIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalIsoDR03"), OffsetOf(__shadow__::__BNphoton, hcalIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloIsoDR03"), OffsetOf(__shadow__::__BNphoton, caloIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("trackIsoHollowConeDR04"), OffsetOf(__shadow__::__BNphoton, trackIsoHollowConeDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("trackIsoSolidConeDR04"), OffsetOf(__shadow__::__BNphoton, trackIsoSolidConeDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ecalIsoDR04"), OffsetOf(__shadow__::__BNphoton, ecalIsoDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalIsoDR04"), OffsetOf(__shadow__::__BNphoton, hcalIsoDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloIsoDR04"), OffsetOf(__shadow__::__BNphoton, caloIsoDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hadOverEm"), OffsetOf(__shadow__::__BNphoton, hadOverEm), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("sigmaEtaEta"), OffsetOf(__shadow__::__BNphoton, sigmaEtaEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("sigmaIetaIeta"), OffsetOf(__shadow__::__BNphoton, sigmaIetaIeta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("r9"), OffsetOf(__shadow__::__BNphoton, r9), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scEnergy"), OffsetOf(__shadow__::__BNphoton, scEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scRawEnergy"), OffsetOf(__shadow__::__BNphoton, scRawEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scSeedEnergy"), OffsetOf(__shadow__::__BNphoton, scSeedEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scEta"), OffsetOf(__shadow__::__BNphoton, scEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scPhi"), OffsetOf(__shadow__::__BNphoton, scPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("scZ"), OffsetOf(__shadow__::__BNphoton, scZ), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genET"), OffsetOf(__shadow__::__BNphoton, genET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genPT"), OffsetOf(__shadow__::__BNphoton, genPT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genPhi"), OffsetOf(__shadow__::__BNphoton, genPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genEta"), OffsetOf(__shadow__::__BNphoton, genEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genMotherET"), OffsetOf(__shadow__::__BNphoton, genMotherET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genMotherPT"), OffsetOf(__shadow__::__BNphoton, genMotherPT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genMotherPhi"), OffsetOf(__shadow__::__BNphoton, genMotherPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genMotherEta"), OffsetOf(__shadow__::__BNphoton, genMotherEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eMax"), OffsetOf(__shadow__::__BNphoton, eMax), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eLeft"), OffsetOf(__shadow__::__BNphoton, eLeft), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eRight"), OffsetOf(__shadow__::__BNphoton, eRight), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eTop"), OffsetOf(__shadow__::__BNphoton, eTop), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eBottom"), OffsetOf(__shadow__::__BNphoton, eBottom), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("e3x3"), OffsetOf(__shadow__::__BNphoton, e3x3), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("swissCross"), OffsetOf(__shadow__::__BNphoton, swissCross), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("seedEnergy"), OffsetOf(__shadow__::__BNphoton, seedEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("seedTime"), OffsetOf(__shadow__::__BNphoton, seedTime), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("swissCrossNoI85"), OffsetOf(__shadow__::__BNphoton, swissCrossNoI85), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("swissCrossI85"), OffsetOf(__shadow__::__BNphoton, swissCrossI85), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("E2overE9NoI85"), OffsetOf(__shadow__::__BNphoton, E2overE9NoI85), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("E2overE9I85"), OffsetOf(__shadow__::__BNphoton, E2overE9I85), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("IDTight"), OffsetOf(__shadow__::__BNphoton, IDTight), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("IDLoose"), OffsetOf(__shadow__::__BNphoton, IDLoose), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("IDLooseEM"), OffsetOf(__shadow__::__BNphoton, IDLooseEM), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genId"), OffsetOf(__shadow__::__BNphoton, genId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genCharge"), OffsetOf(__shadow__::__BNphoton, genCharge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genMotherId"), OffsetOf(__shadow__::__BNphoton, genMotherId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genMotherCharge"), OffsetOf(__shadow__::__BNphoton, genMotherCharge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isEB"), OffsetOf(__shadow__::__BNphoton, isEB), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isEE"), OffsetOf(__shadow__::__BNphoton, isEE), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isGap"), OffsetOf(__shadow__::__BNphoton, isGap), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isEBEEGap"), OffsetOf(__shadow__::__BNphoton, isEBEEGap), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isEBGap"), OffsetOf(__shadow__::__BNphoton, isEBGap), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isEEGap"), OffsetOf(__shadow__::__BNphoton, isEEGap), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("hasPixelSeed"), OffsetOf(__shadow__::__BNphoton, hasPixelSeed), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("seedRecoFlag"), OffsetOf(__shadow__::__BNphoton, seedRecoFlag), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNphoton -------------------
void __BNphoton_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class BNlepton -------------------------------
static void destructor_5322(void*, void * o, const std::vector<void*>&, void *) {
(((::BNlepton*)o)->::BNlepton::~BNlepton)();
}
static  void operator_5323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNlepton*)o)->operator=)(*(const ::BNlepton*)arg[0]);
  else   (((::BNlepton*)o)->operator=)(*(const ::BNlepton*)arg[0]);
}

static void constructor_5324( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNlepton(*(const ::BNlepton*)arg[0]);
  else ::new(mem) ::BNlepton(*(const ::BNlepton*)arg[0]);
}

static void constructor_5325( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::BNlepton(*(double*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::BNlepton(*(double*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::BNlepton(*(double*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  else ::new(mem) ::BNlepton(*(double*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::BNlepton(*(double*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  else ::new(mem) ::BNlepton(*(double*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  }
}

static void constructor_5326( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::BNlepton();
  else ::new(mem) ::BNlepton();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::BNlepton(*(int*)arg[0]);
  else ::new(mem) ::BNlepton(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::BNlepton(*(int*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::BNlepton(*(int*)arg[0],
      *(int*)arg[1]);
  }
}

static void constructor_x49( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNlepton();
  else ::new(mem) ::BNlepton();
}

static void method_newdel_1092( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNlepton >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNlepton >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNlepton >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNlepton >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNlepton >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNlepton -------------------------------
void __BNlepton_db_datamem(Reflex::Class*);
void __BNlepton_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNlepton_datamem_bld(&__BNlepton_db_datamem);
Reflex::GenreflexMemberBuilder __BNlepton_funcmem_bld(&__BNlepton_db_funcmem);
void __BNlepton_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNlepton"), typeid(::BNlepton), sizeof(::BNlepton), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNlepton"), destructor_5322, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9688, type_9690), Reflex::Literal("operator="), operator_5323, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9690), Reflex::Literal("BNlepton"), constructor_5324, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698, type_58, type_58, type_58), Reflex::Literal("BNlepton"), constructor_5325, 0, "v;c;e=0;m=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_58, type_58), Reflex::Literal("BNlepton"), constructor_5326, 0, "e=0;m=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNlepton"), constructor_x49, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1092, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNlepton_datamem_bld);
}

//------Delayed data member builder for class BNlepton -------------------
void __BNlepton_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("energy"), OffsetOf(__shadow__::__BNlepton, energy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("et"), OffsetOf(__shadow__::__BNlepton, et), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pt"), OffsetOf(__shadow__::__BNlepton, pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("px"), OffsetOf(__shadow__::__BNlepton, px), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("py"), OffsetOf(__shadow__::__BNlepton, py), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pz"), OffsetOf(__shadow__::__BNlepton, pz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("phi"), OffsetOf(__shadow__::__BNlepton, phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eta"), OffsetOf(__shadow__::__BNlepton, eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("theta"), OffsetOf(__shadow__::__BNlepton, theta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("jetDeltaR"), OffsetOf(__shadow__::__BNlepton, jetDeltaR), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("jetPtRatio"), OffsetOf(__shadow__::__BNlepton, jetPtRatio), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("jetBTagCSV"), OffsetOf(__shadow__::__BNlepton, jetBTagCSV), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("trackIso"), OffsetOf(__shadow__::__BNlepton, trackIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ecalIso"), OffsetOf(__shadow__::__BNlepton, ecalIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalIso"), OffsetOf(__shadow__::__BNlepton, hcalIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloIso"), OffsetOf(__shadow__::__BNlepton, caloIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("trackIsoDR03"), OffsetOf(__shadow__::__BNlepton, trackIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ecalIsoDR03"), OffsetOf(__shadow__::__BNlepton, ecalIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("hcalIsoDR03"), OffsetOf(__shadow__::__BNlepton, hcalIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("caloIsoDR03"), OffsetOf(__shadow__::__BNlepton, caloIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genET"), OffsetOf(__shadow__::__BNlepton, genET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genPT"), OffsetOf(__shadow__::__BNlepton, genPT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genPhi"), OffsetOf(__shadow__::__BNlepton, genPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genEta"), OffsetOf(__shadow__::__BNlepton, genEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genMotherET"), OffsetOf(__shadow__::__BNlepton, genMotherET), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genMotherPT"), OffsetOf(__shadow__::__BNlepton, genMotherPT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genMotherPhi"), OffsetOf(__shadow__::__BNlepton, genMotherPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("genMotherEta"), OffsetOf(__shadow__::__BNlepton, genMotherEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("vx"), OffsetOf(__shadow__::__BNlepton, vx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("vy"), OffsetOf(__shadow__::__BNlepton, vy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("vz"), OffsetOf(__shadow__::__BNlepton, vz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("tkNormChi2"), OffsetOf(__shadow__::__BNlepton, tkNormChi2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("tkPT"), OffsetOf(__shadow__::__BNlepton, tkPT), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("tkEta"), OffsetOf(__shadow__::__BNlepton, tkEta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("tkPhi"), OffsetOf(__shadow__::__BNlepton, tkPhi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("tkDZ"), OffsetOf(__shadow__::__BNlepton, tkDZ), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("tkDZerr"), OffsetOf(__shadow__::__BNlepton, tkDZerr), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("tkD0"), OffsetOf(__shadow__::__BNlepton, tkD0), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("tkD0bs"), OffsetOf(__shadow__::__BNlepton, tkD0bs), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("tkD0err"), OffsetOf(__shadow__::__BNlepton, tkD0err), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("correctedD0"), OffsetOf(__shadow__::__BNlepton, correctedD0), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("correctedD0Vertex"), OffsetOf(__shadow__::__BNlepton, correctedD0Vertex), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("correctedDZ"), OffsetOf(__shadow__::__BNlepton, correctedDZ), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("particleIso"), OffsetOf(__shadow__::__BNlepton, particleIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("chargedHadronIso"), OffsetOf(__shadow__::__BNlepton, chargedHadronIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("neutralHadronIso"), OffsetOf(__shadow__::__BNlepton, neutralHadronIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("photonIso"), OffsetOf(__shadow__::__BNlepton, photonIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("puChargedHadronIso"), OffsetOf(__shadow__::__BNlepton, puChargedHadronIso), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("chargedHadronIsoDR03"), OffsetOf(__shadow__::__BNlepton, chargedHadronIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("neutralHadronIsoDR03"), OffsetOf(__shadow__::__BNlepton, neutralHadronIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("photonIsoDR03"), OffsetOf(__shadow__::__BNlepton, photonIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("puChargedHadronIsoDR03"), OffsetOf(__shadow__::__BNlepton, puChargedHadronIsoDR03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("chargedHadronIsoDR04"), OffsetOf(__shadow__::__BNlepton, chargedHadronIsoDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("neutralHadronIsoDR04"), OffsetOf(__shadow__::__BNlepton, neutralHadronIsoDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("photonIsoDR04"), OffsetOf(__shadow__::__BNlepton, photonIsoDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("puChargedHadronIsoDR04"), OffsetOf(__shadow__::__BNlepton, puChargedHadronIsoDR04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("rhoPrime"), OffsetOf(__shadow__::__BNlepton, rhoPrime), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("AEffDr03"), OffsetOf(__shadow__::__BNlepton, AEffDr03), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("AEffDr04"), OffsetOf(__shadow__::__BNlepton, AEffDr04), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("IP"), OffsetOf(__shadow__::__BNlepton, IP), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("IPError"), OffsetOf(__shadow__::__BNlepton, IPError), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("SIP"), OffsetOf(__shadow__::__BNlepton, SIP), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isElectron"), OffsetOf(__shadow__::__BNlepton, isElectron), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isMuon"), OffsetOf(__shadow__::__BNlepton, isMuon), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("charge"), OffsetOf(__shadow__::__BNlepton, charge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("tkCharge"), OffsetOf(__shadow__::__BNlepton, tkCharge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genId"), OffsetOf(__shadow__::__BNlepton, genId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genCharge"), OffsetOf(__shadow__::__BNlepton, genCharge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genNumberOfMothers"), OffsetOf(__shadow__::__BNlepton, genNumberOfMothers), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genMotherId"), OffsetOf(__shadow__::__BNlepton, genMotherId), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genMotherCharge"), OffsetOf(__shadow__::__BNlepton, genMotherCharge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genMother0Id"), OffsetOf(__shadow__::__BNlepton, genMother0Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genMother1Id"), OffsetOf(__shadow__::__BNlepton, genMother1Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genGrandMother00Id"), OffsetOf(__shadow__::__BNlepton, genGrandMother00Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genGrandMother01Id"), OffsetOf(__shadow__::__BNlepton, genGrandMother01Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genGrandMother10Id"), OffsetOf(__shadow__::__BNlepton, genGrandMother10Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("genGrandMother11Id"), OffsetOf(__shadow__::__BNlepton, genGrandMother11Id), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("mcMatchID"), OffsetOf(__shadow__::__BNlepton, mcMatchID), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("mcMatchAny"), OffsetOf(__shadow__::__BNlepton, mcMatchAny), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNlepton -------------------
void __BNlepton_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class BNbxlumi -------------------------------
static void destructor_5358(void*, void * o, const std::vector<void*>&, void *) {
(((::BNbxlumi*)o)->::BNbxlumi::~BNbxlumi)();
}
static  void operator_5359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNbxlumi*)o)->operator=)(*(const ::BNbxlumi*)arg[0]);
  else   (((::BNbxlumi*)o)->operator=)(*(const ::BNbxlumi*)arg[0]);
}

static void constructor_5360( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNbxlumi(*(const ::BNbxlumi*)arg[0]);
  else ::new(mem) ::BNbxlumi(*(const ::BNbxlumi*)arg[0]);
}

static void constructor_5361( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNbxlumi(*(double*)arg[0]);
  else ::new(mem) ::BNbxlumi(*(double*)arg[0]);
}

static void constructor_5362( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNbxlumi();
  else ::new(mem) ::BNbxlumi();
}

static void method_newdel_1299( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNbxlumi >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNbxlumi >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNbxlumi >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNbxlumi >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNbxlumi >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNbxlumi -------------------------------
void __BNbxlumi_db_datamem(Reflex::Class*);
void __BNbxlumi_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNbxlumi_datamem_bld(&__BNbxlumi_db_datamem);
Reflex::GenreflexMemberBuilder __BNbxlumi_funcmem_bld(&__BNbxlumi_db_funcmem);
void __BNbxlumi_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNbxlumi"), typeid(::BNbxlumi), sizeof(::BNbxlumi), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNbxlumi"), destructor_5358, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6233, type_6235), Reflex::Literal("operator="), operator_5359, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6235), Reflex::Literal("BNbxlumi"), constructor_5360, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698), Reflex::Literal("BNbxlumi"), constructor_5361, 0, "v", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNbxlumi"), constructor_5362, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1299, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNbxlumi_datamem_bld);
}

//------Delayed data member builder for class BNbxlumi -------------------
void __BNbxlumi_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("bx_B1_now"), OffsetOf(__shadow__::__BNbxlumi, bx_B1_now), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("bx_B2_now"), OffsetOf(__shadow__::__BNbxlumi, bx_B2_now), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("bx_LUMI_now"), OffsetOf(__shadow__::__BNbxlumi, bx_LUMI_now), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNbxlumi -------------------
void __BNbxlumi_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BNphoton,std::allocator<BNphoton> > -------------------------------
static void constructor_5384( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNphoton>();
  else ::new(mem) ::std::vector<BNphoton>();
}

static void constructor_5385( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNphoton>(*(const ::std::allocator<BNphoton>*)arg[0]);
  else ::new(mem) ::std::vector<BNphoton>(*(const ::std::allocator<BNphoton>*)arg[0]);
}

static void constructor_5386( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNphoton>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNphoton>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNphoton>(*(::std::size_t*)arg[0],
      *(const ::BNphoton*)arg[1]);
  else ::new(mem) ::std::vector<BNphoton>(*(::std::size_t*)arg[0],
      *(const ::BNphoton*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNphoton>(*(::std::size_t*)arg[0],
      *(const ::BNphoton*)arg[1],
      *(const ::std::allocator<BNphoton>*)arg[2]);
  else ::new(mem) ::std::vector<BNphoton>(*(::std::size_t*)arg[0],
      *(const ::BNphoton*)arg[1],
      *(const ::std::allocator<BNphoton>*)arg[2]);
  }
}

static void constructor_5387( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNphoton>(*(const ::std::vector<BNphoton>*)arg[0]);
  else ::new(mem) ::std::vector<BNphoton>(*(const ::std::vector<BNphoton>*)arg[0]);
}

static void destructor_5388(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNphoton>*)o)->::std::vector<BNphoton>::~vector)();
}
static  void operator_5389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNphoton>*)o)->operator=)(*(const ::std::vector<BNphoton>*)arg[0]);
  else   (((::std::vector<BNphoton>*)o)->operator=)(*(const ::std::vector<BNphoton>*)arg[0]);
}

static  void method_5390( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNphoton>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNphoton*)arg[1]);
}

static  void method_5391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >)((((::std::vector<BNphoton>*)o)->begin)());
  else   (((::std::vector<BNphoton>*)o)->begin)();
}

static  void method_5392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNphoton*,std::vector<BNphoton> >)((((const ::std::vector<BNphoton>*)o)->begin)());
  else   (((const ::std::vector<BNphoton>*)o)->begin)();
}

static  void method_5393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >)((((::std::vector<BNphoton>*)o)->end)());
  else   (((::std::vector<BNphoton>*)o)->end)();
}

static  void method_5394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNphoton*,std::vector<BNphoton> >)((((const ::std::vector<BNphoton>*)o)->end)());
  else   (((const ::std::vector<BNphoton>*)o)->end)();
}

static  void method_5399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNphoton>*)o)->size)());
  else   (((const ::std::vector<BNphoton>*)o)->size)();
}

static  void method_5400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNphoton>*)o)->max_size)());
  else   (((const ::std::vector<BNphoton>*)o)->max_size)();
}

static  void method_5401( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNphoton>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNphoton>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNphoton*)arg[1]);
  }
}

static  void method_5402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNphoton>*)o)->capacity)());
  else   (((const ::std::vector<BNphoton>*)o)->capacity)();
}

static  void method_5403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNphoton>*)o)->empty)());
  else   (((const ::std::vector<BNphoton>*)o)->empty)();
}

static  void method_5404( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNphoton>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5405( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNphoton>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNphoton>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5406( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNphoton>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNphoton>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5408( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNphoton>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNphoton>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNphoton>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNphoton>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNphoton>*)o)->front)();
  else   (((::std::vector<BNphoton>*)o)->front)();
}

static  void method_5411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNphoton>*)o)->front)();
  else   (((const ::std::vector<BNphoton>*)o)->front)();
}

static  void method_5412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNphoton>*)o)->back)();
  else   (((::std::vector<BNphoton>*)o)->back)();
}

static  void method_5413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNphoton>*)o)->back)();
  else   (((const ::std::vector<BNphoton>*)o)->back)();
}

static  void method_5414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNphoton>*)o)->data)());
  else   (((::std::vector<BNphoton>*)o)->data)();
}

static  void method_5415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNphoton>*)o)->data)());
  else   (((const ::std::vector<BNphoton>*)o)->data)();
}

static  void method_5416( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNphoton>*)o)->push_back)(*(const ::BNphoton*)arg[0]);
}

static  void method_5417( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNphoton>*)o)->pop_back)();
}

static  void method_5418( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >)((((::std::vector<BNphoton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >*)arg[0],
    *(const ::BNphoton*)arg[1]));
  else   (((::std::vector<BNphoton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >*)arg[0],
    *(const ::BNphoton*)arg[1]);
}

static  void method_5419( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNphoton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNphoton*)arg[2]);
}

static  void method_5420( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >)((((::std::vector<BNphoton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >*)arg[0]));
  else   (((::std::vector<BNphoton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >*)arg[0]);
}

static  void method_5421( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >)((((::std::vector<BNphoton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >*)arg[1]));
  else   (((::std::vector<BNphoton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNphoton*,std::vector<BNphoton> >*)arg[1]);
}

static  void method_5422( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNphoton>*)o)->swap)(*(::std::vector<BNphoton>*)arg[0]);
}

static  void method_5423( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNphoton>*)o)->clear)();
}

static void method_newdel_1306( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNphoton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNphoton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNphoton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNphoton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNphoton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x53( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNphoton,std::allocator<BNphoton> >")), ::Reflex::BaseOffset< ::std::vector<BNphoton>,::std::_Vector_base<BNphoton,std::allocator<BNphoton> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x54( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNphoton> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNphoton> >::Generate();
}

//------Dictionary for class vector<BNphoton,std::allocator<BNphoton> > -------------------------------
void __std__vector_BNphoton__db_datamem(Reflex::Class*);
void __std__vector_BNphoton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNphoton__datamem_bld(&__std__vector_BNphoton__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNphoton__funcmem_bld(&__std__vector_BNphoton__db_funcmem);
void __std__vector_BNphoton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNphoton>"), typeid(::std::vector<BNphoton>), sizeof(::std::vector<BNphoton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1831, ::Reflex::BaseOffset< ::std::vector<BNphoton>, ::std::_Vector_base<BNphoton,std::allocator<BNphoton> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1001, Reflex::Literal("std::vector<BNphoton>::_Alloc_value_type"))
  .AddTypedef(type_1831, Reflex::Literal("std::vector<BNphoton>::_Base"))
  .AddTypedef(type_2546, Reflex::Literal("std::vector<BNphoton>::_Tp_alloc_type"))
  .AddTypedef(type_1001, Reflex::Literal("std::vector<BNphoton>::value_type"))
  .AddTypedef(type_5367, Reflex::Literal("std::vector<BNphoton>::pointer"))
  .AddTypedef(type_5369, Reflex::Literal("std::vector<BNphoton>::const_pointer"))
  .AddTypedef(type_5371, Reflex::Literal("std::vector<BNphoton>::reference"))
  .AddTypedef(type_5373, Reflex::Literal("std::vector<BNphoton>::const_reference"))
  .AddTypedef(type_5375, Reflex::Literal("std::vector<BNphoton>::iterator"))
  .AddTypedef(type_5377, Reflex::Literal("std::vector<BNphoton>::const_iterator"))
  .AddTypedef(type_2695, Reflex::Literal("std::vector<BNphoton>::const_reverse_iterator"))
  .AddTypedef(type_2696, Reflex::Literal("std::vector<BNphoton>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNphoton>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNphoton>::difference_type"))
  .AddTypedef(type_2546, Reflex::Literal("std::vector<BNphoton>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5384, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17844), Reflex::Literal("vector"), constructor_5385, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_5373, type_17844), Reflex::Literal("vector"), constructor_5386, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17845), Reflex::Literal("vector"), constructor_5387, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5388, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1306, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x53, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x54, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNphoton__funcmem_bld);
}

//------Delayed data member builder for class vector<BNphoton,std::allocator<BNphoton> > -------------------
void __std__vector_BNphoton__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNphoton,std::allocator<BNphoton> > -------------------
void __std__vector_BNphoton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17846, type_17845), Reflex::Literal("operator="), operator_5389, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_5373), Reflex::Literal("assign"), method_5390, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5375), Reflex::Literal("begin"), method_5391, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5377), Reflex::Literal("begin"), method_5392, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5375), Reflex::Literal("end"), method_5393, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5377), Reflex::Literal("end"), method_5394, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_5399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_5400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_1001), Reflex::Literal("resize"), method_5401, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_5402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_5403, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_5404, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5371, type_2521), Reflex::Literal("operator[]"), operator_5405, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5373, type_2521), Reflex::Literal("operator[]"), operator_5406, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5371, type_2521), Reflex::Literal("at"), method_5408, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5373, type_2521), Reflex::Literal("at"), method_5409, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5371), Reflex::Literal("front"), method_5410, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5373), Reflex::Literal("front"), method_5411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5371), Reflex::Literal("back"), method_5412, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5373), Reflex::Literal("back"), method_5413, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5367), Reflex::Literal("data"), method_5414, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5369), Reflex::Literal("data"), method_5415, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_5373), Reflex::Literal("push_back"), method_5416, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_5417, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5375, type_5375, type_5373), Reflex::Literal("insert"), method_5418, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_5375, type_2521, type_5373), Reflex::Literal("insert"), method_5419, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5375, type_5375), Reflex::Literal("erase"), method_5420, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5375, type_5375, type_5375), Reflex::Literal("erase"), method_5421, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17846), Reflex::Literal("swap"), method_5422, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_5423, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BNtau -------------------------------
static void destructor_6192(void*, void * o, const std::vector<void*>&, void *) {
(((::BNtau*)o)->::BNtau::~BNtau)();
}
static  void operator_6193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNtau*)o)->operator=)(*(const ::BNtau*)arg[0]);
  else   (((::BNtau*)o)->operator=)(*(const ::BNtau*)arg[0]);
}

static void constructor_6194( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNtau(*(const ::BNtau*)arg[0]);
  else ::new(mem) ::BNtau(*(const ::BNtau*)arg[0]);
}

static void constructor_6195( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNtau(*(double*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::BNtau(*(double*)arg[0],
      *(int*)arg[1]);
}

static void constructor_6196( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNtau();
  else ::new(mem) ::BNtau();
}

static void method_newdel_1681( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNtau >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNtau >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNtau >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNtau >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNtau >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNtau -------------------------------
void __BNtau_db_datamem(Reflex::Class*);
void __BNtau_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNtau_datamem_bld(&__BNtau_db_datamem);
Reflex::GenreflexMemberBuilder __BNtau_funcmem_bld(&__BNtau_db_funcmem);
void __BNtau_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNtau"), typeid(::BNtau), sizeof(::BNtau), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNtau"), destructor_6192, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5439, type_5441), Reflex::Literal("operator="), operator_6193, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5441), Reflex::Literal("BNtau"), constructor_6194, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698, type_58), Reflex::Literal("BNtau"), constructor_6195, 0, "v;c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNtau"), constructor_6196, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1681, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNtau_datamem_bld);
}

//------Delayed data member builder for class BNtau -------------------
void __BNtau_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("px"), OffsetOf(__shadow__::__BNtau, px), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("py"), OffsetOf(__shadow__::__BNtau, py), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pz"), OffsetOf(__shadow__::__BNtau, pz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("energy"), OffsetOf(__shadow__::__BNtau, energy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("et"), OffsetOf(__shadow__::__BNtau, et), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("pt"), OffsetOf(__shadow__::__BNtau, pt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("eta"), OffsetOf(__shadow__::__BNtau, eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("phi"), OffsetOf(__shadow__::__BNtau, phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("emFraction"), OffsetOf(__shadow__::__BNtau, emFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("leadingTrackValid"), OffsetOf(__shadow__::__BNtau, leadingTrackValid), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadingTrackPt"), OffsetOf(__shadow__::__BNtau, leadingTrackPt), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadingTrackIpVtdxy"), OffsetOf(__shadow__::__BNtau, leadingTrackIpVtdxy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadingTrackIpVtdz"), OffsetOf(__shadow__::__BNtau, leadingTrackIpVtdz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadingTrackIpVtdxyError"), OffsetOf(__shadow__::__BNtau, leadingTrackIpVtdxyError), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadingTrackIpVtdzError"), OffsetOf(__shadow__::__BNtau, leadingTrackIpVtdzError), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadingTrackVx"), OffsetOf(__shadow__::__BNtau, leadingTrackVx), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadingTrackVy"), OffsetOf(__shadow__::__BNtau, leadingTrackVy), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadingTrackVz"), OffsetOf(__shadow__::__BNtau, leadingTrackVz), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadingTrackValidHits"), OffsetOf(__shadow__::__BNtau, leadingTrackValidHits), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("leadingTrackNormChiSqrd"), OffsetOf(__shadow__::__BNtau, leadingTrackNormChiSqrd), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numProngs"), OffsetOf(__shadow__::__BNtau, numProngs), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numSignalGammas"), OffsetOf(__shadow__::__BNtau, numSignalGammas), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numSignalNeutrals"), OffsetOf(__shadow__::__BNtau, numSignalNeutrals), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("numSignalPiZeros"), OffsetOf(__shadow__::__BNtau, numSignalPiZeros), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("decayMode"), OffsetOf(__shadow__::__BNtau, decayMode), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("charge"), OffsetOf(__shadow__::__BNtau, charge), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("inTheCracks"), OffsetOf(__shadow__::__BNtau, inTheCracks), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstMuonMedium"), OffsetOf(__shadow__::__BNtau, HPSagainstMuonMedium), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronTightMVA3"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronTightMVA3), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronTightMVA2"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronTightMVA2), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyLooseIsolationMVA2"), OffsetOf(__shadow__::__BNtau, HPSbyLooseIsolationMVA2), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstMuonTight"), OffsetOf(__shadow__::__BNtau, HPSagainstMuonTight), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronMedium"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronMedium), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyTightIsolationMVA"), OffsetOf(__shadow__::__BNtau, HPSbyTightIsolationMVA), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstMuonLoose2"), OffsetOf(__shadow__::__BNtau, HPSagainstMuonLoose2), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyLooseCombinedIsolationDeltaBetaCorr"), OffsetOf(__shadow__::__BNtau, HPSbyLooseCombinedIsolationDeltaBetaCorr), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronLooseMVA3"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronLooseMVA3), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronLooseMVA2"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronLooseMVA2), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronTight"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronTight), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyVLooseCombinedIsolationDeltaBetaCorr"), OffsetOf(__shadow__::__BNtau, HPSbyVLooseCombinedIsolationDeltaBetaCorr), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronVTightMVA3"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronVTightMVA3), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronMediumMVA3"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronMediumMVA3), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronMediumMVA2"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronMediumMVA2), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronMVA"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronMVA), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstMuonLoose"), OffsetOf(__shadow__::__BNtau, HPSagainstMuonLoose), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstMuonTight2"), OffsetOf(__shadow__::__BNtau, HPSagainstMuonTight2), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyMediumCombinedIsolationDeltaBetaCorr"), OffsetOf(__shadow__::__BNtau, HPSbyMediumCombinedIsolationDeltaBetaCorr), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronVLooseMVA2"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronVLooseMVA2), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronLoose"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronLoose), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyMediumIsolationMVA"), OffsetOf(__shadow__::__BNtau, HPSbyMediumIsolationMVA), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyMediumCombinedIsolationDeltaBetaCorr3Hits"), OffsetOf(__shadow__::__BNtau, HPSbyMediumCombinedIsolationDeltaBetaCorr3Hits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyMediumIsolationMVA2"), OffsetOf(__shadow__::__BNtau, HPSbyMediumIsolationMVA2), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyTightIsolationMVA2"), OffsetOf(__shadow__::__BNtau, HPSbyTightIsolationMVA2), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronMVA2category"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronMVA2category), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronDeadECAL"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronDeadECAL), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstElectronMVA3category"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronMVA3category), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyTightCombinedIsolationDeltaBetaCorr"), OffsetOf(__shadow__::__BNtau, HPSbyTightCombinedIsolationDeltaBetaCorr), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyLooseCombinedIsolationDeltaBetaCorr3Hits"), OffsetOf(__shadow__::__BNtau, HPSbyLooseCombinedIsolationDeltaBetaCorr3Hits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSagainstMuonMedium2"), OffsetOf(__shadow__::__BNtau, HPSagainstMuonMedium2), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyLooseIsolationMVA"), OffsetOf(__shadow__::__BNtau, HPSbyLooseIsolationMVA), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSbyTightCombinedIsolationDeltaBetaCorr3Hits"), OffsetOf(__shadow__::__BNtau, HPSbyTightCombinedIsolationDeltaBetaCorr3Hits), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("HPSdecayModeFinding"), OffsetOf(__shadow__::__BNtau, HPSdecayModeFinding), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("HPSbyIsolationMVAraw"), OffsetOf(__shadow__::__BNtau, HPSbyIsolationMVAraw), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("HPSbyCombinedIsolationDeltaBetaCorrRaw3Hits"), OffsetOf(__shadow__::__BNtau, HPSbyCombinedIsolationDeltaBetaCorrRaw3Hits), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("HPSbyIsolationMVA2raw"), OffsetOf(__shadow__::__BNtau, HPSbyIsolationMVA2raw), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("HPSagainstElectronMVA2raw"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronMVA2raw), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("HPSagainstElectronMVA3raw"), OffsetOf(__shadow__::__BNtau, HPSagainstElectronMVA3raw), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("HPSbyCombinedIsolationDeltaBetaCorrRaw"), OffsetOf(__shadow__::__BNtau, HPSbyCombinedIsolationDeltaBetaCorrRaw), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNtau -------------------
void __BNtau_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BNtau,std::allocator<BNtau> > -------------------------------
static void constructor_5452( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtau>();
  else ::new(mem) ::std::vector<BNtau>();
}

static void constructor_5453( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtau>(*(const ::std::allocator<BNtau>*)arg[0]);
  else ::new(mem) ::std::vector<BNtau>(*(const ::std::allocator<BNtau>*)arg[0]);
}

static void constructor_5454( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtau>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNtau>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtau>(*(::std::size_t*)arg[0],
      *(const ::BNtau*)arg[1]);
  else ::new(mem) ::std::vector<BNtau>(*(::std::size_t*)arg[0],
      *(const ::BNtau*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtau>(*(::std::size_t*)arg[0],
      *(const ::BNtau*)arg[1],
      *(const ::std::allocator<BNtau>*)arg[2]);
  else ::new(mem) ::std::vector<BNtau>(*(::std::size_t*)arg[0],
      *(const ::BNtau*)arg[1],
      *(const ::std::allocator<BNtau>*)arg[2]);
  }
}

static void constructor_5455( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNtau>(*(const ::std::vector<BNtau>*)arg[0]);
  else ::new(mem) ::std::vector<BNtau>(*(const ::std::vector<BNtau>*)arg[0]);
}

static void destructor_5456(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNtau>*)o)->::std::vector<BNtau>::~vector)();
}
static  void operator_5457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtau>*)o)->operator=)(*(const ::std::vector<BNtau>*)arg[0]);
  else   (((::std::vector<BNtau>*)o)->operator=)(*(const ::std::vector<BNtau>*)arg[0]);
}

static  void method_5458( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtau>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNtau*)arg[1]);
}

static  void method_5459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >)((((::std::vector<BNtau>*)o)->begin)());
  else   (((::std::vector<BNtau>*)o)->begin)();
}

static  void method_5460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNtau*,std::vector<BNtau> >)((((const ::std::vector<BNtau>*)o)->begin)());
  else   (((const ::std::vector<BNtau>*)o)->begin)();
}

static  void method_5461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >)((((::std::vector<BNtau>*)o)->end)());
  else   (((::std::vector<BNtau>*)o)->end)();
}

static  void method_5462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNtau*,std::vector<BNtau> >)((((const ::std::vector<BNtau>*)o)->end)());
  else   (((const ::std::vector<BNtau>*)o)->end)();
}

static  void method_5467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNtau>*)o)->size)());
  else   (((const ::std::vector<BNtau>*)o)->size)();
}

static  void method_5468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNtau>*)o)->max_size)());
  else   (((const ::std::vector<BNtau>*)o)->max_size)();
}

static  void method_5469( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNtau>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNtau>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNtau*)arg[1]);
  }
}

static  void method_5470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNtau>*)o)->capacity)());
  else   (((const ::std::vector<BNtau>*)o)->capacity)();
}

static  void method_5471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNtau>*)o)->empty)());
  else   (((const ::std::vector<BNtau>*)o)->empty)();
}

static  void method_5472( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtau>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtau>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNtau>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5474( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtau>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNtau>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5476( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtau>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNtau>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5477( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtau>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNtau>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtau>*)o)->front)();
  else   (((::std::vector<BNtau>*)o)->front)();
}

static  void method_5479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtau>*)o)->front)();
  else   (((const ::std::vector<BNtau>*)o)->front)();
}

static  void method_5480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNtau>*)o)->back)();
  else   (((::std::vector<BNtau>*)o)->back)();
}

static  void method_5481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNtau>*)o)->back)();
  else   (((const ::std::vector<BNtau>*)o)->back)();
}

static  void method_5482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNtau>*)o)->data)());
  else   (((::std::vector<BNtau>*)o)->data)();
}

static  void method_5483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNtau>*)o)->data)());
  else   (((const ::std::vector<BNtau>*)o)->data)();
}

static  void method_5484( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtau>*)o)->push_back)(*(const ::BNtau*)arg[0]);
}

static  void method_5485( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNtau>*)o)->pop_back)();
}

static  void method_5486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >)((((::std::vector<BNtau>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >*)arg[0],
    *(const ::BNtau*)arg[1]));
  else   (((::std::vector<BNtau>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >*)arg[0],
    *(const ::BNtau*)arg[1]);
}

static  void method_5487( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtau>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNtau*)arg[2]);
}

static  void method_5488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >)((((::std::vector<BNtau>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >*)arg[0]));
  else   (((::std::vector<BNtau>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >*)arg[0]);
}

static  void method_5489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >)((((::std::vector<BNtau>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >*)arg[1]));
  else   (((::std::vector<BNtau>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNtau*,std::vector<BNtau> >*)arg[1]);
}

static  void method_5490( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNtau>*)o)->swap)(*(::std::vector<BNtau>*)arg[0]);
}

static  void method_5491( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNtau>*)o)->clear)();
}

static void method_newdel_1403( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNtau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNtau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNtau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNtau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNtau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x57( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNtau,std::allocator<BNtau> >")), ::Reflex::BaseOffset< ::std::vector<BNtau>,::std::_Vector_base<BNtau,std::allocator<BNtau> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x58( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNtau> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNtau> >::Generate();
}

//------Dictionary for class vector<BNtau,std::allocator<BNtau> > -------------------------------
void __std__vector_BNtau__db_datamem(Reflex::Class*);
void __std__vector_BNtau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNtau__datamem_bld(&__std__vector_BNtau__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNtau__funcmem_bld(&__std__vector_BNtau__db_funcmem);
void __std__vector_BNtau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNtau>"), typeid(::std::vector<BNtau>), sizeof(::std::vector<BNtau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1838, ::Reflex::BaseOffset< ::std::vector<BNtau>, ::std::_Vector_base<BNtau,std::allocator<BNtau> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1681, Reflex::Literal("std::vector<BNtau>::_Alloc_value_type"))
  .AddTypedef(type_1838, Reflex::Literal("std::vector<BNtau>::_Base"))
  .AddTypedef(type_2553, Reflex::Literal("std::vector<BNtau>::_Tp_alloc_type"))
  .AddTypedef(type_1681, Reflex::Literal("std::vector<BNtau>::value_type"))
  .AddTypedef(type_5435, Reflex::Literal("std::vector<BNtau>::pointer"))
  .AddTypedef(type_5437, Reflex::Literal("std::vector<BNtau>::const_pointer"))
  .AddTypedef(type_5439, Reflex::Literal("std::vector<BNtau>::reference"))
  .AddTypedef(type_5441, Reflex::Literal("std::vector<BNtau>::const_reference"))
  .AddTypedef(type_5443, Reflex::Literal("std::vector<BNtau>::iterator"))
  .AddTypedef(type_5445, Reflex::Literal("std::vector<BNtau>::const_iterator"))
  .AddTypedef(type_2709, Reflex::Literal("std::vector<BNtau>::const_reverse_iterator"))
  .AddTypedef(type_2710, Reflex::Literal("std::vector<BNtau>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNtau>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNtau>::difference_type"))
  .AddTypedef(type_2553, Reflex::Literal("std::vector<BNtau>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5452, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17848), Reflex::Literal("vector"), constructor_5453, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_5441, type_17848), Reflex::Literal("vector"), constructor_5454, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17849), Reflex::Literal("vector"), constructor_5455, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5456, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1403, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x57, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x58, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNtau__funcmem_bld);
}

//------Delayed data member builder for class vector<BNtau,std::allocator<BNtau> > -------------------
void __std__vector_BNtau__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNtau,std::allocator<BNtau> > -------------------
void __std__vector_BNtau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17850, type_17849), Reflex::Literal("operator="), operator_5457, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_5441), Reflex::Literal("assign"), method_5458, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5443), Reflex::Literal("begin"), method_5459, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5445), Reflex::Literal("begin"), method_5460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5443), Reflex::Literal("end"), method_5461, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5445), Reflex::Literal("end"), method_5462, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_5467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_5468, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_1681), Reflex::Literal("resize"), method_5469, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_5470, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_5471, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_5472, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5439, type_2521), Reflex::Literal("operator[]"), operator_5473, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5441, type_2521), Reflex::Literal("operator[]"), operator_5474, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5439, type_2521), Reflex::Literal("at"), method_5476, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5441, type_2521), Reflex::Literal("at"), method_5477, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5439), Reflex::Literal("front"), method_5478, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5441), Reflex::Literal("front"), method_5479, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5439), Reflex::Literal("back"), method_5480, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5441), Reflex::Literal("back"), method_5481, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5435), Reflex::Literal("data"), method_5482, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5437), Reflex::Literal("data"), method_5483, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_5441), Reflex::Literal("push_back"), method_5484, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_5485, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5443, type_5443, type_5441), Reflex::Literal("insert"), method_5486, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_5443, type_2521, type_5441), Reflex::Literal("insert"), method_5487, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5443, type_5443), Reflex::Literal("erase"), method_5488, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5443, type_5443, type_5443), Reflex::Literal("erase"), method_5489, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17850), Reflex::Literal("swap"), method_5490, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_5491, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class BNprimaryvertex -------------------------------
static void destructor_6220(void*, void * o, const std::vector<void*>&, void *) {
(((::BNprimaryvertex*)o)->::BNprimaryvertex::~BNprimaryvertex)();
}
static  void operator_6221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BNprimaryvertex*)o)->operator=)(*(const ::BNprimaryvertex*)arg[0]);
  else   (((::BNprimaryvertex*)o)->operator=)(*(const ::BNprimaryvertex*)arg[0]);
}

static void constructor_6222( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNprimaryvertex(*(const ::BNprimaryvertex*)arg[0]);
  else ::new(mem) ::BNprimaryvertex(*(const ::BNprimaryvertex*)arg[0]);
}

static void constructor_6223( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNprimaryvertex(*(double*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::BNprimaryvertex(*(double*)arg[0],
      *(int*)arg[1]);
}

static void constructor_6224( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BNprimaryvertex();
  else ::new(mem) ::BNprimaryvertex();
}

static void method_newdel_1714( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BNprimaryvertex >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BNprimaryvertex >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BNprimaryvertex >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BNprimaryvertex >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BNprimaryvertex >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BNprimaryvertex -------------------------------
void __BNprimaryvertex_db_datamem(Reflex::Class*);
void __BNprimaryvertex_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BNprimaryvertex_datamem_bld(&__BNprimaryvertex_db_datamem);
Reflex::GenreflexMemberBuilder __BNprimaryvertex_funcmem_bld(&__BNprimaryvertex_db_funcmem);
void __BNprimaryvertex_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BNprimaryvertex"), typeid(::BNprimaryvertex), sizeof(::BNprimaryvertex), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BNprimaryvertex"), destructor_6220, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5841, type_5843), Reflex::Literal("operator="), operator_6221, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5843), Reflex::Literal("BNprimaryvertex"), constructor_6222, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1698, type_58), Reflex::Literal("BNprimaryvertex"), constructor_6223, 0, "v;c", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BNprimaryvertex"), constructor_6224, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1714, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BNprimaryvertex_datamem_bld);
}

//------Delayed data member builder for class BNprimaryvertex -------------------
void __BNprimaryvertex_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1698, Reflex::Literal("x"), OffsetOf(__shadow__::__BNprimaryvertex, x), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("xError"), OffsetOf(__shadow__::__BNprimaryvertex, xError), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("y"), OffsetOf(__shadow__::__BNprimaryvertex, y), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("yError"), OffsetOf(__shadow__::__BNprimaryvertex, yError), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("z"), OffsetOf(__shadow__::__BNprimaryvertex, z), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("zError"), OffsetOf(__shadow__::__BNprimaryvertex, zError), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("rho"), OffsetOf(__shadow__::__BNprimaryvertex, rho), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("normalizedChi2"), OffsetOf(__shadow__::__BNprimaryvertex, normalizedChi2), ::Reflex::PUBLIC)
  .AddDataMember(type_1698, Reflex::Literal("ndof"), OffsetOf(__shadow__::__BNprimaryvertex, ndof), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isFake"), OffsetOf(__shadow__::__BNprimaryvertex, isFake), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isValid"), OffsetOf(__shadow__::__BNprimaryvertex, isValid), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("tracksSize"), OffsetOf(__shadow__::__BNprimaryvertex, tracksSize), ::Reflex::PUBLIC)
  .AddDataMember(type_58, Reflex::Literal("isGood"), OffsetOf(__shadow__::__BNprimaryvertex, isGood), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BNprimaryvertex -------------------
void __BNprimaryvertex_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BNprimaryvertex,std::allocator<BNprimaryvertex> > -------------------------------
static void constructor_5852( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNprimaryvertex>();
  else ::new(mem) ::std::vector<BNprimaryvertex>();
}

static void constructor_5853( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNprimaryvertex>(*(const ::std::allocator<BNprimaryvertex>*)arg[0]);
  else ::new(mem) ::std::vector<BNprimaryvertex>(*(const ::std::allocator<BNprimaryvertex>*)arg[0]);
}

static void constructor_5854( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNprimaryvertex>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNprimaryvertex>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNprimaryvertex>(*(::std::size_t*)arg[0],
      *(const ::BNprimaryvertex*)arg[1]);
  else ::new(mem) ::std::vector<BNprimaryvertex>(*(::std::size_t*)arg[0],
      *(const ::BNprimaryvertex*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNprimaryvertex>(*(::std::size_t*)arg[0],
      *(const ::BNprimaryvertex*)arg[1],
      *(const ::std::allocator<BNprimaryvertex>*)arg[2]);
  else ::new(mem) ::std::vector<BNprimaryvertex>(*(::std::size_t*)arg[0],
      *(const ::BNprimaryvertex*)arg[1],
      *(const ::std::allocator<BNprimaryvertex>*)arg[2]);
  }
}

static void constructor_5855( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNprimaryvertex>(*(const ::std::vector<BNprimaryvertex>*)arg[0]);
  else ::new(mem) ::std::vector<BNprimaryvertex>(*(const ::std::vector<BNprimaryvertex>*)arg[0]);
}

static void destructor_5856(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNprimaryvertex>*)o)->::std::vector<BNprimaryvertex>::~vector)();
}
static  void operator_5857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNprimaryvertex>*)o)->operator=)(*(const ::std::vector<BNprimaryvertex>*)arg[0]);
  else   (((::std::vector<BNprimaryvertex>*)o)->operator=)(*(const ::std::vector<BNprimaryvertex>*)arg[0]);
}

static  void method_5858( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNprimaryvertex>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNprimaryvertex*)arg[1]);
}

static  void method_5859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >)((((::std::vector<BNprimaryvertex>*)o)->begin)());
  else   (((::std::vector<BNprimaryvertex>*)o)->begin)();
}

static  void method_5860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNprimaryvertex*,std::vector<BNprimaryvertex> >)((((const ::std::vector<BNprimaryvertex>*)o)->begin)());
  else   (((const ::std::vector<BNprimaryvertex>*)o)->begin)();
}

static  void method_5861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >)((((::std::vector<BNprimaryvertex>*)o)->end)());
  else   (((::std::vector<BNprimaryvertex>*)o)->end)();
}

static  void method_5862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNprimaryvertex*,std::vector<BNprimaryvertex> >)((((const ::std::vector<BNprimaryvertex>*)o)->end)());
  else   (((const ::std::vector<BNprimaryvertex>*)o)->end)();
}

static  void method_5867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNprimaryvertex>*)o)->size)());
  else   (((const ::std::vector<BNprimaryvertex>*)o)->size)();
}

static  void method_5868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNprimaryvertex>*)o)->max_size)());
  else   (((const ::std::vector<BNprimaryvertex>*)o)->max_size)();
}

static  void method_5869( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNprimaryvertex>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNprimaryvertex>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNprimaryvertex*)arg[1]);
  }
}

static  void method_5870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNprimaryvertex>*)o)->capacity)());
  else   (((const ::std::vector<BNprimaryvertex>*)o)->capacity)();
}

static  void method_5871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNprimaryvertex>*)o)->empty)());
  else   (((const ::std::vector<BNprimaryvertex>*)o)->empty)();
}

static  void method_5872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNprimaryvertex>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNprimaryvertex>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNprimaryvertex>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNprimaryvertex>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNprimaryvertex>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5876( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNprimaryvertex>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNprimaryvertex>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNprimaryvertex>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNprimaryvertex>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNprimaryvertex>*)o)->front)();
  else   (((::std::vector<BNprimaryvertex>*)o)->front)();
}

static  void method_5879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNprimaryvertex>*)o)->front)();
  else   (((const ::std::vector<BNprimaryvertex>*)o)->front)();
}

static  void method_5880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNprimaryvertex>*)o)->back)();
  else   (((::std::vector<BNprimaryvertex>*)o)->back)();
}

static  void method_5881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNprimaryvertex>*)o)->back)();
  else   (((const ::std::vector<BNprimaryvertex>*)o)->back)();
}

static  void method_5882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNprimaryvertex>*)o)->data)());
  else   (((::std::vector<BNprimaryvertex>*)o)->data)();
}

static  void method_5883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNprimaryvertex>*)o)->data)());
  else   (((const ::std::vector<BNprimaryvertex>*)o)->data)();
}

static  void method_5884( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNprimaryvertex>*)o)->push_back)(*(const ::BNprimaryvertex*)arg[0]);
}

static  void method_5885( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNprimaryvertex>*)o)->pop_back)();
}

static  void method_5886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >)((((::std::vector<BNprimaryvertex>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >*)arg[0],
    *(const ::BNprimaryvertex*)arg[1]));
  else   (((::std::vector<BNprimaryvertex>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >*)arg[0],
    *(const ::BNprimaryvertex*)arg[1]);
}

static  void method_5887( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNprimaryvertex>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNprimaryvertex*)arg[2]);
}

static  void method_5888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >)((((::std::vector<BNprimaryvertex>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >*)arg[0]));
  else   (((::std::vector<BNprimaryvertex>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >*)arg[0]);
}

static  void method_5889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >)((((::std::vector<BNprimaryvertex>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >*)arg[1]));
  else   (((::std::vector<BNprimaryvertex>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNprimaryvertex*,std::vector<BNprimaryvertex> >*)arg[1]);
}

static  void method_5890( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNprimaryvertex>*)o)->swap)(*(::std::vector<BNprimaryvertex>*)arg[0]);
}

static  void method_5891( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNprimaryvertex>*)o)->clear)();
}

static void method_newdel_1511( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNprimaryvertex> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNprimaryvertex> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNprimaryvertex> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNprimaryvertex> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNprimaryvertex> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x61( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNprimaryvertex,std::allocator<BNprimaryvertex> >")), ::Reflex::BaseOffset< ::std::vector<BNprimaryvertex>,::std::_Vector_base<BNprimaryvertex,std::allocator<BNprimaryvertex> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x62( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNprimaryvertex> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNprimaryvertex> >::Generate();
}

//------Dictionary for class vector<BNprimaryvertex,std::allocator<BNprimaryvertex> > -------------------------------
void __std__vector_BNprimaryvertex__db_datamem(Reflex::Class*);
void __std__vector_BNprimaryvertex__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNprimaryvertex__datamem_bld(&__std__vector_BNprimaryvertex__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNprimaryvertex__funcmem_bld(&__std__vector_BNprimaryvertex__db_funcmem);
void __std__vector_BNprimaryvertex__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNprimaryvertex>"), typeid(::std::vector<BNprimaryvertex>), sizeof(::std::vector<BNprimaryvertex>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1825, ::Reflex::BaseOffset< ::std::vector<BNprimaryvertex>, ::std::_Vector_base<BNprimaryvertex,std::allocator<BNprimaryvertex> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1714, Reflex::Literal("std::vector<BNprimaryvertex>::_Alloc_value_type"))
  .AddTypedef(type_1825, Reflex::Literal("std::vector<BNprimaryvertex>::_Base"))
  .AddTypedef(type_2540, Reflex::Literal("std::vector<BNprimaryvertex>::_Tp_alloc_type"))
  .AddTypedef(type_1714, Reflex::Literal("std::vector<BNprimaryvertex>::value_type"))
  .AddTypedef(type_5837, Reflex::Literal("std::vector<BNprimaryvertex>::pointer"))
  .AddTypedef(type_5839, Reflex::Literal("std::vector<BNprimaryvertex>::const_pointer"))
  .AddTypedef(type_5841, Reflex::Literal("std::vector<BNprimaryvertex>::reference"))
  .AddTypedef(type_5843, Reflex::Literal("std::vector<BNprimaryvertex>::const_reference"))
  .AddTypedef(type_5582, Reflex::Literal("std::vector<BNprimaryvertex>::iterator"))
  .AddTypedef(type_5583, Reflex::Literal("std::vector<BNprimaryvertex>::const_iterator"))
  .AddTypedef(type_2683, Reflex::Literal("std::vector<BNprimaryvertex>::const_reverse_iterator"))
  .AddTypedef(type_2684, Reflex::Literal("std::vector<BNprimaryvertex>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNprimaryvertex>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNprimaryvertex>::difference_type"))
  .AddTypedef(type_2540, Reflex::Literal("std::vector<BNprimaryvertex>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5852, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19399), Reflex::Literal("vector"), constructor_5853, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_5843, type_19399), Reflex::Literal("vector"), constructor_5854, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19400), Reflex::Literal("vector"), constructor_5855, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5856, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1511, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x61, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x62, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNprimaryvertex__funcmem_bld);
}

//------Delayed data member builder for class vector<BNprimaryvertex,std::allocator<BNprimaryvertex> > -------------------
void __std__vector_BNprimaryvertex__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNprimaryvertex,std::allocator<BNprimaryvertex> > -------------------
void __std__vector_BNprimaryvertex__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19401, type_19400), Reflex::Literal("operator="), operator_5857, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_5843), Reflex::Literal("assign"), method_5858, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5582), Reflex::Literal("begin"), method_5859, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5583), Reflex::Literal("begin"), method_5860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5582), Reflex::Literal("end"), method_5861, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5583), Reflex::Literal("end"), method_5862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_5867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_5868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_1714), Reflex::Literal("resize"), method_5869, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_5870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_5871, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_5872, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5841, type_2521), Reflex::Literal("operator[]"), operator_5873, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5843, type_2521), Reflex::Literal("operator[]"), operator_5874, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5841, type_2521), Reflex::Literal("at"), method_5876, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5843, type_2521), Reflex::Literal("at"), method_5877, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5841), Reflex::Literal("front"), method_5878, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5843), Reflex::Literal("front"), method_5879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5841), Reflex::Literal("back"), method_5880, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5843), Reflex::Literal("back"), method_5881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5837), Reflex::Literal("data"), method_5882, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5839), Reflex::Literal("data"), method_5883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_5843), Reflex::Literal("push_back"), method_5884, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_5885, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5582, type_5582, type_5843), Reflex::Literal("insert"), method_5886, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_5582, type_2521, type_5843), Reflex::Literal("insert"), method_5887, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5582, type_5582), Reflex::Literal("erase"), method_5888, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5582, type_5582, type_5582), Reflex::Literal("erase"), method_5889, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_19401), Reflex::Literal("swap"), method_5890, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_5891, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<BNmet,std::allocator<BNmet> > -------------------------------
static void constructor_6014( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmet>();
  else ::new(mem) ::std::vector<BNmet>();
}

static void constructor_6015( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmet>(*(const ::std::allocator<BNmet>*)arg[0]);
  else ::new(mem) ::std::vector<BNmet>(*(const ::std::allocator<BNmet>*)arg[0]);
}

static void constructor_6016( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmet>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNmet>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmet>(*(::std::size_t*)arg[0],
      *(const ::BNmet*)arg[1]);
  else ::new(mem) ::std::vector<BNmet>(*(::std::size_t*)arg[0],
      *(const ::BNmet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmet>(*(::std::size_t*)arg[0],
      *(const ::BNmet*)arg[1],
      *(const ::std::allocator<BNmet>*)arg[2]);
  else ::new(mem) ::std::vector<BNmet>(*(::std::size_t*)arg[0],
      *(const ::BNmet*)arg[1],
      *(const ::std::allocator<BNmet>*)arg[2]);
  }
}

static void constructor_6017( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmet>(*(const ::std::vector<BNmet>*)arg[0]);
  else ::new(mem) ::std::vector<BNmet>(*(const ::std::vector<BNmet>*)arg[0]);
}

static void destructor_6018(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNmet>*)o)->::std::vector<BNmet>::~vector)();
}
static  void operator_6019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmet>*)o)->operator=)(*(const ::std::vector<BNmet>*)arg[0]);
  else   (((::std::vector<BNmet>*)o)->operator=)(*(const ::std::vector<BNmet>*)arg[0]);
}

static  void method_6020( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmet>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNmet*)arg[1]);
}

static  void method_6021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >)((((::std::vector<BNmet>*)o)->begin)());
  else   (((::std::vector<BNmet>*)o)->begin)();
}

static  void method_6022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNmet*,std::vector<BNmet> >)((((const ::std::vector<BNmet>*)o)->begin)());
  else   (((const ::std::vector<BNmet>*)o)->begin)();
}

static  void method_6023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >)((((::std::vector<BNmet>*)o)->end)());
  else   (((::std::vector<BNmet>*)o)->end)();
}

static  void method_6024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNmet*,std::vector<BNmet> >)((((const ::std::vector<BNmet>*)o)->end)());
  else   (((const ::std::vector<BNmet>*)o)->end)();
}

static  void method_6029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNmet>*)o)->size)());
  else   (((const ::std::vector<BNmet>*)o)->size)();
}

static  void method_6030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNmet>*)o)->max_size)());
  else   (((const ::std::vector<BNmet>*)o)->max_size)();
}

static  void method_6031( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNmet>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNmet>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNmet*)arg[1]);
  }
}

static  void method_6032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNmet>*)o)->capacity)());
  else   (((const ::std::vector<BNmet>*)o)->capacity)();
}

static  void method_6033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNmet>*)o)->empty)());
  else   (((const ::std::vector<BNmet>*)o)->empty)();
}

static  void method_6034( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmet>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6035( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNmet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6036( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNmet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNmet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6038( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNmet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6039( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNmet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNmet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmet>*)o)->front)();
  else   (((::std::vector<BNmet>*)o)->front)();
}

static  void method_6041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNmet>*)o)->front)();
  else   (((const ::std::vector<BNmet>*)o)->front)();
}

static  void method_6042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmet>*)o)->back)();
  else   (((::std::vector<BNmet>*)o)->back)();
}

static  void method_6043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNmet>*)o)->back)();
  else   (((const ::std::vector<BNmet>*)o)->back)();
}

static  void method_6044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNmet>*)o)->data)());
  else   (((::std::vector<BNmet>*)o)->data)();
}

static  void method_6045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNmet>*)o)->data)());
  else   (((const ::std::vector<BNmet>*)o)->data)();
}

static  void method_6046( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmet>*)o)->push_back)(*(const ::BNmet*)arg[0]);
}

static  void method_6047( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNmet>*)o)->pop_back)();
}

static  void method_6048( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >)((((::std::vector<BNmet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >*)arg[0],
    *(const ::BNmet*)arg[1]));
  else   (((::std::vector<BNmet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >*)arg[0],
    *(const ::BNmet*)arg[1]);
}

static  void method_6049( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNmet*)arg[2]);
}

static  void method_6050( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >)((((::std::vector<BNmet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >*)arg[0]));
  else   (((::std::vector<BNmet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >*)arg[0]);
}

static  void method_6051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >)((((::std::vector<BNmet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >*)arg[1]));
  else   (((::std::vector<BNmet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNmet*,std::vector<BNmet> >*)arg[1]);
}

static  void method_6052( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmet>*)o)->swap)(*(::std::vector<BNmet>*)arg[0]);
}

static  void method_6053( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNmet>*)o)->clear)();
}

static void method_newdel_1621( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNmet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNmet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNmet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNmet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNmet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x64( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNmet,std::allocator<BNmet> >")), ::Reflex::BaseOffset< ::std::vector<BNmet>,::std::_Vector_base<BNmet,std::allocator<BNmet> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x65( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNmet> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNmet> >::Generate();
}

//------Dictionary for class vector<BNmet,std::allocator<BNmet> > -------------------------------
void __std__vector_BNmet__db_datamem(Reflex::Class*);
void __std__vector_BNmet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNmet__datamem_bld(&__std__vector_BNmet__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNmet__funcmem_bld(&__std__vector_BNmet__db_funcmem);
void __std__vector_BNmet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNmet>"), typeid(::std::vector<BNmet>), sizeof(::std::vector<BNmet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1834, ::Reflex::BaseOffset< ::std::vector<BNmet>, ::std::_Vector_base<BNmet,std::allocator<BNmet> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_868, Reflex::Literal("std::vector<BNmet>::_Alloc_value_type"))
  .AddTypedef(type_1834, Reflex::Literal("std::vector<BNmet>::_Base"))
  .AddTypedef(type_2549, Reflex::Literal("std::vector<BNmet>::_Tp_alloc_type"))
  .AddTypedef(type_868, Reflex::Literal("std::vector<BNmet>::value_type"))
  .AddTypedef(type_5999, Reflex::Literal("std::vector<BNmet>::pointer"))
  .AddTypedef(type_6001, Reflex::Literal("std::vector<BNmet>::const_pointer"))
  .AddTypedef(type_6003, Reflex::Literal("std::vector<BNmet>::reference"))
  .AddTypedef(type_6005, Reflex::Literal("std::vector<BNmet>::const_reference"))
  .AddTypedef(type_5586, Reflex::Literal("std::vector<BNmet>::iterator"))
  .AddTypedef(type_5587, Reflex::Literal("std::vector<BNmet>::const_iterator"))
  .AddTypedef(type_2701, Reflex::Literal("std::vector<BNmet>::const_reverse_iterator"))
  .AddTypedef(type_2702, Reflex::Literal("std::vector<BNmet>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNmet>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNmet>::difference_type"))
  .AddTypedef(type_2549, Reflex::Literal("std::vector<BNmet>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6014, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20301), Reflex::Literal("vector"), constructor_6015, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_6005, type_20301), Reflex::Literal("vector"), constructor_6016, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20302), Reflex::Literal("vector"), constructor_6017, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6018, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1621, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x64, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x65, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNmet__funcmem_bld);
}

//------Delayed data member builder for class vector<BNmet,std::allocator<BNmet> > -------------------
void __std__vector_BNmet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNmet,std::allocator<BNmet> > -------------------
void __std__vector_BNmet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20303, type_20302), Reflex::Literal("operator="), operator_6019, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_6005), Reflex::Literal("assign"), method_6020, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5586), Reflex::Literal("begin"), method_6021, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5587), Reflex::Literal("begin"), method_6022, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5586), Reflex::Literal("end"), method_6023, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5587), Reflex::Literal("end"), method_6024, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_6029, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_6030, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_868), Reflex::Literal("resize"), method_6031, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_6032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_6033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_6034, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6003, type_2521), Reflex::Literal("operator[]"), operator_6035, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6005, type_2521), Reflex::Literal("operator[]"), operator_6036, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6003, type_2521), Reflex::Literal("at"), method_6038, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6005, type_2521), Reflex::Literal("at"), method_6039, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6003), Reflex::Literal("front"), method_6040, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6005), Reflex::Literal("front"), method_6041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6003), Reflex::Literal("back"), method_6042, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6005), Reflex::Literal("back"), method_6043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5999), Reflex::Literal("data"), method_6044, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6001), Reflex::Literal("data"), method_6045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_6005), Reflex::Literal("push_back"), method_6046, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_6047, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5586, type_5586, type_6005), Reflex::Literal("insert"), method_6048, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_5586, type_2521, type_6005), Reflex::Literal("insert"), method_6049, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5586, type_5586), Reflex::Literal("erase"), method_6050, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5586, type_5586, type_5586), Reflex::Literal("erase"), method_6051, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_20303), Reflex::Literal("swap"), method_6052, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_6053, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<BNbxlumi,std::allocator<BNbxlumi> > -------------------------------
static void constructor_6244( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNbxlumi>();
  else ::new(mem) ::std::vector<BNbxlumi>();
}

static void constructor_6245( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNbxlumi>(*(const ::std::allocator<BNbxlumi>*)arg[0]);
  else ::new(mem) ::std::vector<BNbxlumi>(*(const ::std::allocator<BNbxlumi>*)arg[0]);
}

static void constructor_6246( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNbxlumi>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNbxlumi>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNbxlumi>(*(::std::size_t*)arg[0],
      *(const ::BNbxlumi*)arg[1]);
  else ::new(mem) ::std::vector<BNbxlumi>(*(::std::size_t*)arg[0],
      *(const ::BNbxlumi*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNbxlumi>(*(::std::size_t*)arg[0],
      *(const ::BNbxlumi*)arg[1],
      *(const ::std::allocator<BNbxlumi>*)arg[2]);
  else ::new(mem) ::std::vector<BNbxlumi>(*(::std::size_t*)arg[0],
      *(const ::BNbxlumi*)arg[1],
      *(const ::std::allocator<BNbxlumi>*)arg[2]);
  }
}

static void constructor_6247( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNbxlumi>(*(const ::std::vector<BNbxlumi>*)arg[0]);
  else ::new(mem) ::std::vector<BNbxlumi>(*(const ::std::vector<BNbxlumi>*)arg[0]);
}

static void destructor_6248(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNbxlumi>*)o)->::std::vector<BNbxlumi>::~vector)();
}
static  void operator_6249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNbxlumi>*)o)->operator=)(*(const ::std::vector<BNbxlumi>*)arg[0]);
  else   (((::std::vector<BNbxlumi>*)o)->operator=)(*(const ::std::vector<BNbxlumi>*)arg[0]);
}

static  void method_6250( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNbxlumi>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNbxlumi*)arg[1]);
}

static  void method_6251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >)((((::std::vector<BNbxlumi>*)o)->begin)());
  else   (((::std::vector<BNbxlumi>*)o)->begin)();
}

static  void method_6252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNbxlumi*,std::vector<BNbxlumi> >)((((const ::std::vector<BNbxlumi>*)o)->begin)());
  else   (((const ::std::vector<BNbxlumi>*)o)->begin)();
}

static  void method_6253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >)((((::std::vector<BNbxlumi>*)o)->end)());
  else   (((::std::vector<BNbxlumi>*)o)->end)();
}

static  void method_6254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNbxlumi*,std::vector<BNbxlumi> >)((((const ::std::vector<BNbxlumi>*)o)->end)());
  else   (((const ::std::vector<BNbxlumi>*)o)->end)();
}

static  void method_6259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNbxlumi>*)o)->size)());
  else   (((const ::std::vector<BNbxlumi>*)o)->size)();
}

static  void method_6260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNbxlumi>*)o)->max_size)());
  else   (((const ::std::vector<BNbxlumi>*)o)->max_size)();
}

static  void method_6261( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNbxlumi>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNbxlumi>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNbxlumi*)arg[1]);
  }
}

static  void method_6262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNbxlumi>*)o)->capacity)());
  else   (((const ::std::vector<BNbxlumi>*)o)->capacity)();
}

static  void method_6263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNbxlumi>*)o)->empty)());
  else   (((const ::std::vector<BNbxlumi>*)o)->empty)();
}

static  void method_6264( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNbxlumi>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNbxlumi>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNbxlumi>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNbxlumi>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNbxlumi>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6268( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNbxlumi>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNbxlumi>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNbxlumi>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNbxlumi>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNbxlumi>*)o)->front)();
  else   (((::std::vector<BNbxlumi>*)o)->front)();
}

static  void method_6271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNbxlumi>*)o)->front)();
  else   (((const ::std::vector<BNbxlumi>*)o)->front)();
}

static  void method_6272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNbxlumi>*)o)->back)();
  else   (((::std::vector<BNbxlumi>*)o)->back)();
}

static  void method_6273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNbxlumi>*)o)->back)();
  else   (((const ::std::vector<BNbxlumi>*)o)->back)();
}

static  void method_6274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNbxlumi>*)o)->data)());
  else   (((::std::vector<BNbxlumi>*)o)->data)();
}

static  void method_6275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNbxlumi>*)o)->data)());
  else   (((const ::std::vector<BNbxlumi>*)o)->data)();
}

static  void method_6276( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNbxlumi>*)o)->push_back)(*(const ::BNbxlumi*)arg[0]);
}

static  void method_6277( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNbxlumi>*)o)->pop_back)();
}

static  void method_6278( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >)((((::std::vector<BNbxlumi>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >*)arg[0],
    *(const ::BNbxlumi*)arg[1]));
  else   (((::std::vector<BNbxlumi>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >*)arg[0],
    *(const ::BNbxlumi*)arg[1]);
}

static  void method_6279( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNbxlumi>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNbxlumi*)arg[2]);
}

static  void method_6280( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >)((((::std::vector<BNbxlumi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >*)arg[0]));
  else   (((::std::vector<BNbxlumi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >*)arg[0]);
}

static  void method_6281( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >)((((::std::vector<BNbxlumi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >*)arg[1]));
  else   (((::std::vector<BNbxlumi>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNbxlumi*,std::vector<BNbxlumi> >*)arg[1]);
}

static  void method_6282( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNbxlumi>*)o)->swap)(*(::std::vector<BNbxlumi>*)arg[0]);
}

static  void method_6283( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNbxlumi>*)o)->clear)();
}

static void method_newdel_1723( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNbxlumi> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNbxlumi> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNbxlumi> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNbxlumi> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNbxlumi> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x67( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNbxlumi,std::allocator<BNbxlumi> >")), ::Reflex::BaseOffset< ::std::vector<BNbxlumi>,::std::_Vector_base<BNbxlumi,std::allocator<BNbxlumi> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x68( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNbxlumi> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNbxlumi> >::Generate();
}

//------Dictionary for class vector<BNbxlumi,std::allocator<BNbxlumi> > -------------------------------
void __std__vector_BNbxlumi__db_datamem(Reflex::Class*);
void __std__vector_BNbxlumi__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNbxlumi__datamem_bld(&__std__vector_BNbxlumi__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNbxlumi__funcmem_bld(&__std__vector_BNbxlumi__db_funcmem);
void __std__vector_BNbxlumi__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNbxlumi>"), typeid(::std::vector<BNbxlumi>), sizeof(::std::vector<BNbxlumi>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1840, ::Reflex::BaseOffset< ::std::vector<BNbxlumi>, ::std::_Vector_base<BNbxlumi,std::allocator<BNbxlumi> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1299, Reflex::Literal("std::vector<BNbxlumi>::_Alloc_value_type"))
  .AddTypedef(type_1840, Reflex::Literal("std::vector<BNbxlumi>::_Base"))
  .AddTypedef(type_2555, Reflex::Literal("std::vector<BNbxlumi>::_Tp_alloc_type"))
  .AddTypedef(type_1299, Reflex::Literal("std::vector<BNbxlumi>::value_type"))
  .AddTypedef(type_6229, Reflex::Literal("std::vector<BNbxlumi>::pointer"))
  .AddTypedef(type_6231, Reflex::Literal("std::vector<BNbxlumi>::const_pointer"))
  .AddTypedef(type_6233, Reflex::Literal("std::vector<BNbxlumi>::reference"))
  .AddTypedef(type_6235, Reflex::Literal("std::vector<BNbxlumi>::const_reference"))
  .AddTypedef(type_5590, Reflex::Literal("std::vector<BNbxlumi>::iterator"))
  .AddTypedef(type_5591, Reflex::Literal("std::vector<BNbxlumi>::const_iterator"))
  .AddTypedef(type_2713, Reflex::Literal("std::vector<BNbxlumi>::const_reverse_iterator"))
  .AddTypedef(type_2714, Reflex::Literal("std::vector<BNbxlumi>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNbxlumi>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNbxlumi>::difference_type"))
  .AddTypedef(type_2555, Reflex::Literal("std::vector<BNbxlumi>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6244, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20632), Reflex::Literal("vector"), constructor_6245, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_6235, type_20632), Reflex::Literal("vector"), constructor_6246, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20633), Reflex::Literal("vector"), constructor_6247, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6248, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1723, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x67, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x68, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNbxlumi__funcmem_bld);
}

//------Delayed data member builder for class vector<BNbxlumi,std::allocator<BNbxlumi> > -------------------
void __std__vector_BNbxlumi__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNbxlumi,std::allocator<BNbxlumi> > -------------------
void __std__vector_BNbxlumi__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20634, type_20633), Reflex::Literal("operator="), operator_6249, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_6235), Reflex::Literal("assign"), method_6250, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5590), Reflex::Literal("begin"), method_6251, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5591), Reflex::Literal("begin"), method_6252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5590), Reflex::Literal("end"), method_6253, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5591), Reflex::Literal("end"), method_6254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_6259, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_6260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_1299), Reflex::Literal("resize"), method_6261, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_6262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_6263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_6264, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6233, type_2521), Reflex::Literal("operator[]"), operator_6265, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6235, type_2521), Reflex::Literal("operator[]"), operator_6266, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6233, type_2521), Reflex::Literal("at"), method_6268, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6235, type_2521), Reflex::Literal("at"), method_6269, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6233), Reflex::Literal("front"), method_6270, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6235), Reflex::Literal("front"), method_6271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6233), Reflex::Literal("back"), method_6272, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6235), Reflex::Literal("back"), method_6273, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6229), Reflex::Literal("data"), method_6274, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6231), Reflex::Literal("data"), method_6275, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_6235), Reflex::Literal("push_back"), method_6276, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_6277, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5590, type_5590, type_6235), Reflex::Literal("insert"), method_6278, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_5590, type_2521, type_6235), Reflex::Literal("insert"), method_6279, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5590, type_5590), Reflex::Literal("erase"), method_6280, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5590, type_5590, type_5590), Reflex::Literal("erase"), method_6281, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_20634), Reflex::Literal("swap"), method_6282, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_6283, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<BNmcparticle,std::allocator<BNmcparticle> > -------------------------------
static void constructor_6310( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmcparticle>();
  else ::new(mem) ::std::vector<BNmcparticle>();
}

static void constructor_6311( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmcparticle>(*(const ::std::allocator<BNmcparticle>*)arg[0]);
  else ::new(mem) ::std::vector<BNmcparticle>(*(const ::std::allocator<BNmcparticle>*)arg[0]);
}

static void constructor_6312( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmcparticle>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNmcparticle>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmcparticle>(*(::std::size_t*)arg[0],
      *(const ::BNmcparticle*)arg[1]);
  else ::new(mem) ::std::vector<BNmcparticle>(*(::std::size_t*)arg[0],
      *(const ::BNmcparticle*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmcparticle>(*(::std::size_t*)arg[0],
      *(const ::BNmcparticle*)arg[1],
      *(const ::std::allocator<BNmcparticle>*)arg[2]);
  else ::new(mem) ::std::vector<BNmcparticle>(*(::std::size_t*)arg[0],
      *(const ::BNmcparticle*)arg[1],
      *(const ::std::allocator<BNmcparticle>*)arg[2]);
  }
}

static void constructor_6313( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNmcparticle>(*(const ::std::vector<BNmcparticle>*)arg[0]);
  else ::new(mem) ::std::vector<BNmcparticle>(*(const ::std::vector<BNmcparticle>*)arg[0]);
}

static void destructor_6314(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNmcparticle>*)o)->::std::vector<BNmcparticle>::~vector)();
}
static  void operator_6315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmcparticle>*)o)->operator=)(*(const ::std::vector<BNmcparticle>*)arg[0]);
  else   (((::std::vector<BNmcparticle>*)o)->operator=)(*(const ::std::vector<BNmcparticle>*)arg[0]);
}

static  void method_6316( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmcparticle>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNmcparticle*)arg[1]);
}

static  void method_6317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >)((((::std::vector<BNmcparticle>*)o)->begin)());
  else   (((::std::vector<BNmcparticle>*)o)->begin)();
}

static  void method_6318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNmcparticle*,std::vector<BNmcparticle> >)((((const ::std::vector<BNmcparticle>*)o)->begin)());
  else   (((const ::std::vector<BNmcparticle>*)o)->begin)();
}

static  void method_6319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >)((((::std::vector<BNmcparticle>*)o)->end)());
  else   (((::std::vector<BNmcparticle>*)o)->end)();
}

static  void method_6320( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNmcparticle*,std::vector<BNmcparticle> >)((((const ::std::vector<BNmcparticle>*)o)->end)());
  else   (((const ::std::vector<BNmcparticle>*)o)->end)();
}

static  void method_6325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNmcparticle>*)o)->size)());
  else   (((const ::std::vector<BNmcparticle>*)o)->size)();
}

static  void method_6326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNmcparticle>*)o)->max_size)());
  else   (((const ::std::vector<BNmcparticle>*)o)->max_size)();
}

static  void method_6327( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNmcparticle>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNmcparticle>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNmcparticle*)arg[1]);
  }
}

static  void method_6328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNmcparticle>*)o)->capacity)());
  else   (((const ::std::vector<BNmcparticle>*)o)->capacity)();
}

static  void method_6329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNmcparticle>*)o)->empty)());
  else   (((const ::std::vector<BNmcparticle>*)o)->empty)();
}

static  void method_6330( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmcparticle>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6331( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmcparticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNmcparticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6332( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNmcparticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNmcparticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6334( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmcparticle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNmcparticle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNmcparticle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNmcparticle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmcparticle>*)o)->front)();
  else   (((::std::vector<BNmcparticle>*)o)->front)();
}

static  void method_6337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNmcparticle>*)o)->front)();
  else   (((const ::std::vector<BNmcparticle>*)o)->front)();
}

static  void method_6338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNmcparticle>*)o)->back)();
  else   (((::std::vector<BNmcparticle>*)o)->back)();
}

static  void method_6339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNmcparticle>*)o)->back)();
  else   (((const ::std::vector<BNmcparticle>*)o)->back)();
}

static  void method_6340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNmcparticle>*)o)->data)());
  else   (((::std::vector<BNmcparticle>*)o)->data)();
}

static  void method_6341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNmcparticle>*)o)->data)());
  else   (((const ::std::vector<BNmcparticle>*)o)->data)();
}

static  void method_6342( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmcparticle>*)o)->push_back)(*(const ::BNmcparticle*)arg[0]);
}

static  void method_6343( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNmcparticle>*)o)->pop_back)();
}

static  void method_6344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >)((((::std::vector<BNmcparticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >*)arg[0],
    *(const ::BNmcparticle*)arg[1]));
  else   (((::std::vector<BNmcparticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >*)arg[0],
    *(const ::BNmcparticle*)arg[1]);
}

static  void method_6345( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmcparticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNmcparticle*)arg[2]);
}

static  void method_6346( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >)((((::std::vector<BNmcparticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >*)arg[0]));
  else   (((::std::vector<BNmcparticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >*)arg[0]);
}

static  void method_6347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >)((((::std::vector<BNmcparticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >*)arg[1]));
  else   (((::std::vector<BNmcparticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNmcparticle*,std::vector<BNmcparticle> >*)arg[1]);
}

static  void method_6348( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNmcparticle>*)o)->swap)(*(::std::vector<BNmcparticle>*)arg[0]);
}

static  void method_6349( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNmcparticle>*)o)->clear)();
}

static void method_newdel_1726( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNmcparticle> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNmcparticle> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNmcparticle> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNmcparticle> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNmcparticle> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x70( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNmcparticle,std::allocator<BNmcparticle> >")), ::Reflex::BaseOffset< ::std::vector<BNmcparticle>,::std::_Vector_base<BNmcparticle,std::allocator<BNmcparticle> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x71( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNmcparticle> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNmcparticle> >::Generate();
}

//------Dictionary for class vector<BNmcparticle,std::allocator<BNmcparticle> > -------------------------------
void __std__vector_BNmcparticle__db_datamem(Reflex::Class*);
void __std__vector_BNmcparticle__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNmcparticle__datamem_bld(&__std__vector_BNmcparticle__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNmcparticle__funcmem_bld(&__std__vector_BNmcparticle__db_funcmem);
void __std__vector_BNmcparticle__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNmcparticle>"), typeid(::std::vector<BNmcparticle>), sizeof(::std::vector<BNmcparticle>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1835, ::Reflex::BaseOffset< ::std::vector<BNmcparticle>, ::std::_Vector_base<BNmcparticle,std::allocator<BNmcparticle> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_111, Reflex::Literal("std::vector<BNmcparticle>::_Alloc_value_type"))
  .AddTypedef(type_1835, Reflex::Literal("std::vector<BNmcparticle>::_Base"))
  .AddTypedef(type_2550, Reflex::Literal("std::vector<BNmcparticle>::_Tp_alloc_type"))
  .AddTypedef(type_111, Reflex::Literal("std::vector<BNmcparticle>::value_type"))
  .AddTypedef(type_6295, Reflex::Literal("std::vector<BNmcparticle>::pointer"))
  .AddTypedef(type_6297, Reflex::Literal("std::vector<BNmcparticle>::const_pointer"))
  .AddTypedef(type_6299, Reflex::Literal("std::vector<BNmcparticle>::reference"))
  .AddTypedef(type_6301, Reflex::Literal("std::vector<BNmcparticle>::const_reference"))
  .AddTypedef(type_5588, Reflex::Literal("std::vector<BNmcparticle>::iterator"))
  .AddTypedef(type_5589, Reflex::Literal("std::vector<BNmcparticle>::const_iterator"))
  .AddTypedef(type_2703, Reflex::Literal("std::vector<BNmcparticle>::const_reverse_iterator"))
  .AddTypedef(type_2704, Reflex::Literal("std::vector<BNmcparticle>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNmcparticle>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNmcparticle>::difference_type"))
  .AddTypedef(type_2550, Reflex::Literal("std::vector<BNmcparticle>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6310, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20636), Reflex::Literal("vector"), constructor_6311, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_6301, type_20636), Reflex::Literal("vector"), constructor_6312, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20637), Reflex::Literal("vector"), constructor_6313, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6314, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1726, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x70, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x71, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNmcparticle__funcmem_bld);
}

//------Delayed data member builder for class vector<BNmcparticle,std::allocator<BNmcparticle> > -------------------
void __std__vector_BNmcparticle__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNmcparticle,std::allocator<BNmcparticle> > -------------------
void __std__vector_BNmcparticle__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20638, type_20637), Reflex::Literal("operator="), operator_6315, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_6301), Reflex::Literal("assign"), method_6316, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5588), Reflex::Literal("begin"), method_6317, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5589), Reflex::Literal("begin"), method_6318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5588), Reflex::Literal("end"), method_6319, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5589), Reflex::Literal("end"), method_6320, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_6325, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_6326, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_111), Reflex::Literal("resize"), method_6327, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_6328, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_6329, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_6330, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6299, type_2521), Reflex::Literal("operator[]"), operator_6331, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6301, type_2521), Reflex::Literal("operator[]"), operator_6332, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6299, type_2521), Reflex::Literal("at"), method_6334, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6301, type_2521), Reflex::Literal("at"), method_6335, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6299), Reflex::Literal("front"), method_6336, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6301), Reflex::Literal("front"), method_6337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6299), Reflex::Literal("back"), method_6338, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6301), Reflex::Literal("back"), method_6339, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6295), Reflex::Literal("data"), method_6340, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6297), Reflex::Literal("data"), method_6341, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_6301), Reflex::Literal("push_back"), method_6342, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_6343, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5588, type_5588, type_6301), Reflex::Literal("insert"), method_6344, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_5588, type_2521, type_6301), Reflex::Literal("insert"), method_6345, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5588, type_5588), Reflex::Literal("erase"), method_6346, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5588, type_5588, type_5588), Reflex::Literal("erase"), method_6347, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_20638), Reflex::Literal("swap"), method_6348, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_6349, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<BNlepton,std::allocator<BNlepton> > -------------------------------
static void constructor_9699( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNlepton>();
  else ::new(mem) ::std::vector<BNlepton>();
}

static void constructor_9700( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNlepton>(*(const ::std::allocator<BNlepton>*)arg[0]);
  else ::new(mem) ::std::vector<BNlepton>(*(const ::std::allocator<BNlepton>*)arg[0]);
}

static void constructor_9701( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNlepton>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BNlepton>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNlepton>(*(::std::size_t*)arg[0],
      *(const ::BNlepton*)arg[1]);
  else ::new(mem) ::std::vector<BNlepton>(*(::std::size_t*)arg[0],
      *(const ::BNlepton*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNlepton>(*(::std::size_t*)arg[0],
      *(const ::BNlepton*)arg[1],
      *(const ::std::allocator<BNlepton>*)arg[2]);
  else ::new(mem) ::std::vector<BNlepton>(*(::std::size_t*)arg[0],
      *(const ::BNlepton*)arg[1],
      *(const ::std::allocator<BNlepton>*)arg[2]);
  }
}

static void constructor_9702( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BNlepton>(*(const ::std::vector<BNlepton>*)arg[0]);
  else ::new(mem) ::std::vector<BNlepton>(*(const ::std::vector<BNlepton>*)arg[0]);
}

static void destructor_9703(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BNlepton>*)o)->::std::vector<BNlepton>::~vector)();
}
static  void operator_9704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNlepton>*)o)->operator=)(*(const ::std::vector<BNlepton>*)arg[0]);
  else   (((::std::vector<BNlepton>*)o)->operator=)(*(const ::std::vector<BNlepton>*)arg[0]);
}

static  void method_9705( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNlepton>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BNlepton*)arg[1]);
}

static  void method_9706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >)((((::std::vector<BNlepton>*)o)->begin)());
  else   (((::std::vector<BNlepton>*)o)->begin)();
}

static  void method_9707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNlepton*,std::vector<BNlepton> >)((((const ::std::vector<BNlepton>*)o)->begin)());
  else   (((const ::std::vector<BNlepton>*)o)->begin)();
}

static  void method_9708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >)((((::std::vector<BNlepton>*)o)->end)());
  else   (((::std::vector<BNlepton>*)o)->end)();
}

static  void method_9709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BNlepton*,std::vector<BNlepton> >)((((const ::std::vector<BNlepton>*)o)->end)());
  else   (((const ::std::vector<BNlepton>*)o)->end)();
}

static  void method_9714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNlepton>*)o)->size)());
  else   (((const ::std::vector<BNlepton>*)o)->size)();
}

static  void method_9715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNlepton>*)o)->max_size)());
  else   (((const ::std::vector<BNlepton>*)o)->max_size)();
}

static  void method_9716( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BNlepton>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BNlepton>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BNlepton*)arg[1]);
  }
}

static  void method_9717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BNlepton>*)o)->capacity)());
  else   (((const ::std::vector<BNlepton>*)o)->capacity)();
}

static  void method_9718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BNlepton>*)o)->empty)());
  else   (((const ::std::vector<BNlepton>*)o)->empty)();
}

static  void method_9719( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNlepton>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_9720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNlepton>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNlepton>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_9721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNlepton>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNlepton>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_9723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNlepton>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BNlepton>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9724( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNlepton>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BNlepton>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_9725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNlepton>*)o)->front)();
  else   (((::std::vector<BNlepton>*)o)->front)();
}

static  void method_9726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNlepton>*)o)->front)();
  else   (((const ::std::vector<BNlepton>*)o)->front)();
}

static  void method_9727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BNlepton>*)o)->back)();
  else   (((::std::vector<BNlepton>*)o)->back)();
}

static  void method_9728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BNlepton>*)o)->back)();
  else   (((const ::std::vector<BNlepton>*)o)->back)();
}

static  void method_9729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BNlepton>*)o)->data)());
  else   (((::std::vector<BNlepton>*)o)->data)();
}

static  void method_9730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BNlepton>*)o)->data)());
  else   (((const ::std::vector<BNlepton>*)o)->data)();
}

static  void method_9731( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNlepton>*)o)->push_back)(*(const ::BNlepton*)arg[0]);
}

static  void method_9732( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNlepton>*)o)->pop_back)();
}

static  void method_9733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >)((((::std::vector<BNlepton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >*)arg[0],
    *(const ::BNlepton*)arg[1]));
  else   (((::std::vector<BNlepton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >*)arg[0],
    *(const ::BNlepton*)arg[1]);
}

static  void method_9734( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNlepton>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BNlepton*)arg[2]);
}

static  void method_9735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >)((((::std::vector<BNlepton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >*)arg[0]));
  else   (((::std::vector<BNlepton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >*)arg[0]);
}

static  void method_9736( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >)((((::std::vector<BNlepton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >*)arg[1]));
  else   (((::std::vector<BNlepton>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BNlepton*,std::vector<BNlepton> >*)arg[1]);
}

static  void method_9737( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BNlepton>*)o)->swap)(*(::std::vector<BNlepton>*)arg[0]);
}

static  void method_9738( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BNlepton>*)o)->clear)();
}

static void method_newdel_2315( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BNlepton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BNlepton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BNlepton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BNlepton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BNlepton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x73( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BNlepton,std::allocator<BNlepton> >")), ::Reflex::BaseOffset< ::std::vector<BNlepton>,::std::_Vector_base<BNlepton,std::allocator<BNlepton> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x74( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BNlepton> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BNlepton> >::Generate();
}

//------Dictionary for class vector<BNlepton,std::allocator<BNlepton> > -------------------------------
void __std__vector_BNlepton__db_datamem(Reflex::Class*);
void __std__vector_BNlepton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BNlepton__datamem_bld(&__std__vector_BNlepton__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BNlepton__funcmem_bld(&__std__vector_BNlepton__db_funcmem);
void __std__vector_BNlepton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BNlepton>"), typeid(::std::vector<BNlepton>), sizeof(::std::vector<BNlepton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1832, ::Reflex::BaseOffset< ::std::vector<BNlepton>, ::std::_Vector_base<BNlepton,std::allocator<BNlepton> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1092, Reflex::Literal("std::vector<BNlepton>::_Alloc_value_type"))
  .AddTypedef(type_1832, Reflex::Literal("std::vector<BNlepton>::_Base"))
  .AddTypedef(type_2547, Reflex::Literal("std::vector<BNlepton>::_Tp_alloc_type"))
  .AddTypedef(type_1092, Reflex::Literal("std::vector<BNlepton>::value_type"))
  .AddTypedef(type_9684, Reflex::Literal("std::vector<BNlepton>::pointer"))
  .AddTypedef(type_9686, Reflex::Literal("std::vector<BNlepton>::const_pointer"))
  .AddTypedef(type_9688, Reflex::Literal("std::vector<BNlepton>::reference"))
  .AddTypedef(type_9690, Reflex::Literal("std::vector<BNlepton>::const_reference"))
  .AddTypedef(type_5584, Reflex::Literal("std::vector<BNlepton>::iterator"))
  .AddTypedef(type_5585, Reflex::Literal("std::vector<BNlepton>::const_iterator"))
  .AddTypedef(type_2697, Reflex::Literal("std::vector<BNlepton>::const_reverse_iterator"))
  .AddTypedef(type_2698, Reflex::Literal("std::vector<BNlepton>::reverse_iterator"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<BNlepton>::size_type"))
  .AddTypedef(type_2421, Reflex::Literal("std::vector<BNlepton>::difference_type"))
  .AddTypedef(type_2547, Reflex::Literal("std::vector<BNlepton>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_9699, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20762), Reflex::Literal("vector"), constructor_9700, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2521, type_9690, type_20762), Reflex::Literal("vector"), constructor_9701, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21537), Reflex::Literal("vector"), constructor_9702, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_9703, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2315, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x73, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x74, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BNlepton__funcmem_bld);
}

//------Delayed data member builder for class vector<BNlepton,std::allocator<BNlepton> > -------------------
void __std__vector_BNlepton__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BNlepton,std::allocator<BNlepton> > -------------------
void __std__vector_BNlepton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21538, type_21537), Reflex::Literal("operator="), operator_9704, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_9690), Reflex::Literal("assign"), method_9705, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5584), Reflex::Literal("begin"), method_9706, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5585), Reflex::Literal("begin"), method_9707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5584), Reflex::Literal("end"), method_9708, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5585), Reflex::Literal("end"), method_9709, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("size"), method_9714, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("max_size"), method_9715, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521, type_1092), Reflex::Literal("resize"), method_9716, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2521), Reflex::Literal("capacity"), method_9717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("empty"), method_9718, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_2521), Reflex::Literal("reserve"), method_9719, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9688, type_2521), Reflex::Literal("operator[]"), operator_9720, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9690, type_2521), Reflex::Literal("operator[]"), operator_9721, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9688, type_2521), Reflex::Literal("at"), method_9723, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9690, type_2521), Reflex::Literal("at"), method_9724, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9688), Reflex::Literal("front"), method_9725, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9690), Reflex::Literal("front"), method_9726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9688), Reflex::Literal("back"), method_9727, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9690), Reflex::Literal("back"), method_9728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9684), Reflex::Literal("data"), method_9729, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9686), Reflex::Literal("data"), method_9730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_9690), Reflex::Literal("push_back"), method_9731, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("pop_back"), method_9732, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5584, type_5584, type_9690), Reflex::Literal("insert"), method_9733, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_5584, type_2521, type_9690), Reflex::Literal("insert"), method_9734, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5584, type_5584), Reflex::Literal("erase"), method_9735, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5584, type_5584, type_5584), Reflex::Literal("erase"), method_9736, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_21538), Reflex::Literal("swap"), method_9737, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827), Reflex::Literal("clear"), method_9738, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<std::vector<BNgenjet, std::allocator<BNgenjet> > > -------------------------------
static void constructor_16508( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNgenjet> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNgenjet> >();
}

static void constructor_16509( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNgenjet> >(*(::std::auto_ptr<std::vector<BNgenjet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNgenjet> >(*(::std::auto_ptr<std::vector<BNgenjet> >*)arg[0]);
}

static void destructor_16510(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNgenjet> >*)o)->::edm::Wrapper<std::vector<BNgenjet> >::~Wrapper)();
}
static  void method_16511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->product)();
}

static  void operator_16512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->operator->)();
}

static  void method_16513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNgenjet> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNgenjet> >*)o)->productTypeInfo)();
}

static  void method_16514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNgenjet> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNgenjet> >*)o)->typeInfo)();
}

static void constructor_16515( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNgenjet> >((::std::vector<BNgenjet>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNgenjet> >((::std::vector<BNgenjet>*)arg[0]);
}

static  void method_16516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNgenjet> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNgenjet> >*)o)->getInterface)();
}

static  void method_16517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16518( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16519( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->dynamicTypeInfo)();
}

static  void method_16521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->isPresent)();
}

static  void method_16522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNgenjet> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4047( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNgenjet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNgenjet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNgenjet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNgenjet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNgenjet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNgenjet, std::allocator<BNgenjet> > > -------------------------------
void __edm__Wrapper_std__vector_BNgenjet_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNgenjet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNgenjet_s__datamem_bld(&__edm__Wrapper_std__vector_BNgenjet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNgenjet_s__funcmem_bld(&__edm__Wrapper_std__vector_BNgenjet_s__db_funcmem);
void __edm__Wrapper_std__vector_BNgenjet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNgenjet> >"), typeid(::edm::Wrapper<std::vector<BNgenjet> >), sizeof(::edm::Wrapper<std::vector<BNgenjet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_760, Reflex::Literal("edm::Wrapper<std::vector<BNgenjet> >::value_type"))
  .AddTypedef(type_760, Reflex::Literal("edm::Wrapper<std::vector<BNgenjet> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16508, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2062), Reflex::Literal("Wrapper"), constructor_16509, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16510, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25742), Reflex::Literal("Wrapper"), constructor_16515, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4047, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNgenjet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNgenjet_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNgenjet, std::allocator<BNgenjet> > > -------------------
void __edm__Wrapper_std__vector_BNgenjet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNgenjet_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_760, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNgenjet_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNgenjet, std::allocator<BNgenjet> > > -------------------
void __edm__Wrapper_std__vector_BNgenjet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25741), Reflex::Literal("product"), method_16511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25741), Reflex::Literal("operator->"), operator_16512, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16513, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16514, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25743), Reflex::Literal("getInterface"), method_16516, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16517, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16518, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16519, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16520, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNgenjet> -------------------------------
static void constructor_16529( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNgenjet>();
  else ::new(mem) ::edm::Wrapper<BNgenjet>();
}

static void constructor_16530( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNgenjet>(*(::std::auto_ptr<BNgenjet>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNgenjet>(*(::std::auto_ptr<BNgenjet>*)arg[0]);
}

static void destructor_16531(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNgenjet>*)o)->::edm::Wrapper<BNgenjet>::~Wrapper)();
}
static  void method_16532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNgenjet>*)o)->product)());
  else   (((const ::edm::Wrapper<BNgenjet>*)o)->product)();
}

static  void operator_16533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNgenjet>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNgenjet>*)o)->operator->)();
}

static  void method_16534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNgenjet>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNgenjet>*)o)->productTypeInfo)();
}

static  void method_16535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNgenjet>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNgenjet>*)o)->typeInfo)();
}

static void constructor_16536( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNgenjet>((::BNgenjet*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNgenjet>((::BNgenjet*)arg[0]);
}

static  void method_16537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNgenjet>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNgenjet>*)o)->getInterface)();
}

static  void method_16538( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNgenjet>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16539( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNgenjet>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16540( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNgenjet>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNgenjet>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNgenjet>*)o)->dynamicTypeInfo)();
}

static  void method_16542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNgenjet>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNgenjet>*)o)->isPresent)();
}

static  void method_16543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNgenjet>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNgenjet>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4048( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNgenjet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNgenjet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNgenjet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNgenjet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNgenjet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNgenjet> -------------------------------
void __edm__Wrapper_BNgenjet__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNgenjet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNgenjet__datamem_bld(&__edm__Wrapper_BNgenjet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNgenjet__funcmem_bld(&__edm__Wrapper_BNgenjet__db_funcmem);
void __edm__Wrapper_BNgenjet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNgenjet>"), typeid(::edm::Wrapper<BNgenjet>), sizeof(::edm::Wrapper<BNgenjet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNgenjet>")
  .AddTypedef(type_1748, Reflex::Literal("edm::Wrapper<BNgenjet>::value_type"))
  .AddTypedef(type_1748, Reflex::Literal("edm::Wrapper<BNgenjet>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16529, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2063), Reflex::Literal("Wrapper"), constructor_16530, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16531, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4937), Reflex::Literal("Wrapper"), constructor_16536, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4048, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNgenjet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNgenjet__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNgenjet> -------------------
void __edm__Wrapper_BNgenjet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNgenjet_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1748, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNgenjet_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNgenjet> -------------------
void __edm__Wrapper_BNgenjet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4939), Reflex::Literal("product"), method_16532, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4939), Reflex::Literal("operator->"), operator_16533, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16534, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16535, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25746), Reflex::Literal("getInterface"), method_16537, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16538, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16539, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16540, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNprimaryvertex, std::allocator<BNprimaryvertex> > > -------------------------------
static void constructor_16550( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNprimaryvertex> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNprimaryvertex> >();
}

static void constructor_16551( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNprimaryvertex> >(*(::std::auto_ptr<std::vector<BNprimaryvertex> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNprimaryvertex> >(*(::std::auto_ptr<std::vector<BNprimaryvertex> >*)arg[0]);
}

static void destructor_16552(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->::edm::Wrapper<std::vector<BNprimaryvertex> >::~Wrapper)();
}
static  void method_16553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->product)();
}

static  void operator_16554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->operator->)();
}

static  void method_16555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->productTypeInfo)();
}

static  void method_16556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->typeInfo)();
}

static void constructor_16557( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNprimaryvertex> >((::std::vector<BNprimaryvertex>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNprimaryvertex> >((::std::vector<BNprimaryvertex>*)arg[0]);
}

static  void method_16558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->getInterface)();
}

static  void method_16559( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16560( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16561( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->dynamicTypeInfo)();
}

static  void method_16563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->isPresent)();
}

static  void method_16564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNprimaryvertex> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4049( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNprimaryvertex> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNprimaryvertex> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNprimaryvertex> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNprimaryvertex> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNprimaryvertex> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNprimaryvertex, std::allocator<BNprimaryvertex> > > -------------------------------
void __edm__Wrapper_std__vector_BNprimaryvertex_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNprimaryvertex_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNprimaryvertex_s__datamem_bld(&__edm__Wrapper_std__vector_BNprimaryvertex_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNprimaryvertex_s__funcmem_bld(&__edm__Wrapper_std__vector_BNprimaryvertex_s__db_funcmem);
void __edm__Wrapper_std__vector_BNprimaryvertex_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNprimaryvertex> >"), typeid(::edm::Wrapper<std::vector<BNprimaryvertex> >), sizeof(::edm::Wrapper<std::vector<BNprimaryvertex> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1511, Reflex::Literal("edm::Wrapper<std::vector<BNprimaryvertex> >::value_type"))
  .AddTypedef(type_1511, Reflex::Literal("edm::Wrapper<std::vector<BNprimaryvertex> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16550, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2064), Reflex::Literal("Wrapper"), constructor_16551, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16552, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25750), Reflex::Literal("Wrapper"), constructor_16557, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4049, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNprimaryvertex_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNprimaryvertex_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNprimaryvertex, std::allocator<BNprimaryvertex> > > -------------------
void __edm__Wrapper_std__vector_BNprimaryvertex_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNprimaryvertex_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1511, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNprimaryvertex_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNprimaryvertex, std::allocator<BNprimaryvertex> > > -------------------
void __edm__Wrapper_std__vector_BNprimaryvertex_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25749), Reflex::Literal("product"), method_16553, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25749), Reflex::Literal("operator->"), operator_16554, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16555, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16556, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25751), Reflex::Literal("getInterface"), method_16558, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16559, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16560, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16561, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16562, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16563, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNprimaryvertex> -------------------------------
static void constructor_16571( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNprimaryvertex>();
  else ::new(mem) ::edm::Wrapper<BNprimaryvertex>();
}

static void constructor_16572( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNprimaryvertex>(*(::std::auto_ptr<BNprimaryvertex>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNprimaryvertex>(*(::std::auto_ptr<BNprimaryvertex>*)arg[0]);
}

static void destructor_16573(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNprimaryvertex>*)o)->::edm::Wrapper<BNprimaryvertex>::~Wrapper)();
}
static  void method_16574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNprimaryvertex>*)o)->product)());
  else   (((const ::edm::Wrapper<BNprimaryvertex>*)o)->product)();
}

static  void operator_16575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNprimaryvertex>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNprimaryvertex>*)o)->operator->)();
}

static  void method_16576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNprimaryvertex>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNprimaryvertex>*)o)->productTypeInfo)();
}

static  void method_16577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNprimaryvertex>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNprimaryvertex>*)o)->typeInfo)();
}

static void constructor_16578( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNprimaryvertex>((::BNprimaryvertex*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNprimaryvertex>((::BNprimaryvertex*)arg[0]);
}

static  void method_16579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNprimaryvertex>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNprimaryvertex>*)o)->getInterface)();
}

static  void method_16580( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNprimaryvertex>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16581( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNprimaryvertex>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16582( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNprimaryvertex>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNprimaryvertex>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNprimaryvertex>*)o)->dynamicTypeInfo)();
}

static  void method_16584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNprimaryvertex>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNprimaryvertex>*)o)->isPresent)();
}

static  void method_16585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNprimaryvertex>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNprimaryvertex>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4050( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNprimaryvertex> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNprimaryvertex> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNprimaryvertex> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNprimaryvertex> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNprimaryvertex> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNprimaryvertex> -------------------------------
void __edm__Wrapper_BNprimaryvertex__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNprimaryvertex__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNprimaryvertex__datamem_bld(&__edm__Wrapper_BNprimaryvertex__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNprimaryvertex__funcmem_bld(&__edm__Wrapper_BNprimaryvertex__db_funcmem);
void __edm__Wrapper_BNprimaryvertex__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNprimaryvertex>"), typeid(::edm::Wrapper<BNprimaryvertex>), sizeof(::edm::Wrapper<BNprimaryvertex>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNprimaryvertex>")
  .AddTypedef(type_1714, Reflex::Literal("edm::Wrapper<BNprimaryvertex>::value_type"))
  .AddTypedef(type_1714, Reflex::Literal("edm::Wrapper<BNprimaryvertex>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16571, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2065), Reflex::Literal("Wrapper"), constructor_16572, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16573, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5837), Reflex::Literal("Wrapper"), constructor_16578, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4050, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNprimaryvertex__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNprimaryvertex__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNprimaryvertex> -------------------
void __edm__Wrapper_BNprimaryvertex__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNprimaryvertex_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1714, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNprimaryvertex_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNprimaryvertex> -------------------
void __edm__Wrapper_BNprimaryvertex__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5839), Reflex::Literal("product"), method_16574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5839), Reflex::Literal("operator->"), operator_16575, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16576, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16577, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25754), Reflex::Literal("getInterface"), method_16579, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16580, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16581, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16582, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16583, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16584, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNtrigobj, std::allocator<BNtrigobj> > > -------------------------------
static void constructor_16592( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNtrigobj> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNtrigobj> >();
}

static void constructor_16593( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNtrigobj> >(*(::std::auto_ptr<std::vector<BNtrigobj> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNtrigobj> >(*(::std::auto_ptr<std::vector<BNtrigobj> >*)arg[0]);
}

static void destructor_16594(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNtrigobj> >*)o)->::edm::Wrapper<std::vector<BNtrigobj> >::~Wrapper)();
}
static  void method_16595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->product)();
}

static  void operator_16596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->operator->)();
}

static  void method_16597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNtrigobj> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNtrigobj> >*)o)->productTypeInfo)();
}

static  void method_16598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNtrigobj> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNtrigobj> >*)o)->typeInfo)();
}

static void constructor_16599( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNtrigobj> >((::std::vector<BNtrigobj>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNtrigobj> >((::std::vector<BNtrigobj>*)arg[0]);
}

static  void method_16600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNtrigobj> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNtrigobj> >*)o)->getInterface)();
}

static  void method_16601( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16603( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->dynamicTypeInfo)();
}

static  void method_16605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->isPresent)();
}

static  void method_16606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNtrigobj> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4051( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrigobj> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrigobj> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrigobj> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrigobj> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrigobj> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNtrigobj, std::allocator<BNtrigobj> > > -------------------------------
void __edm__Wrapper_std__vector_BNtrigobj_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNtrigobj_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNtrigobj_s__datamem_bld(&__edm__Wrapper_std__vector_BNtrigobj_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNtrigobj_s__funcmem_bld(&__edm__Wrapper_std__vector_BNtrigobj_s__db_funcmem);
void __edm__Wrapper_std__vector_BNtrigobj_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNtrigobj> >"), typeid(::edm::Wrapper<std::vector<BNtrigobj> >), sizeof(::edm::Wrapper<std::vector<BNtrigobj> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_140, Reflex::Literal("edm::Wrapper<std::vector<BNtrigobj> >::value_type"))
  .AddTypedef(type_140, Reflex::Literal("edm::Wrapper<std::vector<BNtrigobj> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16592, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2066), Reflex::Literal("Wrapper"), constructor_16593, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16594, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25758), Reflex::Literal("Wrapper"), constructor_16599, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4051, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNtrigobj_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNtrigobj_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNtrigobj, std::allocator<BNtrigobj> > > -------------------
void __edm__Wrapper_std__vector_BNtrigobj_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNtrigobj_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_140, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNtrigobj_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNtrigobj, std::allocator<BNtrigobj> > > -------------------
void __edm__Wrapper_std__vector_BNtrigobj_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25757), Reflex::Literal("product"), method_16595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25757), Reflex::Literal("operator->"), operator_16596, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16597, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16598, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25759), Reflex::Literal("getInterface"), method_16600, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16601, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16602, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16603, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16604, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNtrigobj> -------------------------------
static void constructor_16613( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNtrigobj>();
  else ::new(mem) ::edm::Wrapper<BNtrigobj>();
}

static void constructor_16614( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNtrigobj>(*(::std::auto_ptr<BNtrigobj>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNtrigobj>(*(::std::auto_ptr<BNtrigobj>*)arg[0]);
}

static void destructor_16615(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNtrigobj>*)o)->::edm::Wrapper<BNtrigobj>::~Wrapper)();
}
static  void method_16616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNtrigobj>*)o)->product)());
  else   (((const ::edm::Wrapper<BNtrigobj>*)o)->product)();
}

static  void operator_16617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNtrigobj>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNtrigobj>*)o)->operator->)();
}

static  void method_16618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNtrigobj>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNtrigobj>*)o)->productTypeInfo)();
}

static  void method_16619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNtrigobj>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNtrigobj>*)o)->typeInfo)();
}

static void constructor_16620( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNtrigobj>((::BNtrigobj*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNtrigobj>((::BNtrigobj*)arg[0]);
}

static  void method_16621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNtrigobj>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNtrigobj>*)o)->getInterface)();
}

static  void method_16622( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNtrigobj>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16623( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNtrigobj>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16624( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNtrigobj>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNtrigobj>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNtrigobj>*)o)->dynamicTypeInfo)();
}

static  void method_16626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNtrigobj>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNtrigobj>*)o)->isPresent)();
}

static  void method_16627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNtrigobj>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNtrigobj>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4052( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrigobj> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrigobj> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrigobj> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrigobj> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrigobj> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNtrigobj> -------------------------------
void __edm__Wrapper_BNtrigobj__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNtrigobj__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNtrigobj__datamem_bld(&__edm__Wrapper_BNtrigobj__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNtrigobj__funcmem_bld(&__edm__Wrapper_BNtrigobj__db_funcmem);
void __edm__Wrapper_BNtrigobj__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNtrigobj>"), typeid(::edm::Wrapper<BNtrigobj>), sizeof(::edm::Wrapper<BNtrigobj>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNtrigobj>")
  .AddTypedef(type_196, Reflex::Literal("edm::Wrapper<BNtrigobj>::value_type"))
  .AddTypedef(type_196, Reflex::Literal("edm::Wrapper<BNtrigobj>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16613, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2067), Reflex::Literal("Wrapper"), constructor_16614, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16615, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3120), Reflex::Literal("Wrapper"), constructor_16620, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4052, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNtrigobj__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNtrigobj__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNtrigobj> -------------------
void __edm__Wrapper_BNtrigobj__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNtrigobj_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_196, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNtrigobj_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNtrigobj> -------------------
void __edm__Wrapper_BNtrigobj__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3122), Reflex::Literal("product"), method_16616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3122), Reflex::Literal("operator->"), operator_16617, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16618, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16619, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25762), Reflex::Literal("getInterface"), method_16621, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16622, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16623, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16624, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16625, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16626, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16627, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNskimbit, std::allocator<BNskimbit> > > -------------------------------
static void constructor_16634( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNskimbit> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNskimbit> >();
}

static void constructor_16635( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNskimbit> >(*(::std::auto_ptr<std::vector<BNskimbit> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNskimbit> >(*(::std::auto_ptr<std::vector<BNskimbit> >*)arg[0]);
}

static void destructor_16636(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNskimbit> >*)o)->::edm::Wrapper<std::vector<BNskimbit> >::~Wrapper)();
}
static  void method_16637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->product)();
}

static  void operator_16638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->operator->)();
}

static  void method_16639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNskimbit> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNskimbit> >*)o)->productTypeInfo)();
}

static  void method_16640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNskimbit> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNskimbit> >*)o)->typeInfo)();
}

static void constructor_16641( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNskimbit> >((::std::vector<BNskimbit>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNskimbit> >((::std::vector<BNskimbit>*)arg[0]);
}

static  void method_16642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNskimbit> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNskimbit> >*)o)->getInterface)();
}

static  void method_16643( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16644( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16645( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->dynamicTypeInfo)();
}

static  void method_16647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->isPresent)();
}

static  void method_16648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNskimbit> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4053( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNskimbit> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNskimbit> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNskimbit> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNskimbit> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNskimbit> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNskimbit, std::allocator<BNskimbit> > > -------------------------------
void __edm__Wrapper_std__vector_BNskimbit_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNskimbit_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNskimbit_s__datamem_bld(&__edm__Wrapper_std__vector_BNskimbit_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNskimbit_s__funcmem_bld(&__edm__Wrapper_std__vector_BNskimbit_s__db_funcmem);
void __edm__Wrapper_std__vector_BNskimbit_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNskimbit> >"), typeid(::edm::Wrapper<std::vector<BNskimbit> >), sizeof(::edm::Wrapper<std::vector<BNskimbit> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_125, Reflex::Literal("edm::Wrapper<std::vector<BNskimbit> >::value_type"))
  .AddTypedef(type_125, Reflex::Literal("edm::Wrapper<std::vector<BNskimbit> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16634, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2068), Reflex::Literal("Wrapper"), constructor_16635, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16636, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25766), Reflex::Literal("Wrapper"), constructor_16641, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4053, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNskimbit_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNskimbit_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNskimbit, std::allocator<BNskimbit> > > -------------------
void __edm__Wrapper_std__vector_BNskimbit_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNskimbit_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_125, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNskimbit_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNskimbit, std::allocator<BNskimbit> > > -------------------
void __edm__Wrapper_std__vector_BNskimbit_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25765), Reflex::Literal("product"), method_16637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25765), Reflex::Literal("operator->"), operator_16638, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16639, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16640, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25767), Reflex::Literal("getInterface"), method_16642, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16643, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16644, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16645, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16646, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNskimbit> -------------------------------
static void constructor_16655( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNskimbit>();
  else ::new(mem) ::edm::Wrapper<BNskimbit>();
}

static void constructor_16656( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNskimbit>(*(::std::auto_ptr<BNskimbit>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNskimbit>(*(::std::auto_ptr<BNskimbit>*)arg[0]);
}

static void destructor_16657(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNskimbit>*)o)->::edm::Wrapper<BNskimbit>::~Wrapper)();
}
static  void method_16658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNskimbit>*)o)->product)());
  else   (((const ::edm::Wrapper<BNskimbit>*)o)->product)();
}

static  void operator_16659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNskimbit>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNskimbit>*)o)->operator->)();
}

static  void method_16660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNskimbit>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNskimbit>*)o)->productTypeInfo)();
}

static  void method_16661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNskimbit>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNskimbit>*)o)->typeInfo)();
}

static void constructor_16662( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNskimbit>((::BNskimbit*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNskimbit>((::BNskimbit*)arg[0]);
}

static  void method_16663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNskimbit>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNskimbit>*)o)->getInterface)();
}

static  void method_16664( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNskimbit>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16665( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNskimbit>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNskimbit>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNskimbit>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNskimbit>*)o)->dynamicTypeInfo)();
}

static  void method_16668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNskimbit>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNskimbit>*)o)->isPresent)();
}

static  void method_16669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNskimbit>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNskimbit>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4054( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNskimbit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNskimbit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNskimbit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNskimbit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNskimbit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNskimbit> -------------------------------
void __edm__Wrapper_BNskimbit__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNskimbit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNskimbit__datamem_bld(&__edm__Wrapper_BNskimbit__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNskimbit__funcmem_bld(&__edm__Wrapper_BNskimbit__db_funcmem);
void __edm__Wrapper_BNskimbit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNskimbit>"), typeid(::edm::Wrapper<BNskimbit>), sizeof(::edm::Wrapper<BNskimbit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNskimbit>")
  .AddTypedef(type_891, Reflex::Literal("edm::Wrapper<BNskimbit>::value_type"))
  .AddTypedef(type_891, Reflex::Literal("edm::Wrapper<BNskimbit>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16655, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2069), Reflex::Literal("Wrapper"), constructor_16656, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16657, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3050), Reflex::Literal("Wrapper"), constructor_16662, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4054, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNskimbit__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNskimbit__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNskimbit> -------------------
void __edm__Wrapper_BNskimbit__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNskimbit_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_891, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNskimbit_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNskimbit> -------------------
void __edm__Wrapper_BNskimbit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("product"), method_16658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("operator->"), operator_16659, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16660, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16661, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25770), Reflex::Literal("getInterface"), method_16663, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16664, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16665, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16666, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16667, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16668, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNtrigger, std::allocator<BNtrigger> > > -------------------------------
static void constructor_16676( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNtrigger> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNtrigger> >();
}

static void constructor_16677( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNtrigger> >(*(::std::auto_ptr<std::vector<BNtrigger> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNtrigger> >(*(::std::auto_ptr<std::vector<BNtrigger> >*)arg[0]);
}

static void destructor_16678(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNtrigger> >*)o)->::edm::Wrapper<std::vector<BNtrigger> >::~Wrapper)();
}
static  void method_16679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->product)();
}

static  void operator_16680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->operator->)();
}

static  void method_16681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNtrigger> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNtrigger> >*)o)->productTypeInfo)();
}

static  void method_16682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNtrigger> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNtrigger> >*)o)->typeInfo)();
}

static void constructor_16683( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNtrigger> >((::std::vector<BNtrigger>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNtrigger> >((::std::vector<BNtrigger>*)arg[0]);
}

static  void method_16684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNtrigger> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNtrigger> >*)o)->getInterface)();
}

static  void method_16685( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16686( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16687( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->dynamicTypeInfo)();
}

static  void method_16689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->isPresent)();
}

static  void method_16690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNtrigger> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4055( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrigger> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrigger> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrigger> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrigger> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrigger> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNtrigger, std::allocator<BNtrigger> > > -------------------------------
void __edm__Wrapper_std__vector_BNtrigger_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNtrigger_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNtrigger_s__datamem_bld(&__edm__Wrapper_std__vector_BNtrigger_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNtrigger_s__funcmem_bld(&__edm__Wrapper_std__vector_BNtrigger_s__db_funcmem);
void __edm__Wrapper_std__vector_BNtrigger_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNtrigger> >"), typeid(::edm::Wrapper<std::vector<BNtrigger> >), sizeof(::edm::Wrapper<std::vector<BNtrigger> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_186, Reflex::Literal("edm::Wrapper<std::vector<BNtrigger> >::value_type"))
  .AddTypedef(type_186, Reflex::Literal("edm::Wrapper<std::vector<BNtrigger> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16676, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2070), Reflex::Literal("Wrapper"), constructor_16677, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16678, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25774), Reflex::Literal("Wrapper"), constructor_16683, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4055, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNtrigger_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNtrigger_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNtrigger, std::allocator<BNtrigger> > > -------------------
void __edm__Wrapper_std__vector_BNtrigger_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNtrigger_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_186, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNtrigger_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNtrigger, std::allocator<BNtrigger> > > -------------------
void __edm__Wrapper_std__vector_BNtrigger_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25773), Reflex::Literal("product"), method_16679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25773), Reflex::Literal("operator->"), operator_16680, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16681, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16682, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25775), Reflex::Literal("getInterface"), method_16684, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16685, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16686, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16687, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16689, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNtrigger> -------------------------------
static void constructor_16697( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNtrigger>();
  else ::new(mem) ::edm::Wrapper<BNtrigger>();
}

static void constructor_16698( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNtrigger>(*(::std::auto_ptr<BNtrigger>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNtrigger>(*(::std::auto_ptr<BNtrigger>*)arg[0]);
}

static void destructor_16699(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNtrigger>*)o)->::edm::Wrapper<BNtrigger>::~Wrapper)();
}
static  void method_16700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNtrigger>*)o)->product)());
  else   (((const ::edm::Wrapper<BNtrigger>*)o)->product)();
}

static  void operator_16701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNtrigger>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNtrigger>*)o)->operator->)();
}

static  void method_16702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNtrigger>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNtrigger>*)o)->productTypeInfo)();
}

static  void method_16703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNtrigger>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNtrigger>*)o)->typeInfo)();
}

static void constructor_16704( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNtrigger>((::BNtrigger*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNtrigger>((::BNtrigger*)arg[0]);
}

static  void method_16705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNtrigger>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNtrigger>*)o)->getInterface)();
}

static  void method_16706( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNtrigger>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16707( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNtrigger>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16708( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNtrigger>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNtrigger>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNtrigger>*)o)->dynamicTypeInfo)();
}

static  void method_16710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNtrigger>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNtrigger>*)o)->isPresent)();
}

static  void method_16711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNtrigger>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNtrigger>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4056( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrigger> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrigger> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrigger> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrigger> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrigger> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNtrigger> -------------------------------
void __edm__Wrapper_BNtrigger__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNtrigger__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNtrigger__datamem_bld(&__edm__Wrapper_BNtrigger__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNtrigger__funcmem_bld(&__edm__Wrapper_BNtrigger__db_funcmem);
void __edm__Wrapper_BNtrigger__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNtrigger>"), typeid(::edm::Wrapper<BNtrigger>), sizeof(::edm::Wrapper<BNtrigger>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNtrigger>")
  .AddTypedef(type_796, Reflex::Literal("edm::Wrapper<BNtrigger>::value_type"))
  .AddTypedef(type_796, Reflex::Literal("edm::Wrapper<BNtrigger>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16697, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2071), Reflex::Literal("Wrapper"), constructor_16698, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16699, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3271), Reflex::Literal("Wrapper"), constructor_16704, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4056, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNtrigger__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNtrigger__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNtrigger> -------------------
void __edm__Wrapper_BNtrigger__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNtrigger_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_796, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNtrigger_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNtrigger> -------------------
void __edm__Wrapper_BNtrigger__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3273), Reflex::Literal("product"), method_16700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3273), Reflex::Literal("operator->"), operator_16701, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16702, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16703, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25778), Reflex::Literal("getInterface"), method_16705, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16706, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16707, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16708, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16709, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16710, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNtrack, std::allocator<BNtrack> > > -------------------------------
static void constructor_16718( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNtrack> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNtrack> >();
}

static void constructor_16719( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNtrack> >(*(::std::auto_ptr<std::vector<BNtrack> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNtrack> >(*(::std::auto_ptr<std::vector<BNtrack> >*)arg[0]);
}

static void destructor_16720(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNtrack> >*)o)->::edm::Wrapper<std::vector<BNtrack> >::~Wrapper)();
}
static  void method_16721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->product)();
}

static  void operator_16722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->operator->)();
}

static  void method_16723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNtrack> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNtrack> >*)o)->productTypeInfo)();
}

static  void method_16724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNtrack> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNtrack> >*)o)->typeInfo)();
}

static void constructor_16725( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNtrack> >((::std::vector<BNtrack>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNtrack> >((::std::vector<BNtrack>*)arg[0]);
}

static  void method_16726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNtrack> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNtrack> >*)o)->getInterface)();
}

static  void method_16727( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16728( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->dynamicTypeInfo)();
}

static  void method_16731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->isPresent)();
}

static  void method_16732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNtrack> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4057( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrack> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrack> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrack> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrack> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtrack> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNtrack, std::allocator<BNtrack> > > -------------------------------
void __edm__Wrapper_std__vector_BNtrack_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNtrack_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNtrack_s__datamem_bld(&__edm__Wrapper_std__vector_BNtrack_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNtrack_s__funcmem_bld(&__edm__Wrapper_std__vector_BNtrack_s__db_funcmem);
void __edm__Wrapper_std__vector_BNtrack_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNtrack> >"), typeid(::edm::Wrapper<std::vector<BNtrack> >), sizeof(::edm::Wrapper<std::vector<BNtrack> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_171, Reflex::Literal("edm::Wrapper<std::vector<BNtrack> >::value_type"))
  .AddTypedef(type_171, Reflex::Literal("edm::Wrapper<std::vector<BNtrack> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16718, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2072), Reflex::Literal("Wrapper"), constructor_16719, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16720, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25782), Reflex::Literal("Wrapper"), constructor_16725, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4057, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNtrack_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNtrack_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNtrack, std::allocator<BNtrack> > > -------------------
void __edm__Wrapper_std__vector_BNtrack_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNtrack_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_171, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNtrack_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNtrack, std::allocator<BNtrack> > > -------------------
void __edm__Wrapper_std__vector_BNtrack_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25781), Reflex::Literal("product"), method_16721, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25781), Reflex::Literal("operator->"), operator_16722, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16723, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16724, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25783), Reflex::Literal("getInterface"), method_16726, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16727, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16728, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16729, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNtrack> -------------------------------
static void constructor_16739( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNtrack>();
  else ::new(mem) ::edm::Wrapper<BNtrack>();
}

static void constructor_16740( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNtrack>(*(::std::auto_ptr<BNtrack>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNtrack>(*(::std::auto_ptr<BNtrack>*)arg[0]);
}

static void destructor_16741(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNtrack>*)o)->::edm::Wrapper<BNtrack>::~Wrapper)();
}
static  void method_16742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNtrack>*)o)->product)());
  else   (((const ::edm::Wrapper<BNtrack>*)o)->product)();
}

static  void operator_16743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNtrack>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNtrack>*)o)->operator->)();
}

static  void method_16744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNtrack>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNtrack>*)o)->productTypeInfo)();
}

static  void method_16745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNtrack>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNtrack>*)o)->typeInfo)();
}

static void constructor_16746( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNtrack>((::BNtrack*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNtrack>((::BNtrack*)arg[0]);
}

static  void method_16747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNtrack>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNtrack>*)o)->getInterface)();
}

static  void method_16748( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNtrack>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16749( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNtrack>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16750( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNtrack>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNtrack>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNtrack>*)o)->dynamicTypeInfo)();
}

static  void method_16752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNtrack>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNtrack>*)o)->isPresent)();
}

static  void method_16753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNtrack>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNtrack>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4058( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrack> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrack> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrack> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrack> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtrack> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNtrack> -------------------------------
void __edm__Wrapper_BNtrack__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNtrack__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNtrack__datamem_bld(&__edm__Wrapper_BNtrack__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNtrack__funcmem_bld(&__edm__Wrapper_BNtrack__db_funcmem);
void __edm__Wrapper_BNtrack__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNtrack>"), typeid(::edm::Wrapper<BNtrack>), sizeof(::edm::Wrapper<BNtrack>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNtrack>")
  .AddTypedef(type_1488, Reflex::Literal("edm::Wrapper<BNtrack>::value_type"))
  .AddTypedef(type_1488, Reflex::Literal("edm::Wrapper<BNtrack>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16739, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2073), Reflex::Literal("Wrapper"), constructor_16740, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16741, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3199), Reflex::Literal("Wrapper"), constructor_16746, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4058, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNtrack__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNtrack__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNtrack> -------------------
void __edm__Wrapper_BNtrack__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNtrack_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1488, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNtrack_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNtrack> -------------------
void __edm__Wrapper_BNtrack__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3201), Reflex::Literal("product"), method_16742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3201), Reflex::Literal("operator->"), operator_16743, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16744, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16745, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25786), Reflex::Literal("getInterface"), method_16747, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16748, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16749, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16750, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNsupercluster, std::allocator<BNsupercluster> > > -------------------------------
static void constructor_16760( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNsupercluster> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNsupercluster> >();
}

static void constructor_16761( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNsupercluster> >(*(::std::auto_ptr<std::vector<BNsupercluster> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNsupercluster> >(*(::std::auto_ptr<std::vector<BNsupercluster> >*)arg[0]);
}

static void destructor_16762(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNsupercluster> >*)o)->::edm::Wrapper<std::vector<BNsupercluster> >::~Wrapper)();
}
static  void method_16763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->product)();
}

static  void operator_16764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->operator->)();
}

static  void method_16765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNsupercluster> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNsupercluster> >*)o)->productTypeInfo)();
}

static  void method_16766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNsupercluster> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNsupercluster> >*)o)->typeInfo)();
}

static void constructor_16767( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNsupercluster> >((::std::vector<BNsupercluster>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNsupercluster> >((::std::vector<BNsupercluster>*)arg[0]);
}

static  void method_16768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNsupercluster> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNsupercluster> >*)o)->getInterface)();
}

static  void method_16769( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16770( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16771( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->dynamicTypeInfo)();
}

static  void method_16773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->isPresent)();
}

static  void method_16774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNsupercluster> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4059( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNsupercluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNsupercluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNsupercluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNsupercluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNsupercluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNsupercluster, std::allocator<BNsupercluster> > > -------------------------------
void __edm__Wrapper_std__vector_BNsupercluster_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNsupercluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNsupercluster_s__datamem_bld(&__edm__Wrapper_std__vector_BNsupercluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNsupercluster_s__funcmem_bld(&__edm__Wrapper_std__vector_BNsupercluster_s__db_funcmem);
void __edm__Wrapper_std__vector_BNsupercluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNsupercluster> >"), typeid(::edm::Wrapper<std::vector<BNsupercluster> >), sizeof(::edm::Wrapper<std::vector<BNsupercluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_576, Reflex::Literal("edm::Wrapper<std::vector<BNsupercluster> >::value_type"))
  .AddTypedef(type_576, Reflex::Literal("edm::Wrapper<std::vector<BNsupercluster> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16760, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2074), Reflex::Literal("Wrapper"), constructor_16761, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16762, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25790), Reflex::Literal("Wrapper"), constructor_16767, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4059, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNsupercluster_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNsupercluster_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNsupercluster, std::allocator<BNsupercluster> > > -------------------
void __edm__Wrapper_std__vector_BNsupercluster_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNsupercluster_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_576, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNsupercluster_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNsupercluster, std::allocator<BNsupercluster> > > -------------------
void __edm__Wrapper_std__vector_BNsupercluster_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25789), Reflex::Literal("product"), method_16763, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25789), Reflex::Literal("operator->"), operator_16764, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16765, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16766, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25791), Reflex::Literal("getInterface"), method_16768, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16769, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16770, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16771, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16774, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNsupercluster> -------------------------------
static void constructor_16781( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNsupercluster>();
  else ::new(mem) ::edm::Wrapper<BNsupercluster>();
}

static void constructor_16782( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNsupercluster>(*(::std::auto_ptr<BNsupercluster>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNsupercluster>(*(::std::auto_ptr<BNsupercluster>*)arg[0]);
}

static void destructor_16783(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNsupercluster>*)o)->::edm::Wrapper<BNsupercluster>::~Wrapper)();
}
static  void method_16784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNsupercluster>*)o)->product)());
  else   (((const ::edm::Wrapper<BNsupercluster>*)o)->product)();
}

static  void operator_16785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNsupercluster>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNsupercluster>*)o)->operator->)();
}

static  void method_16786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNsupercluster>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNsupercluster>*)o)->productTypeInfo)();
}

static  void method_16787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNsupercluster>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNsupercluster>*)o)->typeInfo)();
}

static void constructor_16788( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNsupercluster>((::BNsupercluster*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNsupercluster>((::BNsupercluster*)arg[0]);
}

static  void method_16789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNsupercluster>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNsupercluster>*)o)->getInterface)();
}

static  void method_16790( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNsupercluster>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16791( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNsupercluster>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16792( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNsupercluster>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNsupercluster>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNsupercluster>*)o)->dynamicTypeInfo)();
}

static  void method_16794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNsupercluster>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNsupercluster>*)o)->isPresent)();
}

static  void method_16795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNsupercluster>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNsupercluster>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4060( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNsupercluster> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNsupercluster> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNsupercluster> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNsupercluster> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNsupercluster> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNsupercluster> -------------------------------
void __edm__Wrapper_BNsupercluster__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNsupercluster__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNsupercluster__datamem_bld(&__edm__Wrapper_BNsupercluster__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNsupercluster__funcmem_bld(&__edm__Wrapper_BNsupercluster__db_funcmem);
void __edm__Wrapper_BNsupercluster__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNsupercluster>"), typeid(::edm::Wrapper<BNsupercluster>), sizeof(::edm::Wrapper<BNsupercluster>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNsupercluster>")
  .AddTypedef(type_281, Reflex::Literal("edm::Wrapper<BNsupercluster>::value_type"))
  .AddTypedef(type_281, Reflex::Literal("edm::Wrapper<BNsupercluster>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16781, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2075), Reflex::Literal("Wrapper"), constructor_16782, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16783, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4843), Reflex::Literal("Wrapper"), constructor_16788, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4060, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNsupercluster__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNsupercluster__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNsupercluster> -------------------
void __edm__Wrapper_BNsupercluster__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNsupercluster_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_281, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNsupercluster_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNsupercluster> -------------------
void __edm__Wrapper_BNsupercluster__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4845), Reflex::Literal("product"), method_16784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4845), Reflex::Literal("operator->"), operator_16785, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16786, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16787, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25794), Reflex::Literal("getInterface"), method_16789, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16790, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16791, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16792, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16794, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16795, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNphoton, std::allocator<BNphoton> > > -------------------------------
static void constructor_16802( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNphoton> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNphoton> >();
}

static void constructor_16803( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNphoton> >(*(::std::auto_ptr<std::vector<BNphoton> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNphoton> >(*(::std::auto_ptr<std::vector<BNphoton> >*)arg[0]);
}

static void destructor_16804(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNphoton> >*)o)->::edm::Wrapper<std::vector<BNphoton> >::~Wrapper)();
}
static  void method_16805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->product)();
}

static  void operator_16806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->operator->)();
}

static  void method_16807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNphoton> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNphoton> >*)o)->productTypeInfo)();
}

static  void method_16808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNphoton> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNphoton> >*)o)->typeInfo)();
}

static void constructor_16809( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNphoton> >((::std::vector<BNphoton>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNphoton> >((::std::vector<BNphoton>*)arg[0]);
}

static  void method_16810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNphoton> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNphoton> >*)o)->getInterface)();
}

static  void method_16811( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16812( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16813( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->dynamicTypeInfo)();
}

static  void method_16815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->isPresent)();
}

static  void method_16816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNphoton> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4061( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNphoton> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNphoton> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNphoton> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNphoton> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNphoton> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNphoton, std::allocator<BNphoton> > > -------------------------------
void __edm__Wrapper_std__vector_BNphoton_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNphoton_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNphoton_s__datamem_bld(&__edm__Wrapper_std__vector_BNphoton_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNphoton_s__funcmem_bld(&__edm__Wrapper_std__vector_BNphoton_s__db_funcmem);
void __edm__Wrapper_std__vector_BNphoton_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNphoton> >"), typeid(::edm::Wrapper<std::vector<BNphoton> >), sizeof(::edm::Wrapper<std::vector<BNphoton> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1306, Reflex::Literal("edm::Wrapper<std::vector<BNphoton> >::value_type"))
  .AddTypedef(type_1306, Reflex::Literal("edm::Wrapper<std::vector<BNphoton> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16802, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2076), Reflex::Literal("Wrapper"), constructor_16803, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16804, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25798), Reflex::Literal("Wrapper"), constructor_16809, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4061, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNphoton_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNphoton_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNphoton, std::allocator<BNphoton> > > -------------------
void __edm__Wrapper_std__vector_BNphoton_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNphoton_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1306, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNphoton_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNphoton, std::allocator<BNphoton> > > -------------------
void __edm__Wrapper_std__vector_BNphoton_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25797), Reflex::Literal("product"), method_16805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25797), Reflex::Literal("operator->"), operator_16806, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16807, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16808, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25799), Reflex::Literal("getInterface"), method_16810, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16811, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16812, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16813, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16815, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNphoton> -------------------------------
static void constructor_16823( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNphoton>();
  else ::new(mem) ::edm::Wrapper<BNphoton>();
}

static void constructor_16824( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNphoton>(*(::std::auto_ptr<BNphoton>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNphoton>(*(::std::auto_ptr<BNphoton>*)arg[0]);
}

static void destructor_16825(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNphoton>*)o)->::edm::Wrapper<BNphoton>::~Wrapper)();
}
static  void method_16826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNphoton>*)o)->product)());
  else   (((const ::edm::Wrapper<BNphoton>*)o)->product)();
}

static  void operator_16827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNphoton>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNphoton>*)o)->operator->)();
}

static  void method_16828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNphoton>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNphoton>*)o)->productTypeInfo)();
}

static  void method_16829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNphoton>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNphoton>*)o)->typeInfo)();
}

static void constructor_16830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNphoton>((::BNphoton*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNphoton>((::BNphoton*)arg[0]);
}

static  void method_16831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNphoton>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNphoton>*)o)->getInterface)();
}

static  void method_16832( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNphoton>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16833( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNphoton>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16834( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNphoton>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNphoton>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNphoton>*)o)->dynamicTypeInfo)();
}

static  void method_16836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNphoton>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNphoton>*)o)->isPresent)();
}

static  void method_16837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNphoton>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNphoton>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4062( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNphoton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNphoton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNphoton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNphoton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNphoton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNphoton> -------------------------------
void __edm__Wrapper_BNphoton__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNphoton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNphoton__datamem_bld(&__edm__Wrapper_BNphoton__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNphoton__funcmem_bld(&__edm__Wrapper_BNphoton__db_funcmem);
void __edm__Wrapper_BNphoton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNphoton>"), typeid(::edm::Wrapper<BNphoton>), sizeof(::edm::Wrapper<BNphoton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNphoton>")
  .AddTypedef(type_1001, Reflex::Literal("edm::Wrapper<BNphoton>::value_type"))
  .AddTypedef(type_1001, Reflex::Literal("edm::Wrapper<BNphoton>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16823, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2077), Reflex::Literal("Wrapper"), constructor_16824, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16825, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5367), Reflex::Literal("Wrapper"), constructor_16830, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4062, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNphoton__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNphoton__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNphoton> -------------------
void __edm__Wrapper_BNphoton__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNphoton_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1001, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNphoton_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNphoton> -------------------
void __edm__Wrapper_BNphoton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5369), Reflex::Literal("product"), method_16826, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5369), Reflex::Literal("operator->"), operator_16827, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16828, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16829, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25802), Reflex::Literal("getInterface"), method_16831, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16832, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16833, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16834, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16835, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16836, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNlepton, std::allocator<BNlepton> > > -------------------------------
static void constructor_16844( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNlepton> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNlepton> >();
}

static void constructor_16845( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNlepton> >(*(::std::auto_ptr<std::vector<BNlepton> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNlepton> >(*(::std::auto_ptr<std::vector<BNlepton> >*)arg[0]);
}

static void destructor_16846(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNlepton> >*)o)->::edm::Wrapper<std::vector<BNlepton> >::~Wrapper)();
}
static  void method_16847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->product)();
}

static  void operator_16848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->operator->)();
}

static  void method_16849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNlepton> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNlepton> >*)o)->productTypeInfo)();
}

static  void method_16850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNlepton> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNlepton> >*)o)->typeInfo)();
}

static void constructor_16851( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNlepton> >((::std::vector<BNlepton>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNlepton> >((::std::vector<BNlepton>*)arg[0]);
}

static  void method_16852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNlepton> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNlepton> >*)o)->getInterface)();
}

static  void method_16853( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16854( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16855( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->dynamicTypeInfo)();
}

static  void method_16857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->isPresent)();
}

static  void method_16858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNlepton> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4063( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNlepton> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNlepton> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNlepton> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNlepton> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNlepton> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNlepton, std::allocator<BNlepton> > > -------------------------------
void __edm__Wrapper_std__vector_BNlepton_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNlepton_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNlepton_s__datamem_bld(&__edm__Wrapper_std__vector_BNlepton_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNlepton_s__funcmem_bld(&__edm__Wrapper_std__vector_BNlepton_s__db_funcmem);
void __edm__Wrapper_std__vector_BNlepton_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNlepton> >"), typeid(::edm::Wrapper<std::vector<BNlepton> >), sizeof(::edm::Wrapper<std::vector<BNlepton> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2315, Reflex::Literal("edm::Wrapper<std::vector<BNlepton> >::value_type"))
  .AddTypedef(type_2315, Reflex::Literal("edm::Wrapper<std::vector<BNlepton> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16844, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2078), Reflex::Literal("Wrapper"), constructor_16845, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16846, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25806), Reflex::Literal("Wrapper"), constructor_16851, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4063, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNlepton_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNlepton_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNlepton, std::allocator<BNlepton> > > -------------------
void __edm__Wrapper_std__vector_BNlepton_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNlepton_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2315, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNlepton_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNlepton, std::allocator<BNlepton> > > -------------------
void __edm__Wrapper_std__vector_BNlepton_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25805), Reflex::Literal("product"), method_16847, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25805), Reflex::Literal("operator->"), operator_16848, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16849, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16850, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25807), Reflex::Literal("getInterface"), method_16852, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16853, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16854, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16855, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNlepton> -------------------------------
static void constructor_16865( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNlepton>();
  else ::new(mem) ::edm::Wrapper<BNlepton>();
}

static void constructor_16866( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNlepton>(*(::std::auto_ptr<BNlepton>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNlepton>(*(::std::auto_ptr<BNlepton>*)arg[0]);
}

static void destructor_16867(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNlepton>*)o)->::edm::Wrapper<BNlepton>::~Wrapper)();
}
static  void method_16868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNlepton>*)o)->product)());
  else   (((const ::edm::Wrapper<BNlepton>*)o)->product)();
}

static  void operator_16869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNlepton>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNlepton>*)o)->operator->)();
}

static  void method_16870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNlepton>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNlepton>*)o)->productTypeInfo)();
}

static  void method_16871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNlepton>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNlepton>*)o)->typeInfo)();
}

static void constructor_16872( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNlepton>((::BNlepton*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNlepton>((::BNlepton*)arg[0]);
}

static  void method_16873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNlepton>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNlepton>*)o)->getInterface)();
}

static  void method_16874( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNlepton>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16875( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNlepton>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16876( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNlepton>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNlepton>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNlepton>*)o)->dynamicTypeInfo)();
}

static  void method_16878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNlepton>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNlepton>*)o)->isPresent)();
}

static  void method_16879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNlepton>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNlepton>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4064( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNlepton> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNlepton> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNlepton> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNlepton> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNlepton> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNlepton> -------------------------------
void __edm__Wrapper_BNlepton__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNlepton__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNlepton__datamem_bld(&__edm__Wrapper_BNlepton__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNlepton__funcmem_bld(&__edm__Wrapper_BNlepton__db_funcmem);
void __edm__Wrapper_BNlepton__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNlepton>"), typeid(::edm::Wrapper<BNlepton>), sizeof(::edm::Wrapper<BNlepton>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNlepton>")
  .AddTypedef(type_1092, Reflex::Literal("edm::Wrapper<BNlepton>::value_type"))
  .AddTypedef(type_1092, Reflex::Literal("edm::Wrapper<BNlepton>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16865, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2079), Reflex::Literal("Wrapper"), constructor_16866, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16867, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9684), Reflex::Literal("Wrapper"), constructor_16872, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4064, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNlepton__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNlepton__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNlepton> -------------------
void __edm__Wrapper_BNlepton__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNlepton_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1092, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNlepton_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNlepton> -------------------
void __edm__Wrapper_BNlepton__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9686), Reflex::Literal("product"), method_16868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9686), Reflex::Literal("operator->"), operator_16869, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16870, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16871, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25810), Reflex::Literal("getInterface"), method_16873, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16874, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16875, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16876, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16877, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16878, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNmuon, std::allocator<BNmuon> > > -------------------------------
static void constructor_16886( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNmuon> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNmuon> >();
}

static void constructor_16887( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNmuon> >(*(::std::auto_ptr<std::vector<BNmuon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNmuon> >(*(::std::auto_ptr<std::vector<BNmuon> >*)arg[0]);
}

static void destructor_16888(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNmuon> >*)o)->::edm::Wrapper<std::vector<BNmuon> >::~Wrapper)();
}
static  void method_16889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->product)();
}

static  void operator_16890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->operator->)();
}

static  void method_16891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNmuon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNmuon> >*)o)->productTypeInfo)();
}

static  void method_16892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNmuon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNmuon> >*)o)->typeInfo)();
}

static void constructor_16893( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNmuon> >((::std::vector<BNmuon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNmuon> >((::std::vector<BNmuon>*)arg[0]);
}

static  void method_16894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNmuon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNmuon> >*)o)->getInterface)();
}

static  void method_16895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16897( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->dynamicTypeInfo)();
}

static  void method_16899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->isPresent)();
}

static  void method_16900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNmuon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4065( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmuon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmuon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmuon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmuon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmuon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNmuon, std::allocator<BNmuon> > > -------------------------------
void __edm__Wrapper_std__vector_BNmuon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNmuon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNmuon_s__datamem_bld(&__edm__Wrapper_std__vector_BNmuon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNmuon_s__funcmem_bld(&__edm__Wrapper_std__vector_BNmuon_s__db_funcmem);
void __edm__Wrapper_std__vector_BNmuon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNmuon> >"), typeid(::edm::Wrapper<std::vector<BNmuon> >), sizeof(::edm::Wrapper<std::vector<BNmuon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_377, Reflex::Literal("edm::Wrapper<std::vector<BNmuon> >::value_type"))
  .AddTypedef(type_377, Reflex::Literal("edm::Wrapper<std::vector<BNmuon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16886, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2080), Reflex::Literal("Wrapper"), constructor_16887, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16888, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25814), Reflex::Literal("Wrapper"), constructor_16893, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4065, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNmuon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNmuon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNmuon, std::allocator<BNmuon> > > -------------------
void __edm__Wrapper_std__vector_BNmuon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNmuon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_377, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNmuon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNmuon, std::allocator<BNmuon> > > -------------------
void __edm__Wrapper_std__vector_BNmuon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25813), Reflex::Literal("product"), method_16889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25813), Reflex::Literal("operator->"), operator_16890, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16891, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16892, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25815), Reflex::Literal("getInterface"), method_16894, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16895, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16896, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16897, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNmuon> -------------------------------
static void constructor_16907( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNmuon>();
  else ::new(mem) ::edm::Wrapper<BNmuon>();
}

static void constructor_16908( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNmuon>(*(::std::auto_ptr<BNmuon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNmuon>(*(::std::auto_ptr<BNmuon>*)arg[0]);
}

static void destructor_16909(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNmuon>*)o)->::edm::Wrapper<BNmuon>::~Wrapper)();
}
static  void method_16910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNmuon>*)o)->product)());
  else   (((const ::edm::Wrapper<BNmuon>*)o)->product)();
}

static  void operator_16911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNmuon>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNmuon>*)o)->operator->)();
}

static  void method_16912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNmuon>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNmuon>*)o)->productTypeInfo)();
}

static  void method_16913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNmuon>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNmuon>*)o)->typeInfo)();
}

static void constructor_16914( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNmuon>((::BNmuon*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNmuon>((::BNmuon*)arg[0]);
}

static  void method_16915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNmuon>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNmuon>*)o)->getInterface)();
}

static  void method_16916( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNmuon>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16917( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNmuon>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16918( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNmuon>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNmuon>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNmuon>*)o)->dynamicTypeInfo)();
}

static  void method_16920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNmuon>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNmuon>*)o)->isPresent)();
}

static  void method_16921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNmuon>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNmuon>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4066( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmuon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmuon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmuon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmuon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmuon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNmuon> -------------------------------
void __edm__Wrapper_BNmuon__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNmuon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNmuon__datamem_bld(&__edm__Wrapper_BNmuon__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNmuon__funcmem_bld(&__edm__Wrapper_BNmuon__db_funcmem);
void __edm__Wrapper_BNmuon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNmuon>"), typeid(::edm::Wrapper<BNmuon>), sizeof(::edm::Wrapper<BNmuon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNmuon>")
  .AddTypedef(type_336, Reflex::Literal("edm::Wrapper<BNmuon>::value_type"))
  .AddTypedef(type_336, Reflex::Literal("edm::Wrapper<BNmuon>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16907, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2081), Reflex::Literal("Wrapper"), constructor_16908, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16909, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4307), Reflex::Literal("Wrapper"), constructor_16914, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4066, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNmuon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNmuon__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNmuon> -------------------
void __edm__Wrapper_BNmuon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNmuon_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_336, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNmuon_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNmuon> -------------------
void __edm__Wrapper_BNmuon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4309), Reflex::Literal("product"), method_16910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4309), Reflex::Literal("operator->"), operator_16911, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16912, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16913, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25818), Reflex::Literal("getInterface"), method_16915, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16916, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16917, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16918, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNmet, std::allocator<BNmet> > > -------------------------------
static void constructor_16928( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNmet> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNmet> >();
}

static void constructor_16929( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNmet> >(*(::std::auto_ptr<std::vector<BNmet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNmet> >(*(::std::auto_ptr<std::vector<BNmet> >*)arg[0]);
}

static void destructor_16930(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNmet> >*)o)->::edm::Wrapper<std::vector<BNmet> >::~Wrapper)();
}
static  void method_16931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNmet> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNmet> >*)o)->product)();
}

static  void operator_16932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNmet> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNmet> >*)o)->operator->)();
}

static  void method_16933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNmet> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNmet> >*)o)->productTypeInfo)();
}

static  void method_16934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNmet> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNmet> >*)o)->typeInfo)();
}

static void constructor_16935( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNmet> >((::std::vector<BNmet>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNmet> >((::std::vector<BNmet>*)arg[0]);
}

static  void method_16936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNmet> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNmet> >*)o)->getInterface)();
}

static  void method_16937( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNmet> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16938( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNmet> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16939( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNmet> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNmet> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNmet> >*)o)->dynamicTypeInfo)();
}

static  void method_16941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNmet> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNmet> >*)o)->isPresent)();
}

static  void method_16942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNmet> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNmet> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4067( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNmet, std::allocator<BNmet> > > -------------------------------
void __edm__Wrapper_std__vector_BNmet_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNmet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNmet_s__datamem_bld(&__edm__Wrapper_std__vector_BNmet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNmet_s__funcmem_bld(&__edm__Wrapper_std__vector_BNmet_s__db_funcmem);
void __edm__Wrapper_std__vector_BNmet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNmet> >"), typeid(::edm::Wrapper<std::vector<BNmet> >), sizeof(::edm::Wrapper<std::vector<BNmet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1621, Reflex::Literal("edm::Wrapper<std::vector<BNmet> >::value_type"))
  .AddTypedef(type_1621, Reflex::Literal("edm::Wrapper<std::vector<BNmet> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16928, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2082), Reflex::Literal("Wrapper"), constructor_16929, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16930, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25822), Reflex::Literal("Wrapper"), constructor_16935, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4067, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNmet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNmet_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNmet, std::allocator<BNmet> > > -------------------
void __edm__Wrapper_std__vector_BNmet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNmet_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1621, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNmet_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNmet, std::allocator<BNmet> > > -------------------
void __edm__Wrapper_std__vector_BNmet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25821), Reflex::Literal("product"), method_16931, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25821), Reflex::Literal("operator->"), operator_16932, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16933, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16934, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25823), Reflex::Literal("getInterface"), method_16936, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16937, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16938, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16939, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16940, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16941, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16942, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNmet> -------------------------------
static void constructor_16949( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNmet>();
  else ::new(mem) ::edm::Wrapper<BNmet>();
}

static void constructor_16950( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNmet>(*(::std::auto_ptr<BNmet>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNmet>(*(::std::auto_ptr<BNmet>*)arg[0]);
}

static void destructor_16951(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNmet>*)o)->::edm::Wrapper<BNmet>::~Wrapper)();
}
static  void method_16952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNmet>*)o)->product)());
  else   (((const ::edm::Wrapper<BNmet>*)o)->product)();
}

static  void operator_16953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNmet>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNmet>*)o)->operator->)();
}

static  void method_16954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNmet>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNmet>*)o)->productTypeInfo)();
}

static  void method_16955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNmet>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNmet>*)o)->typeInfo)();
}

static void constructor_16956( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNmet>((::BNmet*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNmet>((::BNmet*)arg[0]);
}

static  void method_16957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNmet>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNmet>*)o)->getInterface)();
}

static  void method_16958( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNmet>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16959( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNmet>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16960( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNmet>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNmet>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNmet>*)o)->dynamicTypeInfo)();
}

static  void method_16962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNmet>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNmet>*)o)->isPresent)();
}

static  void method_16963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNmet>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNmet>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4068( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNmet> -------------------------------
void __edm__Wrapper_BNmet__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNmet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNmet__datamem_bld(&__edm__Wrapper_BNmet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNmet__funcmem_bld(&__edm__Wrapper_BNmet__db_funcmem);
void __edm__Wrapper_BNmet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNmet>"), typeid(::edm::Wrapper<BNmet>), sizeof(::edm::Wrapper<BNmet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNmet>")
  .AddTypedef(type_868, Reflex::Literal("edm::Wrapper<BNmet>::value_type"))
  .AddTypedef(type_868, Reflex::Literal("edm::Wrapper<BNmet>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16949, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2083), Reflex::Literal("Wrapper"), constructor_16950, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16951, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5999), Reflex::Literal("Wrapper"), constructor_16956, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4068, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNmet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNmet__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNmet> -------------------
void __edm__Wrapper_BNmet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNmet_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_868, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNmet_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNmet> -------------------
void __edm__Wrapper_BNmet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6001), Reflex::Literal("product"), method_16952, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6001), Reflex::Literal("operator->"), operator_16953, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16954, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16955, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25826), Reflex::Literal("getInterface"), method_16957, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16958, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16959, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16960, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16961, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16962, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16963, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNmcparticle, std::allocator<BNmcparticle> > > -------------------------------
static void constructor_16970( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNmcparticle> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNmcparticle> >();
}

static void constructor_16971( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNmcparticle> >(*(::std::auto_ptr<std::vector<BNmcparticle> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNmcparticle> >(*(::std::auto_ptr<std::vector<BNmcparticle> >*)arg[0]);
}

static void destructor_16972(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNmcparticle> >*)o)->::edm::Wrapper<std::vector<BNmcparticle> >::~Wrapper)();
}
static  void method_16973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->product)();
}

static  void operator_16974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->operator->)();
}

static  void method_16975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNmcparticle> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNmcparticle> >*)o)->productTypeInfo)();
}

static  void method_16976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNmcparticle> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNmcparticle> >*)o)->typeInfo)();
}

static void constructor_16977( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNmcparticle> >((::std::vector<BNmcparticle>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNmcparticle> >((::std::vector<BNmcparticle>*)arg[0]);
}

static  void method_16978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNmcparticle> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNmcparticle> >*)o)->getInterface)();
}

static  void method_16979( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16981( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->dynamicTypeInfo)();
}

static  void method_16983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->isPresent)();
}

static  void method_16984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNmcparticle> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4069( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmcparticle> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmcparticle> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmcparticle> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmcparticle> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNmcparticle> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNmcparticle, std::allocator<BNmcparticle> > > -------------------------------
void __edm__Wrapper_std__vector_BNmcparticle_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNmcparticle_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNmcparticle_s__datamem_bld(&__edm__Wrapper_std__vector_BNmcparticle_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNmcparticle_s__funcmem_bld(&__edm__Wrapper_std__vector_BNmcparticle_s__db_funcmem);
void __edm__Wrapper_std__vector_BNmcparticle_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNmcparticle> >"), typeid(::edm::Wrapper<std::vector<BNmcparticle> >), sizeof(::edm::Wrapper<std::vector<BNmcparticle> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1726, Reflex::Literal("edm::Wrapper<std::vector<BNmcparticle> >::value_type"))
  .AddTypedef(type_1726, Reflex::Literal("edm::Wrapper<std::vector<BNmcparticle> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16970, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2084), Reflex::Literal("Wrapper"), constructor_16971, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16972, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25830), Reflex::Literal("Wrapper"), constructor_16977, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4069, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNmcparticle_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNmcparticle_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNmcparticle, std::allocator<BNmcparticle> > > -------------------
void __edm__Wrapper_std__vector_BNmcparticle_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNmcparticle_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1726, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNmcparticle_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNmcparticle, std::allocator<BNmcparticle> > > -------------------
void __edm__Wrapper_std__vector_BNmcparticle_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25829), Reflex::Literal("product"), method_16973, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25829), Reflex::Literal("operator->"), operator_16974, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16975, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16976, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25831), Reflex::Literal("getInterface"), method_16978, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_16979, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_16980, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_16981, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_16982, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_16983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_16984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNmcparticle> -------------------------------
static void constructor_16991( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNmcparticle>();
  else ::new(mem) ::edm::Wrapper<BNmcparticle>();
}

static void constructor_16992( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNmcparticle>(*(::std::auto_ptr<BNmcparticle>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNmcparticle>(*(::std::auto_ptr<BNmcparticle>*)arg[0]);
}

static void destructor_16993(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNmcparticle>*)o)->::edm::Wrapper<BNmcparticle>::~Wrapper)();
}
static  void method_16994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNmcparticle>*)o)->product)());
  else   (((const ::edm::Wrapper<BNmcparticle>*)o)->product)();
}

static  void operator_16995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNmcparticle>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNmcparticle>*)o)->operator->)();
}

static  void method_16996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNmcparticle>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNmcparticle>*)o)->productTypeInfo)();
}

static  void method_16997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNmcparticle>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNmcparticle>*)o)->typeInfo)();
}

static void constructor_16998( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNmcparticle>((::BNmcparticle*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNmcparticle>((::BNmcparticle*)arg[0]);
}

static  void method_16999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNmcparticle>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNmcparticle>*)o)->getInterface)();
}

static  void method_17000( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNmcparticle>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17001( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNmcparticle>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17002( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNmcparticle>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNmcparticle>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNmcparticle>*)o)->dynamicTypeInfo)();
}

static  void method_17004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNmcparticle>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNmcparticle>*)o)->isPresent)();
}

static  void method_17005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNmcparticle>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNmcparticle>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4070( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmcparticle> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmcparticle> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmcparticle> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmcparticle> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNmcparticle> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNmcparticle> -------------------------------
void __edm__Wrapper_BNmcparticle__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNmcparticle__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNmcparticle__datamem_bld(&__edm__Wrapper_BNmcparticle__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNmcparticle__funcmem_bld(&__edm__Wrapper_BNmcparticle__db_funcmem);
void __edm__Wrapper_BNmcparticle__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNmcparticle>"), typeid(::edm::Wrapper<BNmcparticle>), sizeof(::edm::Wrapper<BNmcparticle>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNmcparticle>")
  .AddTypedef(type_111, Reflex::Literal("edm::Wrapper<BNmcparticle>::value_type"))
  .AddTypedef(type_111, Reflex::Literal("edm::Wrapper<BNmcparticle>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16991, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2085), Reflex::Literal("Wrapper"), constructor_16992, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16993, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6295), Reflex::Literal("Wrapper"), constructor_16998, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4070, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNmcparticle__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNmcparticle__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNmcparticle> -------------------
void __edm__Wrapper_BNmcparticle__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNmcparticle_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNmcparticle_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNmcparticle> -------------------
void __edm__Wrapper_BNmcparticle__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6297), Reflex::Literal("product"), method_16994, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6297), Reflex::Literal("operator->"), operator_16995, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_16996, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_16997, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25834), Reflex::Literal("getInterface"), method_16999, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17000, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17001, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17002, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17003, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17004, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17005, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNevent, std::allocator<BNevent> > > -------------------------------
static void constructor_17012( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNevent> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNevent> >();
}

static void constructor_17013( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNevent> >(*(::std::auto_ptr<std::vector<BNevent> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNevent> >(*(::std::auto_ptr<std::vector<BNevent> >*)arg[0]);
}

static void destructor_17014(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNevent> >*)o)->::edm::Wrapper<std::vector<BNevent> >::~Wrapper)();
}
static  void method_17015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNevent> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNevent> >*)o)->product)();
}

static  void operator_17016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNevent> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNevent> >*)o)->operator->)();
}

static  void method_17017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNevent> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNevent> >*)o)->productTypeInfo)();
}

static  void method_17018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNevent> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNevent> >*)o)->typeInfo)();
}

static void constructor_17019( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNevent> >((::std::vector<BNevent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNevent> >((::std::vector<BNevent>*)arg[0]);
}

static  void method_17020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNevent> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNevent> >*)o)->getInterface)();
}

static  void method_17021( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNevent> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17022( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNevent> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17023( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNevent> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNevent> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNevent> >*)o)->dynamicTypeInfo)();
}

static  void method_17025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNevent> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNevent> >*)o)->isPresent)();
}

static  void method_17026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNevent> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNevent> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4071( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNevent> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNevent> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNevent> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNevent> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNevent> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNevent, std::allocator<BNevent> > > -------------------------------
void __edm__Wrapper_std__vector_BNevent_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNevent_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNevent_s__datamem_bld(&__edm__Wrapper_std__vector_BNevent_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNevent_s__funcmem_bld(&__edm__Wrapper_std__vector_BNevent_s__db_funcmem);
void __edm__Wrapper_std__vector_BNevent_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNevent> >"), typeid(::edm::Wrapper<std::vector<BNevent> >), sizeof(::edm::Wrapper<std::vector<BNevent> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_68, Reflex::Literal("edm::Wrapper<std::vector<BNevent> >::value_type"))
  .AddTypedef(type_68, Reflex::Literal("edm::Wrapper<std::vector<BNevent> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17012, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2086), Reflex::Literal("Wrapper"), constructor_17013, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17014, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25838), Reflex::Literal("Wrapper"), constructor_17019, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4071, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNevent_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNevent_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNevent, std::allocator<BNevent> > > -------------------
void __edm__Wrapper_std__vector_BNevent_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNevent_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNevent_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNevent, std::allocator<BNevent> > > -------------------
void __edm__Wrapper_std__vector_BNevent_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25837), Reflex::Literal("product"), method_17015, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25837), Reflex::Literal("operator->"), operator_17016, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_17017, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_17018, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25839), Reflex::Literal("getInterface"), method_17020, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17021, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17022, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17023, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17024, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17025, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17026, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNevent> -------------------------------
static void constructor_17033( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNevent>();
  else ::new(mem) ::edm::Wrapper<BNevent>();
}

static void constructor_17034( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNevent>(*(::std::auto_ptr<BNevent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNevent>(*(::std::auto_ptr<BNevent>*)arg[0]);
}

static void destructor_17035(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNevent>*)o)->::edm::Wrapper<BNevent>::~Wrapper)();
}
static  void method_17036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNevent>*)o)->product)());
  else   (((const ::edm::Wrapper<BNevent>*)o)->product)();
}

static  void operator_17037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNevent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNevent>*)o)->operator->)();
}

static  void method_17038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNevent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNevent>*)o)->productTypeInfo)();
}

static  void method_17039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNevent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNevent>*)o)->typeInfo)();
}

static void constructor_17040( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNevent>((::BNevent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNevent>((::BNevent*)arg[0]);
}

static  void method_17041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNevent>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNevent>*)o)->getInterface)();
}

static  void method_17042( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNevent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17043( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNevent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17044( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNevent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNevent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNevent>*)o)->dynamicTypeInfo)();
}

static  void method_17046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNevent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNevent>*)o)->isPresent)();
}

static  void method_17047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNevent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNevent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4072( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNevent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNevent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNevent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNevent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNevent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNevent> -------------------------------
void __edm__Wrapper_BNevent__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNevent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNevent__datamem_bld(&__edm__Wrapper_BNevent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNevent__funcmem_bld(&__edm__Wrapper_BNevent__db_funcmem);
void __edm__Wrapper_BNevent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNevent>"), typeid(::edm::Wrapper<BNevent>), sizeof(::edm::Wrapper<BNevent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNevent>")
  .AddTypedef(type_499, Reflex::Literal("edm::Wrapper<BNevent>::value_type"))
  .AddTypedef(type_499, Reflex::Literal("edm::Wrapper<BNevent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17033, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2087), Reflex::Literal("Wrapper"), constructor_17034, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17035, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2872), Reflex::Literal("Wrapper"), constructor_17040, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4072, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNevent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNevent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNevent> -------------------
void __edm__Wrapper_BNevent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNevent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_499, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNevent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNevent> -------------------
void __edm__Wrapper_BNevent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2874), Reflex::Literal("product"), method_17036, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2874), Reflex::Literal("operator->"), operator_17037, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_17038, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_17039, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25842), Reflex::Literal("getInterface"), method_17041, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17042, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17043, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17044, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNjet, std::allocator<BNjet> > > -------------------------------
static void constructor_17054( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNjet> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNjet> >();
}

static void constructor_17055( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNjet> >(*(::std::auto_ptr<std::vector<BNjet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNjet> >(*(::std::auto_ptr<std::vector<BNjet> >*)arg[0]);
}

static void destructor_17056(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNjet> >*)o)->::edm::Wrapper<std::vector<BNjet> >::~Wrapper)();
}
static  void method_17057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNjet> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNjet> >*)o)->product)();
}

static  void operator_17058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNjet> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNjet> >*)o)->operator->)();
}

static  void method_17059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNjet> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNjet> >*)o)->productTypeInfo)();
}

static  void method_17060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNjet> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNjet> >*)o)->typeInfo)();
}

static void constructor_17061( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNjet> >((::std::vector<BNjet>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNjet> >((::std::vector<BNjet>*)arg[0]);
}

static  void method_17062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNjet> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNjet> >*)o)->getInterface)();
}

static  void method_17063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNjet> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17064( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNjet> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17065( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNjet> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNjet> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNjet> >*)o)->dynamicTypeInfo)();
}

static  void method_17067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNjet> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNjet> >*)o)->isPresent)();
}

static  void method_17068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNjet> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNjet> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4073( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNjet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNjet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNjet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNjet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNjet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNjet, std::allocator<BNjet> > > -------------------------------
void __edm__Wrapper_std__vector_BNjet_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNjet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNjet_s__datamem_bld(&__edm__Wrapper_std__vector_BNjet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNjet_s__funcmem_bld(&__edm__Wrapper_std__vector_BNjet_s__db_funcmem);
void __edm__Wrapper_std__vector_BNjet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNjet> >"), typeid(::edm::Wrapper<std::vector<BNjet> >), sizeof(::edm::Wrapper<std::vector<BNjet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_236, Reflex::Literal("edm::Wrapper<std::vector<BNjet> >::value_type"))
  .AddTypedef(type_236, Reflex::Literal("edm::Wrapper<std::vector<BNjet> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17054, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2088), Reflex::Literal("Wrapper"), constructor_17055, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17056, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25846), Reflex::Literal("Wrapper"), constructor_17061, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4073, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNjet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNjet_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNjet, std::allocator<BNjet> > > -------------------
void __edm__Wrapper_std__vector_BNjet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNjet_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_236, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNjet_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNjet, std::allocator<BNjet> > > -------------------
void __edm__Wrapper_std__vector_BNjet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25845), Reflex::Literal("product"), method_17057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25845), Reflex::Literal("operator->"), operator_17058, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_17059, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_17060, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25847), Reflex::Literal("getInterface"), method_17062, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17063, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17064, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17065, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNjet> -------------------------------
static void constructor_17075( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNjet>();
  else ::new(mem) ::edm::Wrapper<BNjet>();
}

static void constructor_17076( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNjet>(*(::std::auto_ptr<BNjet>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNjet>(*(::std::auto_ptr<BNjet>*)arg[0]);
}

static void destructor_17077(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNjet>*)o)->::edm::Wrapper<BNjet>::~Wrapper)();
}
static  void method_17078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNjet>*)o)->product)());
  else   (((const ::edm::Wrapper<BNjet>*)o)->product)();
}

static  void operator_17079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNjet>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNjet>*)o)->operator->)();
}

static  void method_17080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNjet>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNjet>*)o)->productTypeInfo)();
}

static  void method_17081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNjet>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNjet>*)o)->typeInfo)();
}

static void constructor_17082( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNjet>((::BNjet*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNjet>((::BNjet*)arg[0]);
}

static  void method_17083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNjet>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNjet>*)o)->getInterface)();
}

static  void method_17084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNjet>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17085( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNjet>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17086( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNjet>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNjet>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNjet>*)o)->dynamicTypeInfo)();
}

static  void method_17088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNjet>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNjet>*)o)->isPresent)();
}

static  void method_17089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNjet>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNjet>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4074( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNjet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNjet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNjet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNjet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNjet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNjet> -------------------------------
void __edm__Wrapper_BNjet__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNjet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNjet__datamem_bld(&__edm__Wrapper_BNjet__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNjet__funcmem_bld(&__edm__Wrapper_BNjet__db_funcmem);
void __edm__Wrapper_BNjet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNjet>"), typeid(::edm::Wrapper<BNjet>), sizeof(::edm::Wrapper<BNjet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNjet>")
  .AddTypedef(type_508, Reflex::Literal("edm::Wrapper<BNjet>::value_type"))
  .AddTypedef(type_508, Reflex::Literal("edm::Wrapper<BNjet>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17075, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2089), Reflex::Literal("Wrapper"), constructor_17076, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17077, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3376), Reflex::Literal("Wrapper"), constructor_17082, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4074, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNjet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNjet__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNjet> -------------------
void __edm__Wrapper_BNjet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNjet_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_508, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNjet_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNjet> -------------------
void __edm__Wrapper_BNjet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3378), Reflex::Literal("product"), method_17078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3378), Reflex::Literal("operator->"), operator_17079, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_17080, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_17081, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25850), Reflex::Literal("getInterface"), method_17083, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17084, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17085, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17086, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17088, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNtau, std::allocator<BNtau> > > -------------------------------
static void constructor_17096( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNtau> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNtau> >();
}

static void constructor_17097( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNtau> >(*(::std::auto_ptr<std::vector<BNtau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNtau> >(*(::std::auto_ptr<std::vector<BNtau> >*)arg[0]);
}

static void destructor_17098(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNtau> >*)o)->::edm::Wrapper<std::vector<BNtau> >::~Wrapper)();
}
static  void method_17099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNtau> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNtau> >*)o)->product)();
}

static  void operator_17100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNtau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNtau> >*)o)->operator->)();
}

static  void method_17101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNtau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNtau> >*)o)->productTypeInfo)();
}

static  void method_17102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNtau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNtau> >*)o)->typeInfo)();
}

static void constructor_17103( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNtau> >((::std::vector<BNtau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNtau> >((::std::vector<BNtau>*)arg[0]);
}

static  void method_17104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNtau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNtau> >*)o)->getInterface)();
}

static  void method_17105( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNtau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17106( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNtau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17107( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNtau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNtau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNtau> >*)o)->dynamicTypeInfo)();
}

static  void method_17109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNtau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNtau> >*)o)->isPresent)();
}

static  void method_17110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNtau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNtau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4075( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNtau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNtau, std::allocator<BNtau> > > -------------------------------
void __edm__Wrapper_std__vector_BNtau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNtau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNtau_s__datamem_bld(&__edm__Wrapper_std__vector_BNtau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNtau_s__funcmem_bld(&__edm__Wrapper_std__vector_BNtau_s__db_funcmem);
void __edm__Wrapper_std__vector_BNtau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNtau> >"), typeid(::edm::Wrapper<std::vector<BNtau> >), sizeof(::edm::Wrapper<std::vector<BNtau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1403, Reflex::Literal("edm::Wrapper<std::vector<BNtau> >::value_type"))
  .AddTypedef(type_1403, Reflex::Literal("edm::Wrapper<std::vector<BNtau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17096, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2090), Reflex::Literal("Wrapper"), constructor_17097, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17098, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25854), Reflex::Literal("Wrapper"), constructor_17103, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4075, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNtau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNtau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNtau, std::allocator<BNtau> > > -------------------
void __edm__Wrapper_std__vector_BNtau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNtau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1403, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNtau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNtau, std::allocator<BNtau> > > -------------------
void __edm__Wrapper_std__vector_BNtau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25853), Reflex::Literal("product"), method_17099, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25853), Reflex::Literal("operator->"), operator_17100, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_17101, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_17102, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25855), Reflex::Literal("getInterface"), method_17104, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17105, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17106, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17107, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNtau> -------------------------------
static void constructor_17117( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNtau>();
  else ::new(mem) ::edm::Wrapper<BNtau>();
}

static void constructor_17118( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNtau>(*(::std::auto_ptr<BNtau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNtau>(*(::std::auto_ptr<BNtau>*)arg[0]);
}

static void destructor_17119(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNtau>*)o)->::edm::Wrapper<BNtau>::~Wrapper)();
}
static  void method_17120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNtau>*)o)->product)());
  else   (((const ::edm::Wrapper<BNtau>*)o)->product)();
}

static  void operator_17121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNtau>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNtau>*)o)->operator->)();
}

static  void method_17122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNtau>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNtau>*)o)->productTypeInfo)();
}

static  void method_17123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNtau>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNtau>*)o)->typeInfo)();
}

static void constructor_17124( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNtau>((::BNtau*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNtau>((::BNtau*)arg[0]);
}

static  void method_17125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNtau>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNtau>*)o)->getInterface)();
}

static  void method_17126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNtau>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17127( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNtau>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17128( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNtau>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNtau>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNtau>*)o)->dynamicTypeInfo)();
}

static  void method_17130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNtau>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNtau>*)o)->isPresent)();
}

static  void method_17131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNtau>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNtau>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4076( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNtau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNtau> -------------------------------
void __edm__Wrapper_BNtau__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNtau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNtau__datamem_bld(&__edm__Wrapper_BNtau__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNtau__funcmem_bld(&__edm__Wrapper_BNtau__db_funcmem);
void __edm__Wrapper_BNtau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNtau>"), typeid(::edm::Wrapper<BNtau>), sizeof(::edm::Wrapper<BNtau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNtau>")
  .AddTypedef(type_1681, Reflex::Literal("edm::Wrapper<BNtau>::value_type"))
  .AddTypedef(type_1681, Reflex::Literal("edm::Wrapper<BNtau>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17117, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2091), Reflex::Literal("Wrapper"), constructor_17118, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17119, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5435), Reflex::Literal("Wrapper"), constructor_17124, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4076, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNtau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNtau__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNtau> -------------------
void __edm__Wrapper_BNtau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNtau_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1681, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNtau_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNtau> -------------------
void __edm__Wrapper_BNtau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5437), Reflex::Literal("product"), method_17120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5437), Reflex::Literal("operator->"), operator_17121, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_17122, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_17123, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25858), Reflex::Literal("getInterface"), method_17125, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17126, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17127, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17128, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNelectron, std::allocator<BNelectron> > > -------------------------------
static void constructor_17138( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNelectron> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNelectron> >();
}

static void constructor_17139( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNelectron> >(*(::std::auto_ptr<std::vector<BNelectron> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNelectron> >(*(::std::auto_ptr<std::vector<BNelectron> >*)arg[0]);
}

static void destructor_17140(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNelectron> >*)o)->::edm::Wrapper<std::vector<BNelectron> >::~Wrapper)();
}
static  void method_17141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->product)();
}

static  void operator_17142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->operator->)();
}

static  void method_17143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNelectron> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNelectron> >*)o)->productTypeInfo)();
}

static  void method_17144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNelectron> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNelectron> >*)o)->typeInfo)();
}

static void constructor_17145( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNelectron> >((::std::vector<BNelectron>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNelectron> >((::std::vector<BNelectron>*)arg[0]);
}

static  void method_17146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNelectron> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNelectron> >*)o)->getInterface)();
}

static  void method_17147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17148( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17149( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->dynamicTypeInfo)();
}

static  void method_17151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->isPresent)();
}

static  void method_17152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNelectron> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4077( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNelectron> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNelectron> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNelectron> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNelectron> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNelectron> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNelectron, std::allocator<BNelectron> > > -------------------------------
void __edm__Wrapper_std__vector_BNelectron_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNelectron_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNelectron_s__datamem_bld(&__edm__Wrapper_std__vector_BNelectron_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNelectron_s__funcmem_bld(&__edm__Wrapper_std__vector_BNelectron_s__db_funcmem);
void __edm__Wrapper_std__vector_BNelectron_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNelectron> >"), typeid(::edm::Wrapper<std::vector<BNelectron> >), sizeof(::edm::Wrapper<std::vector<BNelectron> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_549, Reflex::Literal("edm::Wrapper<std::vector<BNelectron> >::value_type"))
  .AddTypedef(type_549, Reflex::Literal("edm::Wrapper<std::vector<BNelectron> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17138, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2092), Reflex::Literal("Wrapper"), constructor_17139, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17140, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25862), Reflex::Literal("Wrapper"), constructor_17145, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4077, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNelectron_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNelectron_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNelectron, std::allocator<BNelectron> > > -------------------
void __edm__Wrapper_std__vector_BNelectron_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNelectron_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_549, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNelectron_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNelectron, std::allocator<BNelectron> > > -------------------
void __edm__Wrapper_std__vector_BNelectron_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25861), Reflex::Literal("product"), method_17141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25861), Reflex::Literal("operator->"), operator_17142, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_17143, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_17144, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25863), Reflex::Literal("getInterface"), method_17146, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17147, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17148, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17149, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17150, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17151, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17152, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNelectron> -------------------------------
static void constructor_17159( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNelectron>();
  else ::new(mem) ::edm::Wrapper<BNelectron>();
}

static void constructor_17160( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNelectron>(*(::std::auto_ptr<BNelectron>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNelectron>(*(::std::auto_ptr<BNelectron>*)arg[0]);
}

static void destructor_17161(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNelectron>*)o)->::edm::Wrapper<BNelectron>::~Wrapper)();
}
static  void method_17162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNelectron>*)o)->product)());
  else   (((const ::edm::Wrapper<BNelectron>*)o)->product)();
}

static  void operator_17163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNelectron>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNelectron>*)o)->operator->)();
}

static  void method_17164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNelectron>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNelectron>*)o)->productTypeInfo)();
}

static  void method_17165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNelectron>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNelectron>*)o)->typeInfo)();
}

static void constructor_17166( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNelectron>((::BNelectron*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNelectron>((::BNelectron*)arg[0]);
}

static  void method_17167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNelectron>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNelectron>*)o)->getInterface)();
}

static  void method_17168( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNelectron>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17169( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNelectron>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17170( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNelectron>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNelectron>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNelectron>*)o)->dynamicTypeInfo)();
}

static  void method_17172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNelectron>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNelectron>*)o)->isPresent)();
}

static  void method_17173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNelectron>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNelectron>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4078( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNelectron> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNelectron> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNelectron> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNelectron> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNelectron> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNelectron> -------------------------------
void __edm__Wrapper_BNelectron__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNelectron__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNelectron__datamem_bld(&__edm__Wrapper_BNelectron__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNelectron__funcmem_bld(&__edm__Wrapper_BNelectron__db_funcmem);
void __edm__Wrapper_BNelectron__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNelectron>"), typeid(::edm::Wrapper<BNelectron>), sizeof(::edm::Wrapper<BNelectron>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNelectron>")
  .AddTypedef(type_1510, Reflex::Literal("edm::Wrapper<BNelectron>::value_type"))
  .AddTypedef(type_1510, Reflex::Literal("edm::Wrapper<BNelectron>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17159, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2093), Reflex::Literal("Wrapper"), constructor_17160, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17161, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4775), Reflex::Literal("Wrapper"), constructor_17166, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4078, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNelectron__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNelectron__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNelectron> -------------------
void __edm__Wrapper_BNelectron__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNelectron_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1510, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNelectron_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNelectron> -------------------
void __edm__Wrapper_BNelectron__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4777), Reflex::Literal("product"), method_17162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4777), Reflex::Literal("operator->"), operator_17163, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_17164, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_17165, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25866), Reflex::Literal("getInterface"), method_17167, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17168, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17169, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17170, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<BNbxlumi, std::allocator<BNbxlumi> > > -------------------------------
static void constructor_17180( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNbxlumi> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BNbxlumi> >();
}

static void constructor_17181( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNbxlumi> >(*(::std::auto_ptr<std::vector<BNbxlumi> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNbxlumi> >(*(::std::auto_ptr<std::vector<BNbxlumi> >*)arg[0]);
}

static void destructor_17182(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BNbxlumi> >*)o)->::edm::Wrapper<std::vector<BNbxlumi> >::~Wrapper)();
}
static  void method_17183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->product)();
}

static  void operator_17184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->operator->)();
}

static  void method_17185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNbxlumi> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BNbxlumi> >*)o)->productTypeInfo)();
}

static  void method_17186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BNbxlumi> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BNbxlumi> >*)o)->typeInfo)();
}

static void constructor_17187( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BNbxlumi> >((::std::vector<BNbxlumi>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BNbxlumi> >((::std::vector<BNbxlumi>*)arg[0]);
}

static  void method_17188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BNbxlumi> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BNbxlumi> >*)o)->getInterface)();
}

static  void method_17189( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17190( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->dynamicTypeInfo)();
}

static  void method_17193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->isPresent)();
}

static  void method_17194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BNbxlumi> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4079( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNbxlumi> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNbxlumi> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNbxlumi> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNbxlumi> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BNbxlumi> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BNbxlumi, std::allocator<BNbxlumi> > > -------------------------------
void __edm__Wrapper_std__vector_BNbxlumi_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BNbxlumi_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNbxlumi_s__datamem_bld(&__edm__Wrapper_std__vector_BNbxlumi_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BNbxlumi_s__funcmem_bld(&__edm__Wrapper_std__vector_BNbxlumi_s__db_funcmem);
void __edm__Wrapper_std__vector_BNbxlumi_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BNbxlumi> >"), typeid(::edm::Wrapper<std::vector<BNbxlumi> >), sizeof(::edm::Wrapper<std::vector<BNbxlumi> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1723, Reflex::Literal("edm::Wrapper<std::vector<BNbxlumi> >::value_type"))
  .AddTypedef(type_1723, Reflex::Literal("edm::Wrapper<std::vector<BNbxlumi> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17180, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2094), Reflex::Literal("Wrapper"), constructor_17181, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17182, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25870), Reflex::Literal("Wrapper"), constructor_17187, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4079, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BNbxlumi_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BNbxlumi_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BNbxlumi, std::allocator<BNbxlumi> > > -------------------
void __edm__Wrapper_std__vector_BNbxlumi_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNbxlumi_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1723, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BNbxlumi_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BNbxlumi, std::allocator<BNbxlumi> > > -------------------
void __edm__Wrapper_std__vector_BNbxlumi_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25869), Reflex::Literal("product"), method_17183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25869), Reflex::Literal("operator->"), operator_17184, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_17185, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_17186, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25871), Reflex::Literal("getInterface"), method_17188, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17189, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17190, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17191, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17194, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BNbxlumi> -------------------------------
static void constructor_17201( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNbxlumi>();
  else ::new(mem) ::edm::Wrapper<BNbxlumi>();
}

static void constructor_17202( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNbxlumi>(*(::std::auto_ptr<BNbxlumi>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNbxlumi>(*(::std::auto_ptr<BNbxlumi>*)arg[0]);
}

static void destructor_17203(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BNbxlumi>*)o)->::edm::Wrapper<BNbxlumi>::~Wrapper)();
}
static  void method_17204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNbxlumi>*)o)->product)());
  else   (((const ::edm::Wrapper<BNbxlumi>*)o)->product)();
}

static  void operator_17205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BNbxlumi>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BNbxlumi>*)o)->operator->)();
}

static  void method_17206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNbxlumi>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BNbxlumi>*)o)->productTypeInfo)();
}

static  void method_17207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BNbxlumi>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BNbxlumi>*)o)->typeInfo)();
}

static void constructor_17208( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BNbxlumi>((::BNbxlumi*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BNbxlumi>((::BNbxlumi*)arg[0]);
}

static  void method_17209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BNbxlumi>*)o)->getInterface)());
  else   (((::edm::Wrapper<BNbxlumi>*)o)->getInterface)();
}

static  void method_17210( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNbxlumi>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17211( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNbxlumi>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17212( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BNbxlumi>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNbxlumi>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BNbxlumi>*)o)->dynamicTypeInfo)();
}

static  void method_17214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BNbxlumi>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BNbxlumi>*)o)->isPresent)();
}

static  void method_17215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BNbxlumi>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BNbxlumi>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4080( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNbxlumi> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNbxlumi> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNbxlumi> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNbxlumi> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BNbxlumi> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BNbxlumi> -------------------------------
void __edm__Wrapper_BNbxlumi__db_datamem(Reflex::Class*);
void __edm__Wrapper_BNbxlumi__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNbxlumi__datamem_bld(&__edm__Wrapper_BNbxlumi__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BNbxlumi__funcmem_bld(&__edm__Wrapper_BNbxlumi__db_funcmem);
void __edm__Wrapper_BNbxlumi__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BNbxlumi>"), typeid(::edm::Wrapper<BNbxlumi>), sizeof(::edm::Wrapper<BNbxlumi>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<BNbxlumi>")
  .AddTypedef(type_1299, Reflex::Literal("edm::Wrapper<BNbxlumi>::value_type"))
  .AddTypedef(type_1299, Reflex::Literal("edm::Wrapper<BNbxlumi>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17201, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2095), Reflex::Literal("Wrapper"), constructor_17202, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17203, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6229), Reflex::Literal("Wrapper"), constructor_17208, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4080, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BNbxlumi__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BNbxlumi__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BNbxlumi> -------------------
void __edm__Wrapper_BNbxlumi__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BNbxlumi_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1299, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BNbxlumi_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BNbxlumi> -------------------
void __edm__Wrapper_BNbxlumi__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6231), Reflex::Literal("product"), method_17204, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6231), Reflex::Literal("operator->"), operator_17205, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_17206, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_17207, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25874), Reflex::Literal("getInterface"), method_17209, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17210, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17211, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17212, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17214, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17215, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<SampleProd, std::allocator<SampleProd> > > -------------------------------
static void constructor_17222( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<SampleProd> >();
  else ::new(mem) ::edm::Wrapper<std::vector<SampleProd> >();
}

static void constructor_17223( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<SampleProd> >(*(::std::auto_ptr<std::vector<SampleProd> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<SampleProd> >(*(::std::auto_ptr<std::vector<SampleProd> >*)arg[0]);
}

static void destructor_17224(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<SampleProd> >*)o)->::edm::Wrapper<std::vector<SampleProd> >::~Wrapper)();
}
static  void method_17225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->product)();
}

static  void operator_17226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->operator->)();
}

static  void method_17227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<SampleProd> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<SampleProd> >*)o)->productTypeInfo)();
}

static  void method_17228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<SampleProd> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<SampleProd> >*)o)->typeInfo)();
}

static void constructor_17229( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<SampleProd> >((::std::vector<SampleProd>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<SampleProd> >((::std::vector<SampleProd>*)arg[0]);
}

static  void method_17230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<SampleProd> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<SampleProd> >*)o)->getInterface)();
}

static  void method_17231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17232( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17233( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->dynamicTypeInfo)();
}

static  void method_17235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->isPresent)();
}

static  void method_17236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<SampleProd> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4081( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<SampleProd> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<SampleProd> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<SampleProd> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<SampleProd> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<SampleProd> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<SampleProd, std::allocator<SampleProd> > > -------------------------------
void __edm__Wrapper_std__vector_SampleProd_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_SampleProd_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_SampleProd_s__datamem_bld(&__edm__Wrapper_std__vector_SampleProd_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_SampleProd_s__funcmem_bld(&__edm__Wrapper_std__vector_SampleProd_s__db_funcmem);
void __edm__Wrapper_std__vector_SampleProd_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<SampleProd> >"), typeid(::edm::Wrapper<std::vector<SampleProd> >), sizeof(::edm::Wrapper<std::vector<SampleProd> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_288, Reflex::Literal("edm::Wrapper<std::vector<SampleProd> >::value_type"))
  .AddTypedef(type_288, Reflex::Literal("edm::Wrapper<std::vector<SampleProd> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17222, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2096), Reflex::Literal("Wrapper"), constructor_17223, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17224, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25878), Reflex::Literal("Wrapper"), constructor_17229, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4081, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_SampleProd_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_SampleProd_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<SampleProd, std::allocator<SampleProd> > > -------------------
void __edm__Wrapper_std__vector_SampleProd_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_SampleProd_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_288, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_SampleProd_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<SampleProd, std::allocator<SampleProd> > > -------------------
void __edm__Wrapper_std__vector_SampleProd_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25877), Reflex::Literal("product"), method_17225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25877), Reflex::Literal("operator->"), operator_17226, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_17227, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_17228, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25879), Reflex::Literal("getInterface"), method_17230, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17231, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17232, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17233, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17236, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<SampleProd> -------------------------------
static void constructor_17243( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<SampleProd>();
  else ::new(mem) ::edm::Wrapper<SampleProd>();
}

static void constructor_17244( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<SampleProd>(*(::std::auto_ptr<SampleProd>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<SampleProd>(*(::std::auto_ptr<SampleProd>*)arg[0]);
}

static void destructor_17245(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<SampleProd>*)o)->::edm::Wrapper<SampleProd>::~Wrapper)();
}
static  void method_17246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<SampleProd>*)o)->product)());
  else   (((const ::edm::Wrapper<SampleProd>*)o)->product)();
}

static  void operator_17247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<SampleProd>*)o)->operator->)());
  else   (((const ::edm::Wrapper<SampleProd>*)o)->operator->)();
}

static  void method_17248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<SampleProd>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<SampleProd>*)o)->productTypeInfo)();
}

static  void method_17249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<SampleProd>*)o)->typeInfo)();
  else   (((::edm::Wrapper<SampleProd>*)o)->typeInfo)();
}

static void constructor_17250( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<SampleProd>((::SampleProd*)arg[0]);
  else ::new(mem) ::edm::Wrapper<SampleProd>((::SampleProd*)arg[0]);
}

static  void method_17251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<SampleProd>*)o)->getInterface)());
  else   (((::edm::Wrapper<SampleProd>*)o)->getInterface)();
}

static  void method_17252( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<SampleProd>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17253( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<SampleProd>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17254( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<SampleProd>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<SampleProd>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<SampleProd>*)o)->dynamicTypeInfo)();
}

static  void method_17256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<SampleProd>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<SampleProd>*)o)->isPresent)();
}

static  void method_17257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<SampleProd>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<SampleProd>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4082( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<SampleProd> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<SampleProd> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<SampleProd> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<SampleProd> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<SampleProd> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<SampleProd> -------------------------------
void __edm__Wrapper_SampleProd__db_datamem(Reflex::Class*);
void __edm__Wrapper_SampleProd__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_SampleProd__datamem_bld(&__edm__Wrapper_SampleProd__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_SampleProd__funcmem_bld(&__edm__Wrapper_SampleProd__db_funcmem);
void __edm__Wrapper_SampleProd__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<SampleProd>"), typeid(::edm::Wrapper<SampleProd>), sizeof(::edm::Wrapper<SampleProd>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "edm::Wrapper<SampleProd>")
  .AddTypedef(type_843, Reflex::Literal("edm::Wrapper<SampleProd>::value_type"))
  .AddTypedef(type_843, Reflex::Literal("edm::Wrapper<SampleProd>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17243, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2097), Reflex::Literal("Wrapper"), constructor_17244, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17245, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3967), Reflex::Literal("Wrapper"), constructor_17250, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4082, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_SampleProd__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_SampleProd__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<SampleProd> -------------------
void __edm__Wrapper_SampleProd__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2862, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_SampleProd_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_843, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_SampleProd_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<SampleProd> -------------------
void __edm__Wrapper_SampleProd__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3969), Reflex::Literal("product"), method_17246, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3969), Reflex::Literal("operator->"), operator_17247, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("productTypeInfo"), method_17248, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("typeInfo"), method_17249, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25882), Reflex::Literal("getInterface"), method_17251, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_17303, type_21533, type_22146), Reflex::Literal("fillView"), method_17252, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_243, type_7491), Reflex::Literal("setPtr"), method_17253, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2827, type_4030, type_21534, type_21533), Reflex::Literal("fillPtrVector"), method_17254, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo"), method_17255, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2862), Reflex::Literal("isPresent"), method_17256, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4030), Reflex::Literal("dynamicTypeInfo_"), method_17257, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __BNevent_dict(); 
      __std__vector_BNevent__dict(); 
      __BNmcparticle_dict(); 
      __BNskimbit_dict(); 
      __std__vector_BNskimbit__dict(); 
      __BNtrigobj_dict(); 
      __std__vector_BNtrigobj__dict(); 
      __BNtrack_dict(); 
      __std__vector_BNtrack__dict(); 
      __BNtrigger_dict(); 
      __std__vector_BNtrigger__dict(); 
      __BNjet_dict(); 
      __std__vector_BNjet__dict(); 
      __BNsupercluster_dict(); 
      __SampleProd_dict(); 
      __std__vector_SampleProd__dict(); 
      __BNmuon_dict(); 
      __std__vector_BNmuon__dict(); 
      __BNelectron_dict(); 
      __std__vector_BNelectron__dict(); 
      __std__vector_BNsupercluster__dict(); 
      __BNgenjet_dict(); 
      __std__vector_BNgenjet__dict(); 
      __BNmet_dict(); 
      __BNphoton_dict(); 
      __BNlepton_dict(); 
      __BNbxlumi_dict(); 
      __std__vector_BNphoton__dict(); 
      __BNtau_dict(); 
      __std__vector_BNtau__dict(); 
      __BNprimaryvertex_dict(); 
      __std__vector_BNprimaryvertex__dict(); 
      __std__vector_BNmet__dict(); 
      __std__vector_BNbxlumi__dict(); 
      __std__vector_BNmcparticle__dict(); 
      __std__vector_BNlepton__dict(); 
      __edm__Wrapper_std__vector_BNgenjet_s__dict(); 
      __edm__Wrapper_BNgenjet__dict(); 
      __edm__Wrapper_std__vector_BNprimaryvertex_s__dict(); 
      __edm__Wrapper_BNprimaryvertex__dict(); 
      __edm__Wrapper_std__vector_BNtrigobj_s__dict(); 
      __edm__Wrapper_BNtrigobj__dict(); 
      __edm__Wrapper_std__vector_BNskimbit_s__dict(); 
      __edm__Wrapper_BNskimbit__dict(); 
      __edm__Wrapper_std__vector_BNtrigger_s__dict(); 
      __edm__Wrapper_BNtrigger__dict(); 
      __edm__Wrapper_std__vector_BNtrack_s__dict(); 
      __edm__Wrapper_BNtrack__dict(); 
      __edm__Wrapper_std__vector_BNsupercluster_s__dict(); 
      __edm__Wrapper_BNsupercluster__dict(); 
      __edm__Wrapper_std__vector_BNphoton_s__dict(); 
      __edm__Wrapper_BNphoton__dict(); 
      __edm__Wrapper_std__vector_BNlepton_s__dict(); 
      __edm__Wrapper_BNlepton__dict(); 
      __edm__Wrapper_std__vector_BNmuon_s__dict(); 
      __edm__Wrapper_BNmuon__dict(); 
      __edm__Wrapper_std__vector_BNmet_s__dict(); 
      __edm__Wrapper_BNmet__dict(); 
      __edm__Wrapper_std__vector_BNmcparticle_s__dict(); 
      __edm__Wrapper_BNmcparticle__dict(); 
      __edm__Wrapper_std__vector_BNevent_s__dict(); 
      __edm__Wrapper_BNevent__dict(); 
      __edm__Wrapper_std__vector_BNjet_s__dict(); 
      __edm__Wrapper_BNjet__dict(); 
      __edm__Wrapper_std__vector_BNtau_s__dict(); 
      __edm__Wrapper_BNtau__dict(); 
      __edm__Wrapper_std__vector_BNelectron_s__dict(); 
      __edm__Wrapper_BNelectron__dict(); 
      __edm__Wrapper_std__vector_BNbxlumi_s__dict(); 
      __edm__Wrapper_BNbxlumi__dict(); 
      __edm__Wrapper_std__vector_SampleProd_s__dict(); 
      __edm__Wrapper_SampleProd__dict(); 
    }
    ~Dictionaries() {
      type_499.Unload(); // class BNevent 
      type_68.Unload(); // class std::vector<BNevent> 
      type_111.Unload(); // class BNmcparticle 
      type_891.Unload(); // class BNskimbit 
      type_125.Unload(); // class std::vector<BNskimbit> 
      type_196.Unload(); // class BNtrigobj 
      type_140.Unload(); // class std::vector<BNtrigobj> 
      type_1488.Unload(); // class BNtrack 
      type_171.Unload(); // class std::vector<BNtrack> 
      type_796.Unload(); // class BNtrigger 
      type_186.Unload(); // class std::vector<BNtrigger> 
      type_508.Unload(); // class BNjet 
      type_236.Unload(); // class std::vector<BNjet> 
      type_281.Unload(); // class BNsupercluster 
      type_843.Unload(); // class SampleProd 
      type_288.Unload(); // class std::vector<SampleProd> 
      type_336.Unload(); // class BNmuon 
      type_377.Unload(); // class std::vector<BNmuon> 
      type_1510.Unload(); // class BNelectron 
      type_549.Unload(); // class std::vector<BNelectron> 
      type_576.Unload(); // class std::vector<BNsupercluster> 
      type_1748.Unload(); // class BNgenjet 
      type_760.Unload(); // class std::vector<BNgenjet> 
      type_868.Unload(); // class BNmet 
      type_1001.Unload(); // class BNphoton 
      type_1092.Unload(); // class BNlepton 
      type_1299.Unload(); // class BNbxlumi 
      type_1306.Unload(); // class std::vector<BNphoton> 
      type_1681.Unload(); // class BNtau 
      type_1403.Unload(); // class std::vector<BNtau> 
      type_1714.Unload(); // class BNprimaryvertex 
      type_1511.Unload(); // class std::vector<BNprimaryvertex> 
      type_1621.Unload(); // class std::vector<BNmet> 
      type_1723.Unload(); // class std::vector<BNbxlumi> 
      type_1726.Unload(); // class std::vector<BNmcparticle> 
      type_2315.Unload(); // class std::vector<BNlepton> 
      type_4047.Unload(); // class edm::Wrapper<std::vector<BNgenjet> > 
      type_4048.Unload(); // class edm::Wrapper<BNgenjet> 
      type_4049.Unload(); // class edm::Wrapper<std::vector<BNprimaryvertex> > 
      type_4050.Unload(); // class edm::Wrapper<BNprimaryvertex> 
      type_4051.Unload(); // class edm::Wrapper<std::vector<BNtrigobj> > 
      type_4052.Unload(); // class edm::Wrapper<BNtrigobj> 
      type_4053.Unload(); // class edm::Wrapper<std::vector<BNskimbit> > 
      type_4054.Unload(); // class edm::Wrapper<BNskimbit> 
      type_4055.Unload(); // class edm::Wrapper<std::vector<BNtrigger> > 
      type_4056.Unload(); // class edm::Wrapper<BNtrigger> 
      type_4057.Unload(); // class edm::Wrapper<std::vector<BNtrack> > 
      type_4058.Unload(); // class edm::Wrapper<BNtrack> 
      type_4059.Unload(); // class edm::Wrapper<std::vector<BNsupercluster> > 
      type_4060.Unload(); // class edm::Wrapper<BNsupercluster> 
      type_4061.Unload(); // class edm::Wrapper<std::vector<BNphoton> > 
      type_4062.Unload(); // class edm::Wrapper<BNphoton> 
      type_4063.Unload(); // class edm::Wrapper<std::vector<BNlepton> > 
      type_4064.Unload(); // class edm::Wrapper<BNlepton> 
      type_4065.Unload(); // class edm::Wrapper<std::vector<BNmuon> > 
      type_4066.Unload(); // class edm::Wrapper<BNmuon> 
      type_4067.Unload(); // class edm::Wrapper<std::vector<BNmet> > 
      type_4068.Unload(); // class edm::Wrapper<BNmet> 
      type_4069.Unload(); // class edm::Wrapper<std::vector<BNmcparticle> > 
      type_4070.Unload(); // class edm::Wrapper<BNmcparticle> 
      type_4071.Unload(); // class edm::Wrapper<std::vector<BNevent> > 
      type_4072.Unload(); // class edm::Wrapper<BNevent> 
      type_4073.Unload(); // class edm::Wrapper<std::vector<BNjet> > 
      type_4074.Unload(); // class edm::Wrapper<BNjet> 
      type_4075.Unload(); // class edm::Wrapper<std::vector<BNtau> > 
      type_4076.Unload(); // class edm::Wrapper<BNtau> 
      type_4077.Unload(); // class edm::Wrapper<std::vector<BNelectron> > 
      type_4078.Unload(); // class edm::Wrapper<BNelectron> 
      type_4079.Unload(); // class edm::Wrapper<std::vector<BNbxlumi> > 
      type_4080.Unload(); // class edm::Wrapper<BNbxlumi> 
      type_4081.Unload(); // class edm::Wrapper<std::vector<SampleProd> > 
      type_4082.Unload(); // class edm::Wrapper<SampleProd> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
