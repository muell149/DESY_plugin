// Generated at Tue Jan 21 10:57:26 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/pscratch/osg/app/cmssoft/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/AnalysisDataFormats/TopObjects/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("reco") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("edm::reftobase") );
  ::Reflex::Type type_74 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_435 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_332 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_354 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1798 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_200 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_111 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_2674 = ::Reflex::TypeBuilder(Reflex::Literal("TtEvent"));
  ::Reflex::Type type_12929 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Jet"));
  ::Reflex::Type type_12916 = ::Reflex::TypeBuilder(Reflex::Literal("pat::MET"));
  ::Reflex::Type type_12983 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Tau"));
  ::Reflex::Type type_12913 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Muon"));
  ::Reflex::Type type_1829 = ::Reflex::TypeBuilder(Reflex::Literal("TtGenEvent"));
  ::Reflex::Type type_2546 = ::Reflex::TypeBuilder(Reflex::Literal("StGenEvent"));
  ::Reflex::Type type_398 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_2227 = ::Reflex::TypeBuilder(Reflex::Literal("TopGenEvent"));
  ::Reflex::Type type_5999 = ::Reflex::TypeBuilder(Reflex::Literal("edm::LogInfo"));
  ::Reflex::Type type_389 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_6595 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCore"));
  ::Reflex::Type type_1709 = ::Reflex::TypeBuilder(Reflex::Literal("StEvtSolution"));
  ::Reflex::Type type_549 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_12981 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Electron"));
  ::Reflex::Type type_12943 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Particle"));
  ::Reflex::Type type_6592 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_11523 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Particle"));
  ::Reflex::Type type_8865 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate"));
  ::Reflex::Type type_977 = ::Reflex::TypeBuilder(Reflex::Literal("TtSemiEvtSolution"));
  ::Reflex::Type type_1805 = ::Reflex::TypeBuilder(Reflex::Literal("TtHadEvtSolution"));
  ::Reflex::Type type_3559 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_11668 = ::Reflex::TypeBuilder(Reflex::Literal("reco::JetTagInfo"));
  ::Reflex::Type type_6709 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Jet>"));
  ::Reflex::Type type_6706 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::MET>"));
  ::Reflex::Type type_11338 = ::Reflex::TypeBuilder(Reflex::Literal("reco::GenParticle"));
  ::Reflex::Type type_2053 = ::Reflex::TypeBuilder(Reflex::Literal("TtDilepEvtSolution"));
  ::Reflex::Type type_11468 = ::Reflex::TypeBuilder(Reflex::Literal("reco::BaseTagInfo"));
  ::Reflex::Type type_6708 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Muon>"));
  ::Reflex::Type type_1100 = ::Reflex::TypeBuilder(Reflex::Literal("TtFullHadronicEvent"));
  ::Reflex::Type type_1227 = ::Reflex::TypeBuilder(Reflex::Literal("TtSemiLeptonicEvent"));
  ::Reflex::Type type_3597 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_2790 = ::Reflex::TypeBuilder(Reflex::Literal("TtFullLeptonicEvent"));
  ::Reflex::Type type_6742 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDProductGetter"));
  ::Reflex::Type type_6828 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCoreWithIndex"));
  ::Reflex::Type type_11359 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CATopJetTagInfo"));
  ::Reflex::Type type_6707 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Electron>"));
  ::Reflex::Type type_2977 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_6838 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<TtGenEvent>"));
  ::Reflex::Type type_10621 = ::Reflex::EnumTypeBuilder(Reflex::Literal("WDecay::LeptonType"));
  ::Reflex::Type type_6851 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<StGenEvent>"));
  ::Reflex::Type type_6625 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<TtGenEvent>"));
  ::Reflex::Type type_6624 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<StGenEvent>"));
  ::Reflex::Type type_3550 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_6833 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<TopGenEvent>"));
  ::Reflex::Type type_6266 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<StGenEvent>"));
  ::Reflex::Type type_6267 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TtGenEvent>"));
  ::Reflex::Type type_11644 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CompositeCandidate"));
  ::Reflex::Type type_6690 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<reco::Jet>"));
  ::Reflex::Type type_11390 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CATopJetProperties"));
  ::Reflex::Type type_3252 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<StGenEvent>"));
  ::Reflex::Type type_3253 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TtGenEvent>"));
  ::Reflex::Type type_6623 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<TopGenEvent>"));
  ::Reflex::Type type_3552 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_6265 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TopGenEvent>"));
  ::Reflex::Type type_3561 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Particle>"));
  ::Reflex::Type type_13152 = ::Reflex::EnumTypeBuilder(Reflex::Literal("TtEvent::HypoClassKey"));
  ::Reflex::Type type_3554 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<StEvtSolution>"));
  ::Reflex::Type type_3551 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3251 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TopGenEvent>"));
  ::Reflex::Type type_6427 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<StGenEvent>"));
  ::Reflex::Type type_6459 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<TtGenEvent>"));
  ::Reflex::Type type_6411 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<TopGenEvent>"));
  ::Reflex::Type type_3978 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<StEvtSolution>"));
  ::Reflex::Type type_3555 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TtHadEvtSolution>"));
  ::Reflex::Type type_6542 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<StGenEvent>"));
  ::Reflex::Type type_6574 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<TtGenEvent>"));
  ::Reflex::Type type_3578 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::GenParticle>"));
  ::Reflex::Type type_3556 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TtSemiEvtSolution>"));
  ::Reflex::Type type_6526 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<TopGenEvent>"));
  ::Reflex::Type type_19143 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase"));
  ::Reflex::Type type_3557 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TtDilepEvtSolution>"));
  ::Reflex::Type type_3979 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TtHadEvtSolution>"));
  ::Reflex::Type type_3126 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<TtEvent::HypoClassKey>"));
  ::Reflex::Type type_6830 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<TtFullHadronicEvent>"));
  ::Reflex::Type type_6831 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<TtSemiLeptonicEvent>"));
  ::Reflex::Type type_6832 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<TtFullLeptonicEvent>"));
  ::Reflex::Type type_5220 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorBase<unsigned int>"));
  ::Reflex::Type type_3980 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TtSemiEvtSolution>"));
  ::Reflex::Type type_6282 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<StGenEvent>"));
  ::Reflex::Type type_6283 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TtGenEvent>"));
  ::Reflex::Type type_6620 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<TtFullHadronicEvent>"));
  ::Reflex::Type type_6621 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<TtSemiLeptonicEvent>"));
  ::Reflex::Type type_6622 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<TtFullLeptonicEvent>"));
  ::Reflex::Type type_6262 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TtFullHadronicEvent>"));
  ::Reflex::Type type_6263 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TtSemiLeptonicEvent>"));
  ::Reflex::Type type_6264 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<TtFullLeptonicEvent>"));
  ::Reflex::Type type_3553 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::CATopJetTagInfo>"));
  ::Reflex::Type type_3981 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TtDilepEvtSolution>"));
  ::Reflex::Type type_3248 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TtFullHadronicEvent>"));
  ::Reflex::Type type_3249 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TtSemiLeptonicEvent>"));
  ::Reflex::Type type_3250 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<TtFullLeptonicEvent>"));
  ::Reflex::Type type_6281 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TopGenEvent>"));
  ::Reflex::Type type_3844 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<TtEvent::HypoClassKey,int>"));
  ::Reflex::Type type_6837 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Jet> >"));
  ::Reflex::Type type_6597 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase"));
  ::Reflex::Type type_6408 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<TtFullHadronicEvent>"));
  ::Reflex::Type type_6409 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<TtSemiLeptonicEvent>"));
  ::Reflex::Type type_6410 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<TtFullLeptonicEvent>"));
  ::Reflex::Type type_3634 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const reco::GenParticle*>"));
  ::Reflex::Type type_3977 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::CATopJetTagInfo>"));
  ::Reflex::Type type_6523 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<TtFullHadronicEvent>"));
  ::Reflex::Type type_6524 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<TtSemiLeptonicEvent>"));
  ::Reflex::Type type_6525 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<TtFullLeptonicEvent>"));
  ::Reflex::Type type_6261 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::CompositeCandidate>"));
  ::Reflex::Type type_3247 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::CompositeCandidate>"));
  ::Reflex::Type type_6256 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<StEvtSolution> >"));
  ::Reflex::Type type_3461 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const TtEvent::HypoClassKey,int>"));
  ::Reflex::Type type_3242 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<StEvtSolution> >"));
  ::Reflex::Type type_6278 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TtFullHadronicEvent>"));
  ::Reflex::Type type_6279 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TtSemiLeptonicEvent>"));
  ::Reflex::Type type_6280 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<TtFullLeptonicEvent>"));
  ::Reflex::Type type_3560 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<unsigned int,double> >"));
  ::Reflex::Type type_3240 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefHolderBase>"));
  ::Reflex::Type type_6257 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<TtHadEvtSolution> >"));
  ::Reflex::Type type_6688 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::GenParticle> >"));
  ::Reflex::Type type_3243 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<TtHadEvtSolution> >"));
  ::Reflex::Type type_6258 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<TtSemiEvtSolution> >"));
  ::Reflex::Type type_3244 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<TtSemiEvtSolution> >"));
  ::Reflex::Type type_38140 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::BaseTagInfo>"));
  ::Reflex::Type type_6259 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<TtDilepEvtSolution> >"));
  ::Reflex::Type type_3245 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<TtDilepEvtSolution> >"));
  ::Reflex::Type type_6277 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::CompositeCandidate>"));
  ::Reflex::Type type_3462 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<WDecay::LeptonType,WDecay::LeptonType>"));
  ::Reflex::Type type_6829 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_6619 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_6255 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_6272 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<StEvtSolution> >"));
  ::Reflex::Type type_3241 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_3238 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_6407 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_3460 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<reco::CompositeCandidate,std::vector<int> >"));
  ::Reflex::Type type_6273 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<TtHadEvtSolution> >"));
  ::Reflex::Type type_6733 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_6274 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<TtSemiEvtSolution> >"));
  ::Reflex::Type type_6522 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_6275 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<TtDilepEvtSolution> >"));
  ::Reflex::Type type_9823 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >"));
  ::Reflex::Type type_6271 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_3985 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const TtEvent::HypoClassKey,int> >"));
  ::Reflex::Type type_3458 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>"));
  ::Reflex::Type type_2817 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<StEvtSolution,std::allocator<StEvtSolution> >"));
  ::Reflex::Type type_3558 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >"));
  ::Reflex::Type type_3786 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >"));
  ::Reflex::Type type_3239 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::BaseTagInfo> >"));
  ::Reflex::Type type_2818 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TtHadEvtSolution,std::allocator<TtHadEvtSolution> >"));
  ::Reflex::Type type_3983 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<reco::CompositeCandidate,std::vector<int> > >"));
  ::Reflex::Type type_2819 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TtSemiEvtSolution,std::allocator<TtSemiEvtSolution> >"));
  ::Reflex::Type type_11880 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >"));
  ::Reflex::Type type_2820 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TtDilepEvtSolution,std::allocator<TtDilepEvtSolution> >"));
  ::Reflex::Type type_3961 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,int> >"));
  ::Reflex::Type type_11881 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const StEvtSolution*,std::vector<StEvtSolution> >"));
  ::Reflex::Type type_11882 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >"));
  ::Reflex::Type type_2939 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_11884 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >"));
  ::Reflex::Type type_6260 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >"));
  ::Reflex::Type type_11886 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >"));
  ::Reflex::Type type_3513 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >,bool>"));
  ::Reflex::Type type_3246 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >"));
  ::Reflex::Type type_11883 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const TtHadEvtSolution*,std::vector<TtHadEvtSolution> >"));
  ::Reflex::Type type_11885 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >"));
  ::Reflex::Type type_36198 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_11887 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >"));
  ::Reflex::Type type_12107 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_4702 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> > >"));
  ::Reflex::Type type_6276 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >"));
  ::Reflex::Type type_36284 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo>"));
  ::Reflex::Type type_12108 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_4426 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> > >"));
  ::Reflex::Type type_4701 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,int> > >"));
  ::Reflex::Type type_3843 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >"));
  ::Reflex::Type type_4425 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const StEvtSolution*,std::vector<StEvtSolution> > >"));
  ::Reflex::Type type_4428 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> > >"));
  ::Reflex::Type type_4430 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> > >"));
  ::Reflex::Type type_6745 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> >"));
  ::Reflex::Type type_6746 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> >"));
  ::Reflex::Type type_6748 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> >"));
  ::Reflex::Type type_4432 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> > >"));
  ::Reflex::Type type_3459 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >"));
  ::Reflex::Type type_4427 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const TtHadEvtSolution*,std::vector<TtHadEvtSolution> > >"));
  ::Reflex::Type type_6749 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> >"));
  ::Reflex::Type type_4429 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> > >"));
  ::Reflex::Type type_4431 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> > >"));
  ::Reflex::Type type_4684 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> > >"));
  ::Reflex::Type type_4683 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> > >"));
  ::Reflex::Type type_3982 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >"));
  ::Reflex::Type type_6747 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> >"));
  ::Reflex::Type type_3787 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >"));
  ::Reflex::Type type_3962 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >"));
  ::Reflex::Type type_2946 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<reco::CompositeCandidate,std::vector<int> >,std::allocator<std::pair<reco::CompositeCandidate,std::vector<int> > > >"));
  ::Reflex::Type type_3512 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >,std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> > >"));
  ::Reflex::Type type_3516 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >,bool>"));
  ::Reflex::Type type_12121 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >"));
  ::Reflex::Type type_4704 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > > >"));
  ::Reflex::Type type_6744 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_3511 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,int> >,std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,int> > >"));
  ::Reflex::Type type_12122 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >"));
  ::Reflex::Type type_4703 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > > >"));
  ::Reflex::Type type_6001 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_5916 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >"));
  ::Reflex::Type type_4698 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >"));
  ::Reflex::Type type_4697 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >"));
  ::Reflex::Type type_38151 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >"));
  ::Reflex::Type type_38156 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >"));
  ::Reflex::Type type_36199 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >"));
  ::Reflex::Type type_3185 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<TtEvent::HypoClassKey,std::pair<const TtEvent::HypoClassKey,int>,std::_Select1st<std::pair<const TtEvent::HypoClassKey,int> >,std::less<TtEvent::HypoClassKey>,std::allocator<std::pair<const TtEvent::HypoClassKey,int> > >"));
  ::Reflex::Type type_3515 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >,std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > > >"));
  ::Reflex::Type type_3514 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >,std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > > >"));
  ::Reflex::Type type_3186 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<TtEvent::HypoClassKey,std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >,std::_Select1st<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >,std::less<TtEvent::HypoClassKey>,std::allocator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > > >"));
  ::Reflex::Type type_11337 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CATopJetTagInfoRefVector"), type_6001);
  ::Reflex::Type type_11405 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CATopJetTagInfoCollection"), type_3553);
  ::Reflex::Type type_11449 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CATopJetTagInfoRefProd"), type_6619);
  ::Reflex::Type type_11566 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CATopJetTagInfoRef"), type_6744);
  ::Reflex::Type type_2978 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2977);
  ::Reflex::Type type_20687 = ::Reflex::ReferenceBuilder(type_977);
  ::Reflex::Type type_977c = ::Reflex::ConstBuilder(type_977);
  ::Reflex::Type type_20689 = ::Reflex::ReferenceBuilder(type_977c);
  ::Reflex::Type type_6625c = ::Reflex::ConstBuilder(type_6625);
  ::Reflex::Type type_46181 = ::Reflex::ReferenceBuilder(type_6625c);
  ::Reflex::Type type_11338c = ::Reflex::ConstBuilder(type_11338);
  ::Reflex::Type type_22103 = ::Reflex::PointerBuilder(type_11338c);
  ::Reflex::Type type_11644c = ::Reflex::ConstBuilder(type_11644);
  ::Reflex::Type type_28831 = ::Reflex::ReferenceBuilder(type_11644c);
  ::Reflex::Type type_46452 = ::Reflex::ReferenceBuilder(type_1100);
  ::Reflex::Type type_1100c = ::Reflex::ConstBuilder(type_1100);
  ::Reflex::Type type_46453 = ::Reflex::ReferenceBuilder(type_1100c);
  ::Reflex::Type type_8865c = ::Reflex::ConstBuilder(type_8865);
  ::Reflex::Type type_46454 = ::Reflex::PointerBuilder(type_8865c);
  ::Reflex::Type type_2978c = ::Reflex::ConstBuilder(type_2978);
  ::Reflex::Type type_30186 = ::Reflex::ReferenceBuilder(type_2978c);
  ::Reflex::Type type_398c = ::Reflex::ConstBuilder(type_398);
  ::Reflex::Type type_16564 = ::Reflex::ReferenceBuilder(type_398c);
  ::Reflex::Type type_13152c = ::Reflex::ConstBuilder(type_13152);
  ::Reflex::Type type_46455 = ::Reflex::ReferenceBuilder(type_13152c);
  ::Reflex::Type type_74c = ::Reflex::ConstBuilder(type_74);
  ::Reflex::Type type_46479 = ::Reflex::ReferenceBuilder(type_1227);
  ::Reflex::Type type_1227c = ::Reflex::ConstBuilder(type_1227);
  ::Reflex::Type type_46480 = ::Reflex::ReferenceBuilder(type_1227c);
  ::Reflex::Type type_16670 = ::Reflex::ReferenceBuilder(type_74c);
  ::Reflex::Type type_20557 = ::Reflex::ReferenceBuilder(type_1709);
  ::Reflex::Type type_1709c = ::Reflex::ConstBuilder(type_1709);
  ::Reflex::Type type_20559 = ::Reflex::ReferenceBuilder(type_1709c);
  ::Reflex::Type type_6624c = ::Reflex::ConstBuilder(type_6624);
  ::Reflex::Type type_47411 = ::Reflex::ReferenceBuilder(type_6624c);
  ::Reflex::Type type_20622 = ::Reflex::ReferenceBuilder(type_1805);
  ::Reflex::Type type_1805c = ::Reflex::ConstBuilder(type_1805);
  ::Reflex::Type type_20624 = ::Reflex::ReferenceBuilder(type_1805c);
  ::Reflex::Type type_6838c = ::Reflex::ConstBuilder(type_6838);
  ::Reflex::Type type_46182 = ::Reflex::ReferenceBuilder(type_6838c);
  ::Reflex::Type type_6837c = ::Reflex::ConstBuilder(type_6837);
  ::Reflex::Type type_46183 = ::Reflex::ReferenceBuilder(type_6837c);
  ::Reflex::Type type_12943c = ::Reflex::ConstBuilder(type_12943);
  ::Reflex::Type type_21010 = ::Reflex::ReferenceBuilder(type_12943c);
  ::Reflex::Type type_9824 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVectorD"), type_9823);
  ::Reflex::Type type_9875 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVector"), type_9824);
  ::Reflex::Type type_47447 = ::Reflex::ReferenceBuilder(type_1829);
  ::Reflex::Type type_1829c = ::Reflex::ConstBuilder(type_1829);
  ::Reflex::Type type_47448 = ::Reflex::ReferenceBuilder(type_1829c);
  ::Reflex::Type type_11367 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GenParticleRefProd"), type_6688);
  ::Reflex::Type type_47449 = ::Reflex::ReferenceBuilder(type_11367);
  ::Reflex::Type type_9875c = ::Reflex::ConstBuilder(type_9875);
  ::Reflex::Type type_47450 = ::Reflex::PointerBuilder(type_9875c);
  ::Reflex::Type type_20752 = ::Reflex::ReferenceBuilder(type_2053);
  ::Reflex::Type type_2053c = ::Reflex::ConstBuilder(type_2053);
  ::Reflex::Type type_20754 = ::Reflex::ReferenceBuilder(type_2053c);
  ::Reflex::Type type_50116 = ::Reflex::ReferenceBuilder(type_2227);
  ::Reflex::Type type_2227c = ::Reflex::ConstBuilder(type_2227);
  ::Reflex::Type type_50117 = ::Reflex::ReferenceBuilder(type_2227c);
  ::Reflex::Type type_11436 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GenParticleCollection"), type_3578);
  ::Reflex::Type type_11436c = ::Reflex::ConstBuilder(type_11436);
  ::Reflex::Type type_50118 = ::Reflex::ReferenceBuilder(type_11436c);
  ::Reflex::Type type_55765 = ::Reflex::ReferenceBuilder(type_2546);
  ::Reflex::Type type_2546c = ::Reflex::ConstBuilder(type_2546);
  ::Reflex::Type type_55766 = ::Reflex::ReferenceBuilder(type_2546c);
  ::Reflex::Type type_57484 = ::Reflex::ReferenceBuilder(type_2674);
  ::Reflex::Type type_2674c = ::Reflex::ConstBuilder(type_2674);
  ::Reflex::Type type_57485 = ::Reflex::ReferenceBuilder(type_2674c);
  ::Reflex::Type type_57486 = ::Reflex::ReferenceBuilder(type_5999);
  ::Reflex::Type type_332c = ::Reflex::ConstBuilder(type_332);
  ::Reflex::Type type_4818 = ::Reflex::PointerBuilder(type_332c);
  ::Reflex::Type type_10621c = ::Reflex::ConstBuilder(type_10621);
  ::Reflex::Type type_57487 = ::Reflex::ReferenceBuilder(type_10621c);
  ::Reflex::Type type_3460c = ::Reflex::ConstBuilder(type_3460);
  ::Reflex::Type type_3597c = ::Reflex::ConstBuilder(type_3597);
  ::Reflex::Type type_47413 = ::Reflex::ReferenceBuilder(type_3597c);
  ::Reflex::Type type_57545 = ::Reflex::ReferenceBuilder(type_2790);
  ::Reflex::Type type_2790c = ::Reflex::ConstBuilder(type_2790);
  ::Reflex::Type type_57546 = ::Reflex::ReferenceBuilder(type_2790c);
  ::Reflex::Type type_1798c = ::Reflex::ConstBuilder(type_1798);
  ::Reflex::Type type_29960 = ::Reflex::ReferenceBuilder(type_1798c);
  ::Reflex::Type type_60050 = ::Reflex::ReferenceBuilder(type_3458);
  ::Reflex::Type type_3458c = ::Reflex::ConstBuilder(type_3458);
  ::Reflex::Type type_60051 = ::Reflex::ReferenceBuilder(type_3458c);
  ::Reflex::Type type_6690c = ::Reflex::ConstBuilder(type_6690);
  ::Reflex::Type type_60052 = ::Reflex::ReferenceBuilder(type_6690c);
  ::Reflex::Type type_11390c = ::Reflex::ConstBuilder(type_11390);
  ::Reflex::Type type_60053 = ::Reflex::ReferenceBuilder(type_11390c);
  ::Reflex::Type type_20817 = ::Reflex::ReferenceBuilder(type_3460);
  ::Reflex::Type type_20819 = ::Reflex::ReferenceBuilder(type_3460c);
  ::Reflex::Type type_3559c = ::Reflex::ConstBuilder(type_3559);
  ::Reflex::Type type_46559 = ::Reflex::ReferenceBuilder(type_3559c);
  ::Reflex::Type type_60056 = ::Reflex::ReferenceBuilder(type_3462);
  ::Reflex::Type type_3462c = ::Reflex::ConstBuilder(type_3462);
  ::Reflex::Type type_60057 = ::Reflex::ReferenceBuilder(type_3462c);
  ::Reflex::Type type_20553 = ::Reflex::PointerBuilder(type_1709);
  ::Reflex::Type type_20555 = ::Reflex::PointerBuilder(type_1709c);
  ::Reflex::Type type_3954 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_389);
  ::Reflex::Type type_3818 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_354);
  ::Reflex::Type type_3978c = ::Reflex::ConstBuilder(type_3978);
  ::Reflex::Type type_57580 = ::Reflex::ReferenceBuilder(type_3978c);
  ::Reflex::Type type_3554c = ::Reflex::ConstBuilder(type_3554);
  ::Reflex::Type type_60094 = ::Reflex::ReferenceBuilder(type_3554c);
  ::Reflex::Type type_60095 = ::Reflex::ReferenceBuilder(type_3554);
  ::Reflex::Type type_20618 = ::Reflex::PointerBuilder(type_1805);
  ::Reflex::Type type_20620 = ::Reflex::PointerBuilder(type_1805c);
  ::Reflex::Type type_3979c = ::Reflex::ConstBuilder(type_3979);
  ::Reflex::Type type_57592 = ::Reflex::ReferenceBuilder(type_3979c);
  ::Reflex::Type type_3555c = ::Reflex::ConstBuilder(type_3555);
  ::Reflex::Type type_60097 = ::Reflex::ReferenceBuilder(type_3555c);
  ::Reflex::Type type_60098 = ::Reflex::ReferenceBuilder(type_3555);
  ::Reflex::Type type_20683 = ::Reflex::PointerBuilder(type_977);
  ::Reflex::Type type_20685 = ::Reflex::PointerBuilder(type_977c);
  ::Reflex::Type type_3980c = ::Reflex::ConstBuilder(type_3980);
  ::Reflex::Type type_57604 = ::Reflex::ReferenceBuilder(type_3980c);
  ::Reflex::Type type_3556c = ::Reflex::ConstBuilder(type_3556);
  ::Reflex::Type type_60100 = ::Reflex::ReferenceBuilder(type_3556c);
  ::Reflex::Type type_60101 = ::Reflex::ReferenceBuilder(type_3556);
  ::Reflex::Type type_20748 = ::Reflex::PointerBuilder(type_2053);
  ::Reflex::Type type_20750 = ::Reflex::PointerBuilder(type_2053c);
  ::Reflex::Type type_3981c = ::Reflex::ConstBuilder(type_3981);
  ::Reflex::Type type_57616 = ::Reflex::ReferenceBuilder(type_3981c);
  ::Reflex::Type type_3557c = ::Reflex::ConstBuilder(type_3557);
  ::Reflex::Type type_60103 = ::Reflex::ReferenceBuilder(type_3557c);
  ::Reflex::Type type_60104 = ::Reflex::ReferenceBuilder(type_3557);
  ::Reflex::Type type_20813 = ::Reflex::PointerBuilder(type_3460);
  ::Reflex::Type type_20815 = ::Reflex::PointerBuilder(type_3460c);
  ::Reflex::Type type_3983c = ::Reflex::ConstBuilder(type_3983);
  ::Reflex::Type type_59121 = ::Reflex::ReferenceBuilder(type_3983c);
  ::Reflex::Type type_3558c = ::Reflex::ConstBuilder(type_3558);
  ::Reflex::Type type_60055 = ::Reflex::ReferenceBuilder(type_3558c);
  ::Reflex::Type type_60105 = ::Reflex::ReferenceBuilder(type_3558);
  ::Reflex::Type type_18360 = ::Reflex::PointerBuilder(type_3459);
  ::Reflex::Type type_3459c = ::Reflex::ConstBuilder(type_3459);
  ::Reflex::Type type_18362 = ::Reflex::PointerBuilder(type_3459c);
  ::Reflex::Type type_18364 = ::Reflex::ReferenceBuilder(type_3459);
  ::Reflex::Type type_18366 = ::Reflex::ReferenceBuilder(type_3459c);
  ::Reflex::Type type_3126c = ::Reflex::ConstBuilder(type_3126);
  ::Reflex::Type type_59694 = ::Reflex::ReferenceBuilder(type_3126c);
  ::Reflex::Type type_3982c = ::Reflex::ConstBuilder(type_3982);
  ::Reflex::Type type_59825 = ::Reflex::ReferenceBuilder(type_3982c);
  ::Reflex::Type type_3843c = ::Reflex::ConstBuilder(type_3843);
  ::Reflex::Type type_60647 = ::Reflex::ReferenceBuilder(type_3843c);
  ::Reflex::Type type_60648 = ::Reflex::ReferenceBuilder(type_3843);
  ::Reflex::Type type_18255 = ::Reflex::PointerBuilder(type_3461);
  ::Reflex::Type type_3461c = ::Reflex::ConstBuilder(type_3461);
  ::Reflex::Type type_18257 = ::Reflex::PointerBuilder(type_3461c);
  ::Reflex::Type type_18259 = ::Reflex::ReferenceBuilder(type_3461);
  ::Reflex::Type type_18261 = ::Reflex::ReferenceBuilder(type_3461c);
  ::Reflex::Type type_3985c = ::Reflex::ConstBuilder(type_3985);
  ::Reflex::Type type_59817 = ::Reflex::ReferenceBuilder(type_3985c);
  ::Reflex::Type type_3844c = ::Reflex::ConstBuilder(type_3844);
  ::Reflex::Type type_60649 = ::Reflex::ReferenceBuilder(type_3844c);
  ::Reflex::Type type_60650 = ::Reflex::ReferenceBuilder(type_3844);
  ::Reflex::Type type_16659 = ::Reflex::ReferenceBuilder(type_74);
  ::Reflex::Type type_62998 = ::Reflex::PointerBuilder(type_3554c);
  ::Reflex::Type type_549c = ::Reflex::ConstBuilder(type_549);
  ::Reflex::Type type_5901 = ::Reflex::ReferenceBuilder(type_549c);
  ::Reflex::Type type_62999 = ::Reflex::PointerBuilder(type_3554);
  ::Reflex::Type type_6272c = ::Reflex::ConstBuilder(type_6272);
  ::Reflex::Type type_63000 = ::Reflex::PointerBuilder(type_6272c);
  ::Reflex::Type type_6592c = ::Reflex::ConstBuilder(type_6592);
  ::Reflex::Type type_35422 = ::Reflex::ReferenceBuilder(type_6592c);
  ::Reflex::Type type_35543 = ::Reflex::ReferenceBuilder(type_3550);
  ::Reflex::Type type_62995 = ::Reflex::ReferenceBuilder(type_6733);
  ::Reflex::Type type_435c = ::Reflex::ConstBuilder(type_435);
  ::Reflex::Type type_5295 = ::Reflex::PointerBuilder(type_435c);
  ::Reflex::Type type_16681 = ::Reflex::ReferenceBuilder(type_5295);
  ::Reflex::Type type_3551c = ::Reflex::ConstBuilder(type_3551);
  ::Reflex::Type type_35653 = ::Reflex::ReferenceBuilder(type_3551c);
  ::Reflex::Type type_63003 = ::Reflex::PointerBuilder(type_3555c);
  ::Reflex::Type type_63004 = ::Reflex::PointerBuilder(type_3555);
  ::Reflex::Type type_6273c = ::Reflex::ConstBuilder(type_6273);
  ::Reflex::Type type_63005 = ::Reflex::PointerBuilder(type_6273c);
  ::Reflex::Type type_63008 = ::Reflex::PointerBuilder(type_3556c);
  ::Reflex::Type type_63009 = ::Reflex::PointerBuilder(type_3556);
  ::Reflex::Type type_6274c = ::Reflex::ConstBuilder(type_6274);
  ::Reflex::Type type_63010 = ::Reflex::PointerBuilder(type_6274c);
  ::Reflex::Type type_63013 = ::Reflex::PointerBuilder(type_3557c);
  ::Reflex::Type type_63014 = ::Reflex::PointerBuilder(type_3557);
  ::Reflex::Type type_6275c = ::Reflex::ConstBuilder(type_6275);
  ::Reflex::Type type_63015 = ::Reflex::PointerBuilder(type_6275c);
  ::Reflex::Type type_63018 = ::Reflex::PointerBuilder(type_3558c);
  ::Reflex::Type type_63019 = ::Reflex::PointerBuilder(type_3558);
  ::Reflex::Type type_6276c = ::Reflex::ConstBuilder(type_6276);
  ::Reflex::Type type_63020 = ::Reflex::PointerBuilder(type_6276c);
  ::Reflex::Type type_28827 = ::Reflex::PointerBuilder(type_11644c);
  ::Reflex::Type type_28825 = ::Reflex::PointerBuilder(type_11644);
  ::Reflex::Type type_6277c = ::Reflex::ConstBuilder(type_6277);
  ::Reflex::Type type_63023 = ::Reflex::PointerBuilder(type_6277c);
  ::Reflex::Type type_63026 = ::Reflex::PointerBuilder(type_1100c);
  ::Reflex::Type type_63027 = ::Reflex::PointerBuilder(type_1100);
  ::Reflex::Type type_6278c = ::Reflex::ConstBuilder(type_6278);
  ::Reflex::Type type_63028 = ::Reflex::PointerBuilder(type_6278c);
  ::Reflex::Type type_63031 = ::Reflex::PointerBuilder(type_1227c);
  ::Reflex::Type type_63032 = ::Reflex::PointerBuilder(type_1227);
  ::Reflex::Type type_6279c = ::Reflex::ConstBuilder(type_6279);
  ::Reflex::Type type_63033 = ::Reflex::PointerBuilder(type_6279c);
  ::Reflex::Type type_63036 = ::Reflex::PointerBuilder(type_2790c);
  ::Reflex::Type type_63037 = ::Reflex::PointerBuilder(type_2790);
  ::Reflex::Type type_6280c = ::Reflex::ConstBuilder(type_6280);
  ::Reflex::Type type_63038 = ::Reflex::PointerBuilder(type_6280c);
  ::Reflex::Type type_63041 = ::Reflex::PointerBuilder(type_2227c);
  ::Reflex::Type type_63042 = ::Reflex::PointerBuilder(type_2227);
  ::Reflex::Type type_6281c = ::Reflex::ConstBuilder(type_6281);
  ::Reflex::Type type_63043 = ::Reflex::PointerBuilder(type_6281c);
  ::Reflex::Type type_63046 = ::Reflex::PointerBuilder(type_2546c);
  ::Reflex::Type type_63047 = ::Reflex::PointerBuilder(type_2546);
  ::Reflex::Type type_6282c = ::Reflex::ConstBuilder(type_6282);
  ::Reflex::Type type_63048 = ::Reflex::PointerBuilder(type_6282c);
  ::Reflex::Type type_63051 = ::Reflex::PointerBuilder(type_1829c);
  ::Reflex::Type type_63052 = ::Reflex::PointerBuilder(type_1829);
  ::Reflex::Type type_6283c = ::Reflex::ConstBuilder(type_6283);
  ::Reflex::Type type_63053 = ::Reflex::PointerBuilder(type_6283c);
  ::Reflex::Type type_63349 = ::Reflex::ReferenceBuilder(type_6620);
  ::Reflex::Type type_6620c = ::Reflex::ConstBuilder(type_6620);
  ::Reflex::Type type_63350 = ::Reflex::ReferenceBuilder(type_6620c);
  ::Reflex::Type type_6830c = ::Reflex::ConstBuilder(type_6830);
  ::Reflex::Type type_63351 = ::Reflex::ReferenceBuilder(type_6830c);
  ::Reflex::Type type_6523c = ::Reflex::ConstBuilder(type_6523);
  ::Reflex::Type type_63352 = ::Reflex::ReferenceBuilder(type_6523c);
  ::Reflex::Type type_6408c = ::Reflex::ConstBuilder(type_6408);
  ::Reflex::Type type_63353 = ::Reflex::ReferenceBuilder(type_6408c);
  ::Reflex::Type type_6742c = ::Reflex::ConstBuilder(type_6742);
  ::Reflex::Type type_35539 = ::Reflex::PointerBuilder(type_6742c);
  ::Reflex::Type type_6595c = ::Reflex::ConstBuilder(type_6595);
  ::Reflex::Type type_35600 = ::Reflex::ReferenceBuilder(type_6595c);
  ::Reflex::Type type_63354 = ::Reflex::ReferenceBuilder(type_6621);
  ::Reflex::Type type_6621c = ::Reflex::ConstBuilder(type_6621);
  ::Reflex::Type type_63355 = ::Reflex::ReferenceBuilder(type_6621c);
  ::Reflex::Type type_6831c = ::Reflex::ConstBuilder(type_6831);
  ::Reflex::Type type_63356 = ::Reflex::ReferenceBuilder(type_6831c);
  ::Reflex::Type type_6524c = ::Reflex::ConstBuilder(type_6524);
  ::Reflex::Type type_63357 = ::Reflex::ReferenceBuilder(type_6524c);
  ::Reflex::Type type_6409c = ::Reflex::ConstBuilder(type_6409);
  ::Reflex::Type type_63358 = ::Reflex::ReferenceBuilder(type_6409c);
  ::Reflex::Type type_63359 = ::Reflex::ReferenceBuilder(type_6622);
  ::Reflex::Type type_6622c = ::Reflex::ConstBuilder(type_6622);
  ::Reflex::Type type_63360 = ::Reflex::ReferenceBuilder(type_6622c);
  ::Reflex::Type type_6832c = ::Reflex::ConstBuilder(type_6832);
  ::Reflex::Type type_63361 = ::Reflex::ReferenceBuilder(type_6832c);
  ::Reflex::Type type_6525c = ::Reflex::ConstBuilder(type_6525);
  ::Reflex::Type type_63362 = ::Reflex::ReferenceBuilder(type_6525c);
  ::Reflex::Type type_6410c = ::Reflex::ConstBuilder(type_6410);
  ::Reflex::Type type_63363 = ::Reflex::ReferenceBuilder(type_6410c);
  ::Reflex::Type type_63364 = ::Reflex::ReferenceBuilder(type_6623);
  ::Reflex::Type type_6623c = ::Reflex::ConstBuilder(type_6623);
  ::Reflex::Type type_63365 = ::Reflex::ReferenceBuilder(type_6623c);
  ::Reflex::Type type_6833c = ::Reflex::ConstBuilder(type_6833);
  ::Reflex::Type type_63366 = ::Reflex::ReferenceBuilder(type_6833c);
  ::Reflex::Type type_6526c = ::Reflex::ConstBuilder(type_6526);
  ::Reflex::Type type_63367 = ::Reflex::ReferenceBuilder(type_6526c);
  ::Reflex::Type type_6411c = ::Reflex::ConstBuilder(type_6411);
  ::Reflex::Type type_63368 = ::Reflex::ReferenceBuilder(type_6411c);
  ::Reflex::Type type_63369 = ::Reflex::ReferenceBuilder(type_6624);
  ::Reflex::Type type_6851c = ::Reflex::ConstBuilder(type_6851);
  ::Reflex::Type type_47412 = ::Reflex::ReferenceBuilder(type_6851c);
  ::Reflex::Type type_6542c = ::Reflex::ConstBuilder(type_6542);
  ::Reflex::Type type_63276 = ::Reflex::ReferenceBuilder(type_6542c);
  ::Reflex::Type type_6427c = ::Reflex::ConstBuilder(type_6427);
  ::Reflex::Type type_63231 = ::Reflex::ReferenceBuilder(type_6427c);
  ::Reflex::Type type_63370 = ::Reflex::ReferenceBuilder(type_6625);
  ::Reflex::Type type_6574c = ::Reflex::ConstBuilder(type_6574);
  ::Reflex::Type type_63278 = ::Reflex::ReferenceBuilder(type_6574c);
  ::Reflex::Type type_6459c = ::Reflex::ConstBuilder(type_6459);
  ::Reflex::Type type_63233 = ::Reflex::ReferenceBuilder(type_6459c);
  ::Reflex::Type type_20492 = ::Reflex::ReferenceBuilder(type_11359);
  ::Reflex::Type type_11359c = ::Reflex::ConstBuilder(type_11359);
  ::Reflex::Type type_20494 = ::Reflex::ReferenceBuilder(type_11359c);
  ::Reflex::Type type_20488 = ::Reflex::PointerBuilder(type_11359);
  ::Reflex::Type type_69936 = ::Reflex::ReferenceBuilder(type_11390);
  ::Reflex::Type type_6744c = ::Reflex::ConstBuilder(type_6744);
  ::Reflex::Type type_6001c = ::Reflex::ConstBuilder(type_6001);
  ::Reflex::Type type_62828 = ::Reflex::ReferenceBuilder(type_6001c);
  ::Reflex::Type type_62829 = ::Reflex::ReferenceBuilder(type_6744c);
  ::Reflex::Type type_5220c = ::Reflex::ConstBuilder(type_5220);
  ::Reflex::Type type_35538 = ::Reflex::ReferenceBuilder(type_5220c);
  ::Reflex::Type type_3553c = ::Reflex::ConstBuilder(type_3553);
  ::Reflex::Type type_62830 = ::Reflex::PointerBuilder(type_3553c);
  ::Reflex::Type type_5916c = ::Reflex::ConstBuilder(type_5916);
  ::Reflex::Type type_62831 = ::Reflex::ReferenceBuilder(type_5916c);
  ::Reflex::Type type_62832 = ::Reflex::ReferenceBuilder(type_6001);
  ::Reflex::Type type_6598 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::helper_vector"), type_6597);
  ::Reflex::Type type_35544 = ::Reflex::ReferenceBuilder(type_6598);
  ::Reflex::Type type_20490 = ::Reflex::PointerBuilder(type_11359c);
  ::Reflex::Type type_3977c = ::Reflex::ConstBuilder(type_3977);
  ::Reflex::Type type_59037 = ::Reflex::ReferenceBuilder(type_3977c);
  ::Reflex::Type type_42817 = ::Reflex::ReferenceBuilder(type_3553c);
  ::Reflex::Type type_60092 = ::Reflex::ReferenceBuilder(type_3553);
  ::Reflex::Type type_63344 = ::Reflex::ReferenceBuilder(type_6619);
  ::Reflex::Type type_6619c = ::Reflex::ConstBuilder(type_6619);
  ::Reflex::Type type_63345 = ::Reflex::ReferenceBuilder(type_6619c);
  ::Reflex::Type type_6829c = ::Reflex::ConstBuilder(type_6829);
  ::Reflex::Type type_63346 = ::Reflex::ReferenceBuilder(type_6829c);
  ::Reflex::Type type_6522c = ::Reflex::ConstBuilder(type_6522);
  ::Reflex::Type type_63347 = ::Reflex::ReferenceBuilder(type_6522c);
  ::Reflex::Type type_6407c = ::Reflex::ConstBuilder(type_6407);
  ::Reflex::Type type_63348 = ::Reflex::ReferenceBuilder(type_6407c);
  ::Reflex::Type type_63472 = ::Reflex::ReferenceBuilder(type_6744);
  ::Reflex::Type type_62993 = ::Reflex::PointerBuilder(type_3553);
  ::Reflex::Type type_6271c = ::Reflex::ConstBuilder(type_6271);
  ::Reflex::Type type_62994 = ::Reflex::PointerBuilder(type_6271c);
  ::Reflex::Type type_72812 = ::Reflex::ReferenceBuilder(type_38151);
  ::Reflex::Type type_38151c = ::Reflex::ConstBuilder(type_38151);
  ::Reflex::Type type_72813 = ::Reflex::ReferenceBuilder(type_38151c);
  ::Reflex::Type type_38769 = ::Reflex::PointerBuilder(type_19143);
  ::Reflex::Type type_2394 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_389);
  ::Reflex::Type type_19143c = ::Reflex::ConstBuilder(type_19143);
  ::Reflex::Type type_71771 = ::Reflex::ReferenceBuilder(type_19143c);
  ::Reflex::Type type_38771 = ::Reflex::ReferenceBuilder(type_19143);
  ::Reflex::Type type_16743 = ::Reflex::ReferenceBuilder(type_2977);
  ::Reflex::Type type_38156c = ::Reflex::ConstBuilder(type_38156);
  ::Reflex::Type type_72818 = ::Reflex::ReferenceBuilder(type_38156c);
  ::Reflex::Type type_72819 = ::Reflex::ReferenceBuilder(type_38156);
  ::Reflex::Type type_72807 = ::Reflex::PointerBuilder(type_38140);
  ::Reflex::Type type_11468c = ::Reflex::ConstBuilder(type_11468);
  ::Reflex::Type type_28634 = ::Reflex::PointerBuilder(type_11468c);
  ::Reflex::Type type_38140c = ::Reflex::ConstBuilder(type_38140);
  ::Reflex::Type type_72809 = ::Reflex::ReferenceBuilder(type_38140c);
  ::Reflex::Type type_6255f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::CATopJetTagInfoCollection>"), type_6255);
  ::Reflex::Type type_38151f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<reco::CATopJetTagInfoRef>"), type_38151);
  ::Reflex::Type type_38156f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::BaseTagInfo, reco::CATopJetTagInfoRef>"), type_38156);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TtSemiEvtSolution
#undef __TtSemiEvtSolution
#endif
class __TtSemiEvtSolution {
  public:
  __TtSemiEvtSolution();
  virtual ~__TtSemiEvtSolution() throw();
  ::edm::RefProd<TtGenEvent> theGenEvt_;
  ::edm::Ptr<pat::Jet> hadb_;
  ::edm::Ptr<pat::Jet> hadp_;
  ::edm::Ptr<pat::Jet> hadq_;
  ::edm::Ptr<pat::Jet> lepb_;
  ::edm::Ptr<pat::Muon> muon_;
  ::edm::Ptr<pat::Electron> electron_;
  ::edm::Ptr<pat::MET> neutrino_;
  ::std::vector<pat::Particle> fitHadb_;
  ::std::vector<pat::Particle> fitHadp_;
  ::std::vector<pat::Particle> fitHadq_;
  ::std::vector<pat::Particle> fitLepb_;
  ::std::vector<pat::Particle> fitLepl_;
  ::std::vector<pat::Particle> fitLepn_;
  ::reco::CompositeCandidate mcHyp_;
  ::reco::CompositeCandidate recoHyp_;
  ::reco::CompositeCandidate fitHyp_;
  ::std::string decay_;
  int jetCorrScheme_;
  double sumAnglejp_;
  double angleHadp_;
  double angleHadq_;
  double angleHadb_;
  double angleLepb_;
  int changeWQ_;
  int jetParam_;
  int leptonParam_;
  int neutrinoParam_;
  double probChi2_;
  int mcBestJetComb_;
  int simpleBestJetComb_;
  int lrBestJetComb_;
  double lrJetCombLRval_;
  double lrJetCombProb_;
  double lrSignalEvtLRval_;
  double lrSignalEvtProb_;
  ::std::vector<std::pair<unsigned int,double> > lrJetCombVarVal_;
  ::std::vector<std::pair<unsigned int,double> > lrSignalEvtVarVal_;
};
#ifdef __TtFullHadronicEvent
#undef __TtFullHadronicEvent
#endif
class __TtFullHadronicEvent : public ::TtEvent {
  public:
  __TtFullHadronicEvent();
  virtual ~__TtFullHadronicEvent() throw();
};
#ifdef __TtSemiLeptonicEvent
#undef __TtSemiLeptonicEvent
#endif
class __TtSemiLeptonicEvent : public ::TtEvent {
  public:
  __TtSemiLeptonicEvent();
  virtual ~__TtSemiLeptonicEvent() throw();
  ::std::map<TtEvent::HypoClassKey,int> numberOfRealNeutrinoSolutions_;
};
#ifdef __StEvtSolution
#undef __StEvtSolution
#endif
class __StEvtSolution {
  public:
  __StEvtSolution();
  virtual ~__StEvtSolution() throw();
  ::edm::RefProd<StGenEvent> theGenEvt_;
  ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > bottom_;
  ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > light_;
  ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > muon_;
  ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > electron_;
  ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > neutrino_;
  ::std::vector<pat::Particle> fitBottom_;
  ::std::vector<pat::Particle> fitLight_;
  ::std::vector<pat::Particle> fitLepton_;
  ::std::vector<pat::Particle> fitNeutrino_;
  ::std::string decay_;
  int jetCorrScheme_;
  double chi2Prob_;
  ::std::vector<double> scanValues_;
  double pTrueCombExist_;
  double pTrueBJetSel_;
  double pTrueBhadrSel_;
  double pTrueJetComb_;
  double signalPur_;
  double signalLRTot_;
  double sumDeltaRjp_;
  double deltaRB_;
  double deltaRL_;
  int changeBL_;
  bool bestSol_;
};
#ifdef __TtHadEvtSolution
#undef __TtHadEvtSolution
#endif
class __TtHadEvtSolution {
  public:
  __TtHadEvtSolution();
  virtual ~__TtHadEvtSolution() throw();
  ::edm::RefProd<TtGenEvent> theGenEvt_;
  ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > hadb_;
  ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > hadp_;
  ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > hadq_;
  ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > hadbbar_;
  ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > hadj_;
  ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > hadk_;
  ::std::vector<pat::Particle> fitHadb_;
  ::std::vector<pat::Particle> fitHadp_;
  ::std::vector<pat::Particle> fitHadq_;
  ::std::vector<pat::Particle> fitHadbbar_;
  ::std::vector<pat::Particle> fitHadj_;
  ::std::vector<pat::Particle> fitHadk_;
  ::std::string decay_;
  int jetCorrScheme_;
  double sumAnglejp_;
  double angleHadp_;
  double angleHadq_;
  double angleHadb_;
  double angleHadbbar_;
  double angleHadj_;
  double angleHadk_;
  int changeW1Q_;
  int changeW2Q_;
  int jetParam_;
  double probChi2_;
  int mcBestJetComb_;
  int simpleBestJetComb_;
  int lrBestJetComb_;
  double lrJetCombLRval_;
  double lrJetCombProb_;
  double lrSignalEvtLRval_;
  double lrSignalEvtProb_;
  ::std::vector<std::pair<unsigned int,double> > lrJetCombVarVal_;
  ::std::vector<std::pair<unsigned int,double> > lrSignalEvtVarVal_;
};
#ifdef __TtGenEvent
#undef __TtGenEvent
#endif
class __TtGenEvent : public ::TopGenEvent {
  public:
  __TtGenEvent();
  virtual ~__TtGenEvent() throw();
  ::math::XYZTLorentzVector topPair_;
};
#ifdef __TtDilepEvtSolution
#undef __TtDilepEvtSolution
#endif
class __TtDilepEvtSolution {
  public:
  __TtDilepEvtSolution();
  virtual ~__TtDilepEvtSolution() throw();
  ::edm::RefProd<TtGenEvent> theGenEvt_;
  ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > elecp_;
  ::edm::Ref<std::vector<pat::Electron>,pat::Electron,edm::refhelper::FindUsingAdvance<std::vector<pat::Electron>,pat::Electron> > elecm_;
  ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > muonp_;
  ::edm::Ref<std::vector<pat::Muon>,pat::Muon,edm::refhelper::FindUsingAdvance<std::vector<pat::Muon>,pat::Muon> > muonm_;
  ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > taup_;
  ::edm::Ref<std::vector<pat::Tau>,pat::Tau,edm::refhelper::FindUsingAdvance<std::vector<pat::Tau>,pat::Tau> > taum_;
  ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > jetB_;
  ::edm::Ref<std::vector<pat::Jet>,pat::Jet,edm::refhelper::FindUsingAdvance<std::vector<pat::Jet>,pat::Jet> > jetBbar_;
  ::edm::Ref<std::vector<pat::MET>,pat::MET,edm::refhelper::FindUsingAdvance<std::vector<pat::MET>,pat::MET> > met_;
  int jetCorrScheme_;
  ::std::string wpDecay_;
  ::std::string wmDecay_;
  bool bestSol_;
  double topmass_;
  double weightmax_;
  double lrSignalEvtLRval_;
  double lrSignalEvtProb_;
  ::std::vector<std::pair<unsigned int,double> > lrSignalEvtVarVal_;
};
#ifdef __TopGenEvent
#undef __TopGenEvent
#endif
class __TopGenEvent {
  public:
  __TopGenEvent();
  virtual ~__TopGenEvent() throw();
  ::reco::GenParticleRefProd parts_;
  ::reco::GenParticleRefProd initPartons_;
};
#ifdef __StGenEvent
#undef __StGenEvent
#endif
class __StGenEvent : public ::TopGenEvent {
  public:
  __StGenEvent();
  virtual ~__StGenEvent() throw();
};
#ifdef __TtEvent
#undef __TtEvent
#endif
class __TtEvent {
  public:
  __TtEvent();
  virtual ~__TtEvent() throw();
#ifdef __TtEvent__HypoClassKeyStringToEnum
#undef __TtEvent__HypoClassKeyStringToEnum
#endif
  struct __TtEvent__HypoClassKeyStringToEnum {
    public:
    __TtEvent__HypoClassKeyStringToEnum();
    void* label;
    ::TtEvent::HypoClassKey value;
  };
  ::std::pair<WDecay::LeptonType,WDecay::LeptonType> lepDecays_;
  ::edm::RefProd<TtGenEvent> genEvt_;
  ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > evtHyp_;
  ::std::map<TtEvent::HypoClassKey,int> nJetsConsidered_;
  ::std::vector<double> fitChi2_;
  ::std::vector<double> hitFitChi2_;
  ::std::vector<double> fitProb_;
  ::std::vector<double> hitFitProb_;
  ::std::vector<double> hitFitMT_;
  ::std::vector<double> hitFitSigMT_;
  ::std::vector<double> genMatchSumPt_;
  ::std::vector<double> genMatchSumDR_;
  ::std::string mvaMethod_;
  ::std::vector<double> mvaDisc_;
};
#ifdef __TtFullLeptonicEvent
#undef __TtFullLeptonicEvent
#endif
class __TtFullLeptonicEvent : public ::TtEvent {
  public:
  __TtFullLeptonicEvent();
  virtual ~__TtFullLeptonicEvent() throw();
  ::std::vector<double> solWeight_;
  bool wrongCharge_;
};
#ifdef __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties_
#undef __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties_
#endif
struct __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties_ {
  public:
  __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties_();
  ::edm::RefToBase<reco::Jet> first;
  ::reco::CATopJetProperties second;
};
#ifdef __std__pair_reco__CompositeCandidate_std__vector_int_s_
#undef __std__pair_reco__CompositeCandidate_std__vector_int_s_
#endif
struct __std__pair_reco__CompositeCandidate_std__vector_int_s_ {
  public:
  __std__pair_reco__CompositeCandidate_std__vector_int_s_();
  ::reco::CompositeCandidate first;
  ::std::vector<int> second;
};
#ifdef __std__pair_WDecay__LeptonType_WDecay__LeptonType_
#undef __std__pair_WDecay__LeptonType_WDecay__LeptonType_
#endif
struct __std__pair_WDecay__LeptonType_WDecay__LeptonType_ {
  public:
  __std__pair_WDecay__LeptonType_WDecay__LeptonType_();
  ::WDecay::LeptonType first;
  ::WDecay::LeptonType second;
};
#ifdef __std__vector_StEvtSolution_
#undef __std__vector_StEvtSolution_
#endif
class __std__vector_StEvtSolution_ : protected ::std::_Vector_base<StEvtSolution,std::allocator<StEvtSolution> > {
  public:
  __std__vector_StEvtSolution_();
};
#ifdef __std__vector_TtHadEvtSolution_
#undef __std__vector_TtHadEvtSolution_
#endif
class __std__vector_TtHadEvtSolution_ : protected ::std::_Vector_base<TtHadEvtSolution,std::allocator<TtHadEvtSolution> > {
  public:
  __std__vector_TtHadEvtSolution_();
};
#ifdef __std__vector_TtSemiEvtSolution_
#undef __std__vector_TtSemiEvtSolution_
#endif
class __std__vector_TtSemiEvtSolution_ : protected ::std::_Vector_base<TtSemiEvtSolution,std::allocator<TtSemiEvtSolution> > {
  public:
  __std__vector_TtSemiEvtSolution_();
};
#ifdef __std__vector_TtDilepEvtSolution_
#undef __std__vector_TtDilepEvtSolution_
#endif
class __std__vector_TtDilepEvtSolution_ : protected ::std::_Vector_base<TtDilepEvtSolution,std::allocator<TtDilepEvtSolution> > {
  public:
  __std__vector_TtDilepEvtSolution_();
};
#ifdef __std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_
#undef __std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_
#endif
class __std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_ : protected ::std::_Vector_base<std::pair<reco::CompositeCandidate,std::vector<int> >,std::allocator<std::pair<reco::CompositeCandidate,std::vector<int> > > > {
  public:
  __std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_();
};
#ifdef __std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s_
#undef __std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s_
#endif
class __std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s_ {
  public:
  __std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s_();
  ::std::_Rb_tree<TtEvent::HypoClassKey,std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >,std::_Select1st<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >,std::less<TtEvent::HypoClassKey>,std::allocator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > > > _M_t;
};
#ifdef __std__map_TtEvent__HypoClassKey_int_
#undef __std__map_TtEvent__HypoClassKey_int_
#endif
class __std__map_TtEvent__HypoClassKey_int_ {
  public:
  __std__map_TtEvent__HypoClassKey_int_();
  ::std::_Rb_tree<TtEvent::HypoClassKey,std::pair<const TtEvent::HypoClassKey,int>,std::_Select1st<std::pair<const TtEvent::HypoClassKey,int> >,std::less<TtEvent::HypoClassKey>,std::allocator<std::pair<const TtEvent::HypoClassKey,int> > > _M_t;
};
#ifdef __edm__Wrapper_std__vector_StEvtSolution_s_
#undef __edm__Wrapper_std__vector_StEvtSolution_s_
#endif
class __edm__Wrapper_std__vector_StEvtSolution_s_ {
  public:
  __edm__Wrapper_std__vector_StEvtSolution_s_();
  bool present;
  ::std::vector<StEvtSolution> obj;
};
#ifdef __edm__Wrapper_std__vector_TtHadEvtSolution_s_
#undef __edm__Wrapper_std__vector_TtHadEvtSolution_s_
#endif
class __edm__Wrapper_std__vector_TtHadEvtSolution_s_ {
  public:
  __edm__Wrapper_std__vector_TtHadEvtSolution_s_();
  bool present;
  ::std::vector<TtHadEvtSolution> obj;
};
#ifdef __edm__Wrapper_std__vector_TtSemiEvtSolution_s_
#undef __edm__Wrapper_std__vector_TtSemiEvtSolution_s_
#endif
class __edm__Wrapper_std__vector_TtSemiEvtSolution_s_ {
  public:
  __edm__Wrapper_std__vector_TtSemiEvtSolution_s_();
  bool present;
  ::std::vector<TtSemiEvtSolution> obj;
};
#ifdef __edm__Wrapper_std__vector_TtDilepEvtSolution_s_
#undef __edm__Wrapper_std__vector_TtDilepEvtSolution_s_
#endif
class __edm__Wrapper_std__vector_TtDilepEvtSolution_s_ {
  public:
  __edm__Wrapper_std__vector_TtDilepEvtSolution_s_();
  bool present;
  ::std::vector<TtDilepEvtSolution> obj;
};
#ifdef __edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s_
#undef __edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s_
#endif
class __edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s_ {
  public:
  __edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s_();
  bool present;
  ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > obj;
};
#ifdef __edm__Wrapper_reco__CompositeCandidate_
#undef __edm__Wrapper_reco__CompositeCandidate_
#endif
class __edm__Wrapper_reco__CompositeCandidate_ {
  public:
  __edm__Wrapper_reco__CompositeCandidate_();
  bool present;
  ::reco::CompositeCandidate obj;
};
#ifdef __edm__Wrapper_TtFullHadronicEvent_
#undef __edm__Wrapper_TtFullHadronicEvent_
#endif
class __edm__Wrapper_TtFullHadronicEvent_ {
  public:
  __edm__Wrapper_TtFullHadronicEvent_();
  bool present;
  ::TtFullHadronicEvent obj;
};
#ifdef __edm__Wrapper_TtSemiLeptonicEvent_
#undef __edm__Wrapper_TtSemiLeptonicEvent_
#endif
class __edm__Wrapper_TtSemiLeptonicEvent_ {
  public:
  __edm__Wrapper_TtSemiLeptonicEvent_();
  bool present;
  ::TtSemiLeptonicEvent obj;
};
#ifdef __edm__Wrapper_TtFullLeptonicEvent_
#undef __edm__Wrapper_TtFullLeptonicEvent_
#endif
class __edm__Wrapper_TtFullLeptonicEvent_ {
  public:
  __edm__Wrapper_TtFullLeptonicEvent_();
  bool present;
  ::TtFullLeptonicEvent obj;
};
#ifdef __edm__Wrapper_TopGenEvent_
#undef __edm__Wrapper_TopGenEvent_
#endif
class __edm__Wrapper_TopGenEvent_ {
  public:
  __edm__Wrapper_TopGenEvent_();
  bool present;
  ::TopGenEvent obj;
};
#ifdef __edm__Wrapper_StGenEvent_
#undef __edm__Wrapper_StGenEvent_
#endif
class __edm__Wrapper_StGenEvent_ {
  public:
  __edm__Wrapper_StGenEvent_();
  bool present;
  ::StGenEvent obj;
};
#ifdef __edm__Wrapper_TtGenEvent_
#undef __edm__Wrapper_TtGenEvent_
#endif
class __edm__Wrapper_TtGenEvent_ {
  public:
  __edm__Wrapper_TtGenEvent_();
  bool present;
  ::TtGenEvent obj;
};
#ifdef __edm__RefProd_TtFullHadronicEvent_
#undef __edm__RefProd_TtFullHadronicEvent_
#endif
class __edm__RefProd_TtFullHadronicEvent_ {
  public:
  __edm__RefProd_TtFullHadronicEvent_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_TtSemiLeptonicEvent_
#undef __edm__RefProd_TtSemiLeptonicEvent_
#endif
class __edm__RefProd_TtSemiLeptonicEvent_ {
  public:
  __edm__RefProd_TtSemiLeptonicEvent_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_TtFullLeptonicEvent_
#undef __edm__RefProd_TtFullLeptonicEvent_
#endif
class __edm__RefProd_TtFullLeptonicEvent_ {
  public:
  __edm__RefProd_TtFullLeptonicEvent_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_TopGenEvent_
#undef __edm__RefProd_TopGenEvent_
#endif
class __edm__RefProd_TopGenEvent_ {
  public:
  __edm__RefProd_TopGenEvent_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_StGenEvent_
#undef __edm__RefProd_StGenEvent_
#endif
class __edm__RefProd_StGenEvent_ {
  public:
  __edm__RefProd_StGenEvent_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_TtGenEvent_
#undef __edm__RefProd_TtGenEvent_
#endif
class __edm__RefProd_TtGenEvent_ {
  public:
  __edm__RefProd_TtGenEvent_();
  ::edm::RefCore product_;
};
#ifdef __reco__CATopJetTagInfo
#undef __reco__CATopJetTagInfo
#endif
class __reco__CATopJetTagInfo : public ::reco::JetTagInfo {
  public:
  __reco__CATopJetTagInfo();
  virtual ~__reco__CATopJetTagInfo() throw();
  virtual ::reco::CATopJetTagInfo* clone() const throw();
  ::reco::CATopJetProperties properties_;
};
#ifdef __reco__CATopJetProperties
#undef __reco__CATopJetProperties
#endif
class __reco__CATopJetProperties {
  public:
  __reco__CATopJetProperties();
  int nSubJets;
  double minMass;
  double topMass;
  double wMass;
};
#ifdef __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_
#undef __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_
#endif
class __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_ {
  public:
  __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __std__vector_reco__CATopJetTagInfo_
#undef __std__vector_reco__CATopJetTagInfo_
#endif
class __std__vector_reco__CATopJetTagInfo_ : protected ::std::_Vector_base<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > {
  public:
  __std__vector_reco__CATopJetTagInfo_();
};
#ifdef __edm__RefProd_std__vector_reco__CATopJetTagInfo_s_
#undef __edm__RefProd_std__vector_reco__CATopJetTagInfo_s_
#endif
class __edm__RefProd_std__vector_reco__CATopJetTagInfo_s_ {
  public:
  __edm__RefProd_std__vector_reco__CATopJetTagInfo_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_
#undef __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_
#endif
class __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_ {
  public:
  __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s_
#undef __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s_
#endif
class __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s_ {
  public:
  __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s_();
  bool present;
  ::std::vector<reco::CATopJetTagInfo> obj;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_() throw();
  ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_
#undef __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_
#endif
class __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_ : public ::edm::reftobase::BaseHolder<reco::BaseTagInfo> {
  public:
  __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_();
  virtual ~__edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_() throw();
  ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > ref_;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class TtSemiEvtSolution -------------------------------
static  void operator_8673( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TtSemiEvtSolution*)o)->operator=)(*(const ::TtSemiEvtSolution*)arg[0]);
  else   (((::TtSemiEvtSolution*)o)->operator=)(*(const ::TtSemiEvtSolution*)arg[0]);
}

static void constructor_8674( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtSemiEvtSolution(*(const ::TtSemiEvtSolution*)arg[0]);
  else ::new(mem) ::TtSemiEvtSolution(*(const ::TtSemiEvtSolution*)arg[0]);
}

static void constructor_8675( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtSemiEvtSolution();
  else ::new(mem) ::TtSemiEvtSolution();
}

static void destructor_8676(void*, void * o, const std::vector<void*>&, void *) {
(((::TtSemiEvtSolution*)o)->::TtSemiEvtSolution::~TtSemiEvtSolution)();
}
static  void method_8677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtSemiEvtSolution*)o)->getHadb)());
  else   (((const ::TtSemiEvtSolution*)o)->getHadb)();
}

static  void method_8678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtSemiEvtSolution*)o)->getHadp)());
  else   (((const ::TtSemiEvtSolution*)o)->getHadp)();
}

static  void method_8679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtSemiEvtSolution*)o)->getHadq)());
  else   (((const ::TtSemiEvtSolution*)o)->getHadq)();
}

static  void method_8680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtSemiEvtSolution*)o)->getLepb)());
  else   (((const ::TtSemiEvtSolution*)o)->getLepb)();
}

static  void method_8681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Muon)((((const ::TtSemiEvtSolution*)o)->getMuon)());
  else   (((const ::TtSemiEvtSolution*)o)->getMuon)();
}

static  void method_8682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Electron)((((const ::TtSemiEvtSolution*)o)->getElectron)());
  else   (((const ::TtSemiEvtSolution*)o)->getElectron)();
}

static  void method_8683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::MET)((((const ::TtSemiEvtSolution*)o)->getNeutrino)());
  else   (((const ::TtSemiEvtSolution*)o)->getNeutrino)();
}

static  void method_8684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::TtSemiEvtSolution*)o)->getGenEvent)();
  else   (((const ::TtSemiEvtSolution*)o)->getGenEvent)();
}

static  void method_8685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiEvtSolution*)o)->getGenHadt)());
  else   (((const ::TtSemiEvtSolution*)o)->getGenHadt)();
}

static  void method_8686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiEvtSolution*)o)->getGenHadW)());
  else   (((const ::TtSemiEvtSolution*)o)->getGenHadW)();
}

static  void method_8687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiEvtSolution*)o)->getGenHadb)());
  else   (((const ::TtSemiEvtSolution*)o)->getGenHadb)();
}

static  void method_8688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiEvtSolution*)o)->getGenHadp)());
  else   (((const ::TtSemiEvtSolution*)o)->getGenHadp)();
}

static  void method_8689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiEvtSolution*)o)->getGenHadq)());
  else   (((const ::TtSemiEvtSolution*)o)->getGenHadq)();
}

static  void method_8690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiEvtSolution*)o)->getGenLept)());
  else   (((const ::TtSemiEvtSolution*)o)->getGenLept)();
}

static  void method_8691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiEvtSolution*)o)->getGenLepW)());
  else   (((const ::TtSemiEvtSolution*)o)->getGenLepW)();
}

static  void method_8692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiEvtSolution*)o)->getGenLepb)());
  else   (((const ::TtSemiEvtSolution*)o)->getGenLepb)();
}

static  void method_8693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiEvtSolution*)o)->getGenLepl)());
  else   (((const ::TtSemiEvtSolution*)o)->getGenLepl)();
}

static  void method_8694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiEvtSolution*)o)->getGenLepn)());
  else   (((const ::TtSemiEvtSolution*)o)->getGenLepn)();
}

static  void method_8695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtSemiEvtSolution*)o)->getRecHadt)());
  else   (((const ::TtSemiEvtSolution*)o)->getRecHadt)();
}

static  void method_8696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtSemiEvtSolution*)o)->getRecHadW)());
  else   (((const ::TtSemiEvtSolution*)o)->getRecHadW)();
}

static  void method_8697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtSemiEvtSolution*)o)->getRecHadb)());
  else   (((const ::TtSemiEvtSolution*)o)->getRecHadb)();
}

static  void method_8698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtSemiEvtSolution*)o)->getRecHadp)());
  else   (((const ::TtSemiEvtSolution*)o)->getRecHadp)();
}

static  void method_8699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtSemiEvtSolution*)o)->getRecHadq)());
  else   (((const ::TtSemiEvtSolution*)o)->getRecHadq)();
}

static  void method_8700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtSemiEvtSolution*)o)->getRecLept)());
  else   (((const ::TtSemiEvtSolution*)o)->getRecLept)();
}

static  void method_8701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtSemiEvtSolution*)o)->getRecLepW)());
  else   (((const ::TtSemiEvtSolution*)o)->getRecLepW)();
}

static  void method_8702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtSemiEvtSolution*)o)->getRecLepb)());
  else   (((const ::TtSemiEvtSolution*)o)->getRecLepb)();
}

static  void method_8703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Muon)((((const ::TtSemiEvtSolution*)o)->getRecLepm)());
  else   (((const ::TtSemiEvtSolution*)o)->getRecLepm)();
}

static  void method_8704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Electron)((((const ::TtSemiEvtSolution*)o)->getRecLepe)());
  else   (((const ::TtSemiEvtSolution*)o)->getRecLepe)();
}

static  void method_8705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::MET)((((const ::TtSemiEvtSolution*)o)->getRecLepn)());
  else   (((const ::TtSemiEvtSolution*)o)->getRecLepn)();
}

static  void method_8706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtSemiEvtSolution*)o)->getCalHadt)());
  else   (((const ::TtSemiEvtSolution*)o)->getCalHadt)();
}

static  void method_8707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtSemiEvtSolution*)o)->getCalHadW)());
  else   (((const ::TtSemiEvtSolution*)o)->getCalHadW)();
}

static  void method_8708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtSemiEvtSolution*)o)->getCalHadb)());
  else   (((const ::TtSemiEvtSolution*)o)->getCalHadb)();
}

static  void method_8709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtSemiEvtSolution*)o)->getCalHadp)());
  else   (((const ::TtSemiEvtSolution*)o)->getCalHadp)();
}

static  void method_8710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtSemiEvtSolution*)o)->getCalHadq)());
  else   (((const ::TtSemiEvtSolution*)o)->getCalHadq)();
}

static  void method_8711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtSemiEvtSolution*)o)->getCalLept)());
  else   (((const ::TtSemiEvtSolution*)o)->getCalLept)();
}

static  void method_8712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtSemiEvtSolution*)o)->getCalLepW)());
  else   (((const ::TtSemiEvtSolution*)o)->getCalLepW)();
}

static  void method_8713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtSemiEvtSolution*)o)->getCalLepb)());
  else   (((const ::TtSemiEvtSolution*)o)->getCalLepb)();
}

static  void method_8714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Muon)((((const ::TtSemiEvtSolution*)o)->getCalLepm)());
  else   (((const ::TtSemiEvtSolution*)o)->getCalLepm)();
}

static  void method_8715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Electron)((((const ::TtSemiEvtSolution*)o)->getCalLepe)());
  else   (((const ::TtSemiEvtSolution*)o)->getCalLepe)();
}

static  void method_8716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::MET)((((const ::TtSemiEvtSolution*)o)->getCalLepn)());
  else   (((const ::TtSemiEvtSolution*)o)->getCalLepn)();
}

static  void method_8717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtSemiEvtSolution*)o)->getFitHadt)());
  else   (((const ::TtSemiEvtSolution*)o)->getFitHadt)();
}

static  void method_8718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtSemiEvtSolution*)o)->getFitHadW)());
  else   (((const ::TtSemiEvtSolution*)o)->getFitHadW)();
}

static  void method_8719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::TtSemiEvtSolution*)o)->getFitHadb)());
  else   (((const ::TtSemiEvtSolution*)o)->getFitHadb)();
}

static  void method_8720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::TtSemiEvtSolution*)o)->getFitHadp)());
  else   (((const ::TtSemiEvtSolution*)o)->getFitHadp)();
}

static  void method_8721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::TtSemiEvtSolution*)o)->getFitHadq)());
  else   (((const ::TtSemiEvtSolution*)o)->getFitHadq)();
}

static  void method_8722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtSemiEvtSolution*)o)->getFitLept)());
  else   (((const ::TtSemiEvtSolution*)o)->getFitLept)();
}

static  void method_8723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtSemiEvtSolution*)o)->getFitLepW)());
  else   (((const ::TtSemiEvtSolution*)o)->getFitLepW)();
}

static  void method_8724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::TtSemiEvtSolution*)o)->getFitLepb)());
  else   (((const ::TtSemiEvtSolution*)o)->getFitLepb)();
}

static  void method_8725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::TtSemiEvtSolution*)o)->getFitLepl)());
  else   (((const ::TtSemiEvtSolution*)o)->getFitLepl)();
}

static  void method_8726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::TtSemiEvtSolution*)o)->getFitLepn)());
  else   (((const ::TtSemiEvtSolution*)o)->getFitLepn)();
}

static  void method_8727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TtSemiEvtSolution*)o)->getDecay)());
  else   (((const ::TtSemiEvtSolution*)o)->getDecay)();
}

static  void method_8728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtSemiEvtSolution*)o)->getMCBestSumAngles)());
  else   (((const ::TtSemiEvtSolution*)o)->getMCBestSumAngles)();
}

static  void method_8729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtSemiEvtSolution*)o)->getMCBestAngleHadp)());
  else   (((const ::TtSemiEvtSolution*)o)->getMCBestAngleHadp)();
}

static  void method_8730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtSemiEvtSolution*)o)->getMCBestAngleHadq)());
  else   (((const ::TtSemiEvtSolution*)o)->getMCBestAngleHadq)();
}

static  void method_8731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtSemiEvtSolution*)o)->getMCBestAngleHadb)());
  else   (((const ::TtSemiEvtSolution*)o)->getMCBestAngleHadb)();
}

static  void method_8732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtSemiEvtSolution*)o)->getMCBestAngleLepb)());
  else   (((const ::TtSemiEvtSolution*)o)->getMCBestAngleLepb)();
}

static  void method_8733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtSemiEvtSolution*)o)->getMCChangeWQ)());
  else   (((const ::TtSemiEvtSolution*)o)->getMCChangeWQ)();
}

static  void method_8734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtSemiEvtSolution*)o)->getJetParametrisation)());
  else   (((const ::TtSemiEvtSolution*)o)->getJetParametrisation)();
}

static  void method_8735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtSemiEvtSolution*)o)->getLeptonParametrisation)());
  else   (((const ::TtSemiEvtSolution*)o)->getLeptonParametrisation)();
}

static  void method_8736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtSemiEvtSolution*)o)->getNeutrinoParametrisation)());
  else   (((const ::TtSemiEvtSolution*)o)->getNeutrinoParametrisation)();
}

static  void method_8737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtSemiEvtSolution*)o)->getProbChi2)());
  else   (((const ::TtSemiEvtSolution*)o)->getProbChi2)();
}

static  void method_8738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtSemiEvtSolution*)o)->getLRSignalEvtObsVal)(*(unsigned int*)arg[0]));
  else   (((const ::TtSemiEvtSolution*)o)->getLRSignalEvtObsVal)(*(unsigned int*)arg[0]);
}

static  void method_8739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtSemiEvtSolution*)o)->getLRSignalEvtLRval)());
  else   (((const ::TtSemiEvtSolution*)o)->getLRSignalEvtLRval)();
}

static  void method_8740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtSemiEvtSolution*)o)->getLRSignalEvtProb)());
  else   (((const ::TtSemiEvtSolution*)o)->getLRSignalEvtProb)();
}

static  void method_8741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtSemiEvtSolution*)o)->getMCBestJetComb)());
  else   (((const ::TtSemiEvtSolution*)o)->getMCBestJetComb)();
}

static  void method_8742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtSemiEvtSolution*)o)->getSimpleBestJetComb)());
  else   (((const ::TtSemiEvtSolution*)o)->getSimpleBestJetComb)();
}

static  void method_8743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtSemiEvtSolution*)o)->getLRBestJetComb)());
  else   (((const ::TtSemiEvtSolution*)o)->getLRBestJetComb)();
}

static  void method_8744( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtSemiEvtSolution*)o)->getLRJetCombObsVal)(*(unsigned int*)arg[0]));
  else   (((const ::TtSemiEvtSolution*)o)->getLRJetCombObsVal)(*(unsigned int*)arg[0]);
}

static  void method_8745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtSemiEvtSolution*)o)->getLRJetCombLRval)());
  else   (((const ::TtSemiEvtSolution*)o)->getLRJetCombLRval)();
}

static  void method_8746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtSemiEvtSolution*)o)->getLRJetCombProb)());
  else   (((const ::TtSemiEvtSolution*)o)->getLRJetCombProb)();
}

static  void method_8747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::TtSemiEvtSolution*)o)->getRecoHyp)();
  else   (((const ::TtSemiEvtSolution*)o)->getRecoHyp)();
}

static  void method_8748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::TtSemiEvtSolution*)o)->getFitHyp)();
  else   (((const ::TtSemiEvtSolution*)o)->getFitHyp)();
}

static  void method_8749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::TtSemiEvtSolution*)o)->getMCHyp)();
  else   (((const ::TtSemiEvtSolution*)o)->getMCHyp)();
}

static void method_newdel_977( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TtSemiEvtSolution >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TtSemiEvtSolution >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TtSemiEvtSolution >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TtSemiEvtSolution >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TtSemiEvtSolution >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TtSemiEvtSolution -------------------------------
void __TtSemiEvtSolution_db_datamem(Reflex::Class*);
void __TtSemiEvtSolution_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TtSemiEvtSolution_datamem_bld(&__TtSemiEvtSolution_db_datamem);
Reflex::GenreflexMemberBuilder __TtSemiEvtSolution_funcmem_bld(&__TtSemiEvtSolution_db_funcmem);
void __TtSemiEvtSolution_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TtSemiEvtSolution"), typeid(::TtSemiEvtSolution), sizeof(::TtSemiEvtSolution), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20687, type_20689), Reflex::Literal("operator="), operator_8673, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20689), Reflex::Literal("TtSemiEvtSolution"), constructor_8674, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TtSemiEvtSolution"), constructor_8675, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TtSemiEvtSolution"), destructor_8676, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_977, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TtSemiEvtSolution_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TtSemiEvtSolution_funcmem_bld);
}

//------Delayed data member builder for class TtSemiEvtSolution -------------------
void __TtSemiEvtSolution_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6625, Reflex::Literal("theGenEvt_"), OffsetOf(__shadow__::__TtSemiEvtSolution, theGenEvt_), ::Reflex::PRIVATE)
  .AddDataMember(type_6709, Reflex::Literal("hadb_"), OffsetOf(__shadow__::__TtSemiEvtSolution, hadb_), ::Reflex::PRIVATE)
  .AddDataMember(type_6709, Reflex::Literal("hadp_"), OffsetOf(__shadow__::__TtSemiEvtSolution, hadp_), ::Reflex::PRIVATE)
  .AddDataMember(type_6709, Reflex::Literal("hadq_"), OffsetOf(__shadow__::__TtSemiEvtSolution, hadq_), ::Reflex::PRIVATE)
  .AddDataMember(type_6709, Reflex::Literal("lepb_"), OffsetOf(__shadow__::__TtSemiEvtSolution, lepb_), ::Reflex::PRIVATE)
  .AddDataMember(type_6708, Reflex::Literal("muon_"), OffsetOf(__shadow__::__TtSemiEvtSolution, muon_), ::Reflex::PRIVATE)
  .AddDataMember(type_6707, Reflex::Literal("electron_"), OffsetOf(__shadow__::__TtSemiEvtSolution, electron_), ::Reflex::PRIVATE)
  .AddDataMember(type_6706, Reflex::Literal("neutrino_"), OffsetOf(__shadow__::__TtSemiEvtSolution, neutrino_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitHadb_"), OffsetOf(__shadow__::__TtSemiEvtSolution, fitHadb_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitHadp_"), OffsetOf(__shadow__::__TtSemiEvtSolution, fitHadp_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitHadq_"), OffsetOf(__shadow__::__TtSemiEvtSolution, fitHadq_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitLepb_"), OffsetOf(__shadow__::__TtSemiEvtSolution, fitLepb_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitLepl_"), OffsetOf(__shadow__::__TtSemiEvtSolution, fitLepl_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitLepn_"), OffsetOf(__shadow__::__TtSemiEvtSolution, fitLepn_), ::Reflex::PRIVATE)
  .AddDataMember(type_11644, Reflex::Literal("mcHyp_"), OffsetOf(__shadow__::__TtSemiEvtSolution, mcHyp_), ::Reflex::PRIVATE)
  .AddDataMember(type_11644, Reflex::Literal("recoHyp_"), OffsetOf(__shadow__::__TtSemiEvtSolution, recoHyp_), ::Reflex::PRIVATE)
  .AddDataMember(type_11644, Reflex::Literal("fitHyp_"), OffsetOf(__shadow__::__TtSemiEvtSolution, fitHyp_), ::Reflex::PRIVATE)
  .AddDataMember(type_2978, Reflex::Literal("decay_"), OffsetOf(__shadow__::__TtSemiEvtSolution, decay_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("jetCorrScheme_"), OffsetOf(__shadow__::__TtSemiEvtSolution, jetCorrScheme_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("sumAnglejp_"), OffsetOf(__shadow__::__TtSemiEvtSolution, sumAnglejp_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("angleHadp_"), OffsetOf(__shadow__::__TtSemiEvtSolution, angleHadp_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("angleHadq_"), OffsetOf(__shadow__::__TtSemiEvtSolution, angleHadq_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("angleHadb_"), OffsetOf(__shadow__::__TtSemiEvtSolution, angleHadb_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("angleLepb_"), OffsetOf(__shadow__::__TtSemiEvtSolution, angleLepb_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("changeWQ_"), OffsetOf(__shadow__::__TtSemiEvtSolution, changeWQ_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("jetParam_"), OffsetOf(__shadow__::__TtSemiEvtSolution, jetParam_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("leptonParam_"), OffsetOf(__shadow__::__TtSemiEvtSolution, leptonParam_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("neutrinoParam_"), OffsetOf(__shadow__::__TtSemiEvtSolution, neutrinoParam_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("probChi2_"), OffsetOf(__shadow__::__TtSemiEvtSolution, probChi2_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("mcBestJetComb_"), OffsetOf(__shadow__::__TtSemiEvtSolution, mcBestJetComb_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("simpleBestJetComb_"), OffsetOf(__shadow__::__TtSemiEvtSolution, simpleBestJetComb_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("lrBestJetComb_"), OffsetOf(__shadow__::__TtSemiEvtSolution, lrBestJetComb_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("lrJetCombLRval_"), OffsetOf(__shadow__::__TtSemiEvtSolution, lrJetCombLRval_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("lrJetCombProb_"), OffsetOf(__shadow__::__TtSemiEvtSolution, lrJetCombProb_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("lrSignalEvtLRval_"), OffsetOf(__shadow__::__TtSemiEvtSolution, lrSignalEvtLRval_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("lrSignalEvtProb_"), OffsetOf(__shadow__::__TtSemiEvtSolution, lrSignalEvtProb_), ::Reflex::PRIVATE)
  .AddDataMember(type_3560, Reflex::Literal("lrJetCombVarVal_"), OffsetOf(__shadow__::__TtSemiEvtSolution, lrJetCombVarVal_), ::Reflex::PRIVATE)
  .AddDataMember(type_3560, Reflex::Literal("lrSignalEvtVarVal_"), OffsetOf(__shadow__::__TtSemiEvtSolution, lrSignalEvtVarVal_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TtSemiEvtSolution -------------------
void __TtSemiEvtSolution_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getHadb"), method_8677, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getHadp"), method_8678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getHadq"), method_8679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getLepb"), method_8680, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12913), Reflex::Literal("getMuon"), method_8681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12981), Reflex::Literal("getElectron"), method_8682, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12916), Reflex::Literal("getNeutrino"), method_8683, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46181), Reflex::Literal("getGenEvent"), method_8684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenHadt"), method_8685, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenHadW"), method_8686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenHadb"), method_8687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenHadp"), method_8688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenHadq"), method_8689, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenLept"), method_8690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenLepW"), method_8691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenLepb"), method_8692, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenLepl"), method_8693, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenLepn"), method_8694, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getRecHadt"), method_8695, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getRecHadW"), method_8696, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecHadb"), method_8697, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecHadp"), method_8698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecHadq"), method_8699, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getRecLept"), method_8700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getRecLepW"), method_8701, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecLepb"), method_8702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12913), Reflex::Literal("getRecLepm"), method_8703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12981), Reflex::Literal("getRecLepe"), method_8704, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12916), Reflex::Literal("getRecLepn"), method_8705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getCalHadt"), method_8706, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getCalHadW"), method_8707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getCalHadb"), method_8708, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getCalHadp"), method_8709, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getCalHadq"), method_8710, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getCalLept"), method_8711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getCalLepW"), method_8712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getCalLepb"), method_8713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12913), Reflex::Literal("getCalLepm"), method_8714, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12981), Reflex::Literal("getCalLepe"), method_8715, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12916), Reflex::Literal("getCalLepn"), method_8716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getFitHadt"), method_8717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getFitHadW"), method_8718, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitHadb"), method_8719, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitHadp"), method_8720, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitHadq"), method_8721, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getFitLept"), method_8722, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getFitLepW"), method_8723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitLepb"), method_8724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitLepl"), method_8725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitLepn"), method_8726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2978), Reflex::Literal("getDecay"), method_8727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getMCBestSumAngles"), method_8728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getMCBestAngleHadp"), method_8729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getMCBestAngleHadq"), method_8730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getMCBestAngleHadb"), method_8731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getMCBestAngleLepb"), method_8732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getMCChangeWQ"), method_8733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getJetParametrisation"), method_8734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getLeptonParametrisation"), method_8735, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getNeutrinoParametrisation"), method_8736, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getProbChi2"), method_8737, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_398), Reflex::Literal("getLRSignalEvtObsVal"), method_8738, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getLRSignalEvtLRval"), method_8739, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getLRSignalEvtProb"), method_8740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getMCBestJetComb"), method_8741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getSimpleBestJetComb"), method_8742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getLRBestJetComb"), method_8743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_398), Reflex::Literal("getLRJetCombObsVal"), method_8744, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getLRJetCombLRval"), method_8745, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getLRJetCombProb"), method_8746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28831), Reflex::Literal("getRecoHyp"), method_8747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28831), Reflex::Literal("getFitHyp"), method_8748, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28831), Reflex::Literal("getMCHyp"), method_8749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TtFullHadronicEvent -------------------------------
static  void operator_8940( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TtFullHadronicEvent*)o)->operator=)(*(const ::TtFullHadronicEvent*)arg[0]);
  else   (((::TtFullHadronicEvent*)o)->operator=)(*(const ::TtFullHadronicEvent*)arg[0]);
}

static void constructor_8941( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtFullHadronicEvent(*(const ::TtFullHadronicEvent*)arg[0]);
  else ::new(mem) ::TtFullHadronicEvent(*(const ::TtFullHadronicEvent*)arg[0]);
}

static void constructor_8942( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtFullHadronicEvent();
  else ::new(mem) ::TtFullHadronicEvent();
}

static void destructor_8943(void*, void * o, const std::vector<void*>&, void *) {
(((::TtFullHadronicEvent*)o)->::TtFullHadronicEvent::~TtFullHadronicEvent)();
}
static  void method_8944( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->top)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->top)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->top)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->top)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->top)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->top)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->top)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->top)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->b)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->b)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->b)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->b)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->b)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->b)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->b)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->b)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightQ)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->lightQ)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightQ)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->lightQ)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightQ)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->lightQ)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightQ)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->lightQ)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightP)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->lightP)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightP)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->lightP)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightP)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->lightP)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightP)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->lightP)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->wPlus)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->wPlus)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->wPlus)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->wPlus)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->wPlus)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->wPlus)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->wPlus)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->wPlus)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8954( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->topBar)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->topBar)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->topBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->topBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8955( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->topBar)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->topBar)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->topBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->topBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8956( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->bBar)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->bBar)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->bBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->bBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8957( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->bBar)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->bBar)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->bBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->bBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8958( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightQBar)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->lightQBar)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightQBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->lightQBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8959( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightQBar)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->lightQBar)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightQBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->lightQBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightPBar)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->lightPBar)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightPBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->lightPBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightPBar)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->lightPBar)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightPBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->lightPBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->wMinus)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->wMinus)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->wMinus)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->wMinus)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->wMinus)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullHadronicEvent*)o)->wMinus)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->wMinus)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullHadronicEvent*)o)->wMinus)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_8964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->top)());
  else   (((const ::TtFullHadronicEvent*)o)->top)();
}

static  void method_8965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->b)());
  else   (((const ::TtFullHadronicEvent*)o)->b)();
}

static  void method_8966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightQ)());
  else   (((const ::TtFullHadronicEvent*)o)->lightQ)();
}

static  void method_8967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightP)());
  else   (((const ::TtFullHadronicEvent*)o)->lightP)();
}

static  void method_8968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->wPlus)());
  else   (((const ::TtFullHadronicEvent*)o)->wPlus)();
}

static  void method_8969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->topBar)());
  else   (((const ::TtFullHadronicEvent*)o)->topBar)();
}

static  void method_8970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->bBar)());
  else   (((const ::TtFullHadronicEvent*)o)->bBar)();
}

static  void method_8971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightQBar)());
  else   (((const ::TtFullHadronicEvent*)o)->lightQBar)();
}

static  void method_8972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->lightPBar)());
  else   (((const ::TtFullHadronicEvent*)o)->lightPBar)();
}

static  void method_8973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullHadronicEvent*)o)->wMinus)());
  else   (((const ::TtFullHadronicEvent*)o)->wMinus)();
}

static  void method_8974( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::TtFullHadronicEvent*)o)->print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::TtFullHadronicEvent*)o)->print)(*(const int*)arg[0]);
  }
}

static void method_newdel_1100( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TtFullHadronicEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TtFullHadronicEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TtFullHadronicEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TtFullHadronicEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TtFullHadronicEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TtEvent")), ::Reflex::BaseOffset< ::TtFullHadronicEvent,::TtEvent >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TtFullHadronicEvent -------------------------------
void __TtFullHadronicEvent_db_datamem(Reflex::Class*);
void __TtFullHadronicEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TtFullHadronicEvent_datamem_bld(&__TtFullHadronicEvent_db_datamem);
Reflex::GenreflexMemberBuilder __TtFullHadronicEvent_funcmem_bld(&__TtFullHadronicEvent_db_funcmem);
void __TtFullHadronicEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TtFullHadronicEvent"), typeid(::TtFullHadronicEvent), sizeof(::TtFullHadronicEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_2674, ::Reflex::BaseOffset< ::TtFullHadronicEvent, ::TtEvent >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46452, type_46453), Reflex::Literal("operator="), operator_8940, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_46453), Reflex::Literal("TtFullHadronicEvent"), constructor_8941, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TtFullHadronicEvent"), constructor_8942, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TtFullHadronicEvent"), destructor_8943, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1100, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__TtFullHadronicEvent_funcmem_bld);
}

//------Delayed data member builder for class TtFullHadronicEvent -------------------
void __TtFullHadronicEvent_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class TtFullHadronicEvent -------------------
void __TtFullHadronicEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("top"), method_8944, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("top"), method_8945, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("b"), method_8946, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("b"), method_8947, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("lightQ"), method_8948, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("lightQ"), method_8949, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("lightP"), method_8950, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("lightP"), method_8951, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("wPlus"), method_8952, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("wPlus"), method_8953, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("topBar"), method_8954, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("topBar"), method_8955, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("bBar"), method_8956, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("bBar"), method_8957, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("lightQBar"), method_8958, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("lightQBar"), method_8959, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("lightPBar"), method_8960, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("lightPBar"), method_8961, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("wMinus"), method_8962, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("wMinus"), method_8963, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("top"), method_8964, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("b"), method_8965, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("lightQ"), method_8966, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("lightP"), method_8967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("wPlus"), method_8968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("topBar"), method_8969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("bBar"), method_8970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("lightQBar"), method_8971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("lightPBar"), method_8972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("wMinus"), method_8973, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_74c), Reflex::Literal("print"), method_8974, 0, "verbosity=1", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TtSemiLeptonicEvent -------------------------------
static  void operator_9129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TtSemiLeptonicEvent*)o)->operator=)(*(const ::TtSemiLeptonicEvent*)arg[0]);
  else   (((::TtSemiLeptonicEvent*)o)->operator=)(*(const ::TtSemiLeptonicEvent*)arg[0]);
}

static void constructor_9130( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtSemiLeptonicEvent(*(const ::TtSemiLeptonicEvent*)arg[0]);
  else ::new(mem) ::TtSemiLeptonicEvent(*(const ::TtSemiLeptonicEvent*)arg[0]);
}

static void constructor_9131( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtSemiLeptonicEvent();
  else ::new(mem) ::TtSemiLeptonicEvent();
}

static void destructor_9132(void*, void * o, const std::vector<void*>&, void *) {
(((::TtSemiLeptonicEvent*)o)->::TtSemiLeptonicEvent::~TtSemiLeptonicEvent)();
}
static  void method_9133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayTop)(*(const ::std::string*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayTop)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayTop)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayTop)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayTop)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayTop)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayTop)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayTop)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayB)(*(const ::std::string*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayB)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayB)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayB)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayB)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayB)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayB)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayB)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayW)(*(const ::std::string*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayW)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayW)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayW)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayW)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayW)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayW)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayW)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuark)(*(const ::std::string*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuark)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuark)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuark)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuark)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuark)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuark)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuark)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuarkBar)(*(const ::std::string*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuarkBar)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuarkBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuarkBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuarkBar)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuarkBar)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuarkBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuarkBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayTop)(*(const ::std::string*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayTop)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayTop)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayTop)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayTop)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayTop)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayTop)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayTop)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayB)(*(const ::std::string*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayB)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayB)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayB)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayB)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayB)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayB)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayB)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9147( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayW)(*(const ::std::string*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayW)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayW)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayW)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayW)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayW)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayW)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayW)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->singleNeutrino)(*(const ::std::string*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->singleNeutrino)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->singleNeutrino)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->singleNeutrino)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->singleNeutrino)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->singleNeutrino)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->singleNeutrino)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->singleNeutrino)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->singleLepton)(*(const ::std::string*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->singleLepton)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->singleLepton)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->singleLepton)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->singleLepton)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtSemiLeptonicEvent*)o)->singleLepton)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->singleLepton)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtSemiLeptonicEvent*)o)->singleLepton)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_9153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayTop)());
  else   (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayTop)();
}

static  void method_9154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayB)());
  else   (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayB)();
}

static  void method_9155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayW)());
  else   (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayW)();
}

static  void method_9156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuark)());
  else   (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuark)();
}

static  void method_9157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuarkBar)());
  else   (((const ::TtSemiLeptonicEvent*)o)->hadronicDecayQuarkBar)();
}

static  void method_9158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayTop)());
  else   (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayTop)();
}

static  void method_9159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayB)());
  else   (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayB)();
}

static  void method_9160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->leptonicDecayW)());
  else   (((const ::TtSemiLeptonicEvent*)o)->leptonicDecayW)();
}

static  void method_9161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->singleLepton)());
  else   (((const ::TtSemiLeptonicEvent*)o)->singleLepton)();
}

static  void method_9162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtSemiLeptonicEvent*)o)->singleNeutrino)());
  else   (((const ::TtSemiLeptonicEvent*)o)->singleNeutrino)();
}

static  void method_9163( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::TtSemiLeptonicEvent*)o)->print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::TtSemiLeptonicEvent*)o)->print)(*(const int*)arg[0]);
  }
}

static  void method_9164( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtSemiLeptonicEvent*)o)->numberOfRealNeutrinoSolutions)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::TtSemiLeptonicEvent*)o)->numberOfRealNeutrinoSolutions)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_9165( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtSemiLeptonicEvent*)o)->numberOfRealNeutrinoSolutions)(*(const ::std::string*)arg[0]));
  else   (((const ::TtSemiLeptonicEvent*)o)->numberOfRealNeutrinoSolutions)(*(const ::std::string*)arg[0]);
}

static  void method_9166( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtSemiLeptonicEvent*)o)->setNumberOfRealNeutrinoSolutions)(*(const ::TtEvent::HypoClassKey*)arg[0],
    *(const int*)arg[1]);
}

static void method_newdel_1227( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TtSemiLeptonicEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TtSemiLeptonicEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TtSemiLeptonicEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TtSemiLeptonicEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TtSemiLeptonicEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TtEvent")), ::Reflex::BaseOffset< ::TtSemiLeptonicEvent,::TtEvent >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TtSemiLeptonicEvent -------------------------------
void __TtSemiLeptonicEvent_db_datamem(Reflex::Class*);
void __TtSemiLeptonicEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TtSemiLeptonicEvent_datamem_bld(&__TtSemiLeptonicEvent_db_datamem);
Reflex::GenreflexMemberBuilder __TtSemiLeptonicEvent_funcmem_bld(&__TtSemiLeptonicEvent_db_funcmem);
void __TtSemiLeptonicEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TtSemiLeptonicEvent"), typeid(::TtSemiLeptonicEvent), sizeof(::TtSemiLeptonicEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_2674, ::Reflex::BaseOffset< ::TtSemiLeptonicEvent, ::TtEvent >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46479, type_46480), Reflex::Literal("operator="), operator_9129, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_46480), Reflex::Literal("TtSemiLeptonicEvent"), constructor_9130, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TtSemiLeptonicEvent"), constructor_9131, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TtSemiLeptonicEvent"), destructor_9132, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1227, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TtSemiLeptonicEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TtSemiLeptonicEvent_funcmem_bld);
}

//------Delayed data member builder for class TtSemiLeptonicEvent -------------------
void __TtSemiLeptonicEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3844, Reflex::Literal("numberOfRealNeutrinoSolutions_"), OffsetOf(__shadow__::__TtSemiLeptonicEvent, numberOfRealNeutrinoSolutions_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TtSemiLeptonicEvent -------------------
void __TtSemiLeptonicEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("hadronicDecayTop"), method_9133, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("hadronicDecayTop"), method_9134, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("hadronicDecayB"), method_9135, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("hadronicDecayB"), method_9136, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("hadronicDecayW"), method_9137, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("hadronicDecayW"), method_9138, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("hadronicDecayQuark"), method_9139, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("hadronicDecayQuark"), method_9140, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("hadronicDecayQuarkBar"), method_9141, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("hadronicDecayQuarkBar"), method_9142, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("leptonicDecayTop"), method_9143, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("leptonicDecayTop"), method_9144, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("leptonicDecayB"), method_9145, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("leptonicDecayB"), method_9146, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("leptonicDecayW"), method_9147, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("leptonicDecayW"), method_9148, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("singleNeutrino"), method_9149, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("singleNeutrino"), method_9150, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("singleLepton"), method_9151, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("singleLepton"), method_9152, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("hadronicDecayTop"), method_9153, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("hadronicDecayB"), method_9154, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("hadronicDecayW"), method_9155, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("hadronicDecayQuark"), method_9156, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("hadronicDecayQuarkBar"), method_9157, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("leptonicDecayTop"), method_9158, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("leptonicDecayB"), method_9159, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("leptonicDecayW"), method_9160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("singleLepton"), method_9161, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("singleNeutrino"), method_9162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_74c), Reflex::Literal("print"), method_9163, 0, "verbosity=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74c, type_46455), Reflex::Literal("numberOfRealNeutrinoSolutions"), method_9164, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74c, type_30186), Reflex::Literal("numberOfRealNeutrinoSolutions"), method_9165, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_46455, type_16670), Reflex::Literal("setNumberOfRealNeutrinoSolutions"), method_9166, 0, "key;nr", ::Reflex::PUBLIC);
}
//------Stub functions for class StEvtSolution -------------------------------
static  void operator_10023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::StEvtSolution*)o)->operator=)(*(const ::StEvtSolution*)arg[0]);
  else   (((::StEvtSolution*)o)->operator=)(*(const ::StEvtSolution*)arg[0]);
}

static void constructor_10024( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::StEvtSolution(*(const ::StEvtSolution*)arg[0]);
  else ::new(mem) ::StEvtSolution(*(const ::StEvtSolution*)arg[0]);
}

static void constructor_10025( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::StEvtSolution();
  else ::new(mem) ::StEvtSolution();
}

static void destructor_10026(void*, void * o, const std::vector<void*>&, void *) {
(((::StEvtSolution*)o)->::StEvtSolution::~StEvtSolution)();
}
static  void method_10027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::StEvtSolution*)o)->getBottom)());
  else   (((const ::StEvtSolution*)o)->getBottom)();
}

static  void method_10028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::StEvtSolution*)o)->getLight)());
  else   (((const ::StEvtSolution*)o)->getLight)();
}

static  void method_10029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Muon)((((const ::StEvtSolution*)o)->getMuon)());
  else   (((const ::StEvtSolution*)o)->getMuon)();
}

static  void method_10030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Electron)((((const ::StEvtSolution*)o)->getElectron)());
  else   (((const ::StEvtSolution*)o)->getElectron)();
}

static  void method_10031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::MET)((((const ::StEvtSolution*)o)->getNeutrino)());
  else   (((const ::StEvtSolution*)o)->getNeutrino)();
}

static  void method_10032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::StEvtSolution*)o)->getLepW)());
  else   (((const ::StEvtSolution*)o)->getLepW)();
}

static  void method_10033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::StEvtSolution*)o)->getLept)());
  else   (((const ::StEvtSolution*)o)->getLept)();
}

static  void method_10034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::StEvtSolution*)o)->getGenEvent)();
  else   (((const ::StEvtSolution*)o)->getGenEvent)();
}

static  void method_10035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::StEvtSolution*)o)->getGenBottom)());
  else   (((const ::StEvtSolution*)o)->getGenBottom)();
}

static  void method_10036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::StEvtSolution*)o)->getGenLepton)());
  else   (((const ::StEvtSolution*)o)->getGenLepton)();
}

static  void method_10037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::StEvtSolution*)o)->getGenNeutrino)());
  else   (((const ::StEvtSolution*)o)->getGenNeutrino)();
}

static  void method_10038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::StEvtSolution*)o)->getGenLepW)());
  else   (((const ::StEvtSolution*)o)->getGenLepW)();
}

static  void method_10039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::StEvtSolution*)o)->getGenLept)());
  else   (((const ::StEvtSolution*)o)->getGenLept)();
}

static  void method_10040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::StEvtSolution*)o)->getRecBottom)());
  else   (((const ::StEvtSolution*)o)->getRecBottom)();
}

static  void method_10041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::StEvtSolution*)o)->getRecLight)());
  else   (((const ::StEvtSolution*)o)->getRecLight)();
}

static  void method_10042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Muon)((((const ::StEvtSolution*)o)->getRecMuon)());
  else   (((const ::StEvtSolution*)o)->getRecMuon)();
}

static  void method_10043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Electron)((((const ::StEvtSolution*)o)->getRecElectron)());
  else   (((const ::StEvtSolution*)o)->getRecElectron)();
}

static  void method_10044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::MET)((((const ::StEvtSolution*)o)->getRecNeutrino)());
  else   (((const ::StEvtSolution*)o)->getRecNeutrino)();
}

static  void method_10045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::StEvtSolution*)o)->getRecLepW)());
  else   (((const ::StEvtSolution*)o)->getRecLepW)();
}

static  void method_10046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::StEvtSolution*)o)->getRecLept)());
  else   (((const ::StEvtSolution*)o)->getRecLept)();
}

static  void method_10047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::StEvtSolution*)o)->getFitBottom)());
  else   (((const ::StEvtSolution*)o)->getFitBottom)();
}

static  void method_10048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::StEvtSolution*)o)->getFitLight)());
  else   (((const ::StEvtSolution*)o)->getFitLight)();
}

static  void method_10049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::StEvtSolution*)o)->getFitLepton)());
  else   (((const ::StEvtSolution*)o)->getFitLepton)();
}

static  void method_10050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::StEvtSolution*)o)->getFitNeutrino)());
  else   (((const ::StEvtSolution*)o)->getFitNeutrino)();
}

static  void method_10051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::StEvtSolution*)o)->getFitLepW)());
  else   (((const ::StEvtSolution*)o)->getFitLepW)();
}

static  void method_10052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::StEvtSolution*)o)->getFitLept)());
  else   (((const ::StEvtSolution*)o)->getFitLept)();
}

static  void method_10053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::StEvtSolution*)o)->getDecay)());
  else   (((const ::StEvtSolution*)o)->getDecay)();
}

static  void method_10054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<double>)((((const ::StEvtSolution*)o)->getScanValues)());
  else   (((const ::StEvtSolution*)o)->getScanValues)();
}

static  void method_10055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::StEvtSolution*)o)->getChi2Prob)());
  else   (((const ::StEvtSolution*)o)->getChi2Prob)();
}

static  void method_10056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::StEvtSolution*)o)->getPtrueCombExist)());
  else   (((const ::StEvtSolution*)o)->getPtrueCombExist)();
}

static  void method_10057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::StEvtSolution*)o)->getPtrueBJetSel)());
  else   (((const ::StEvtSolution*)o)->getPtrueBJetSel)();
}

static  void method_10058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::StEvtSolution*)o)->getPtrueBhadrSel)());
  else   (((const ::StEvtSolution*)o)->getPtrueBhadrSel)();
}

static  void method_10059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::StEvtSolution*)o)->getPtrueJetComb)());
  else   (((const ::StEvtSolution*)o)->getPtrueJetComb)();
}

static  void method_10060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::StEvtSolution*)o)->getSignalPur)());
  else   (((const ::StEvtSolution*)o)->getSignalPur)();
}

static  void method_10061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::StEvtSolution*)o)->getSignalLRTot)());
  else   (((const ::StEvtSolution*)o)->getSignalLRTot)();
}

static  void method_10062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::StEvtSolution*)o)->getSumDeltaRjp)());
  else   (((const ::StEvtSolution*)o)->getSumDeltaRjp)();
}

static  void method_10063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::StEvtSolution*)o)->getDeltaRB)());
  else   (((const ::StEvtSolution*)o)->getDeltaRB)();
}

static  void method_10064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::StEvtSolution*)o)->getDeltaRL)());
  else   (((const ::StEvtSolution*)o)->getDeltaRL)();
}

static  void method_10065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::StEvtSolution*)o)->getChangeBL)());
  else   (((const ::StEvtSolution*)o)->getChangeBL)();
}

static  void method_10066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::StEvtSolution*)o)->getBestSol)());
  else   (((const ::StEvtSolution*)o)->getBestSol)();
}

static void method_newdel_1709( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::StEvtSolution >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::StEvtSolution >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::StEvtSolution >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::StEvtSolution >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::StEvtSolution >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class StEvtSolution -------------------------------
void __StEvtSolution_db_datamem(Reflex::Class*);
void __StEvtSolution_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __StEvtSolution_datamem_bld(&__StEvtSolution_db_datamem);
Reflex::GenreflexMemberBuilder __StEvtSolution_funcmem_bld(&__StEvtSolution_db_funcmem);
void __StEvtSolution_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("StEvtSolution"), typeid(::StEvtSolution), sizeof(::StEvtSolution), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20557, type_20559), Reflex::Literal("operator="), operator_10023, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20559), Reflex::Literal("StEvtSolution"), constructor_10024, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("StEvtSolution"), constructor_10025, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StEvtSolution"), destructor_10026, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1709, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__StEvtSolution_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__StEvtSolution_funcmem_bld);
}

//------Delayed data member builder for class StEvtSolution -------------------
void __StEvtSolution_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6624, Reflex::Literal("theGenEvt_"), OffsetOf(__shadow__::__StEvtSolution, theGenEvt_), ::Reflex::PRIVATE)
  .AddDataMember(type_6745, Reflex::Literal("bottom_"), OffsetOf(__shadow__::__StEvtSolution, bottom_), ::Reflex::PRIVATE)
  .AddDataMember(type_6745, Reflex::Literal("light_"), OffsetOf(__shadow__::__StEvtSolution, light_), ::Reflex::PRIVATE)
  .AddDataMember(type_6749, Reflex::Literal("muon_"), OffsetOf(__shadow__::__StEvtSolution, muon_), ::Reflex::PRIVATE)
  .AddDataMember(type_6747, Reflex::Literal("electron_"), OffsetOf(__shadow__::__StEvtSolution, electron_), ::Reflex::PRIVATE)
  .AddDataMember(type_6746, Reflex::Literal("neutrino_"), OffsetOf(__shadow__::__StEvtSolution, neutrino_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitBottom_"), OffsetOf(__shadow__::__StEvtSolution, fitBottom_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitLight_"), OffsetOf(__shadow__::__StEvtSolution, fitLight_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitLepton_"), OffsetOf(__shadow__::__StEvtSolution, fitLepton_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitNeutrino_"), OffsetOf(__shadow__::__StEvtSolution, fitNeutrino_), ::Reflex::PRIVATE)
  .AddDataMember(type_2978, Reflex::Literal("decay_"), OffsetOf(__shadow__::__StEvtSolution, decay_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("jetCorrScheme_"), OffsetOf(__shadow__::__StEvtSolution, jetCorrScheme_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("chi2Prob_"), OffsetOf(__shadow__::__StEvtSolution, chi2Prob_), ::Reflex::PRIVATE)
  .AddDataMember(type_3597, Reflex::Literal("scanValues_"), OffsetOf(__shadow__::__StEvtSolution, scanValues_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("pTrueCombExist_"), OffsetOf(__shadow__::__StEvtSolution, pTrueCombExist_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("pTrueBJetSel_"), OffsetOf(__shadow__::__StEvtSolution, pTrueBJetSel_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("pTrueBhadrSel_"), OffsetOf(__shadow__::__StEvtSolution, pTrueBhadrSel_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("pTrueJetComb_"), OffsetOf(__shadow__::__StEvtSolution, pTrueJetComb_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("signalPur_"), OffsetOf(__shadow__::__StEvtSolution, signalPur_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("signalLRTot_"), OffsetOf(__shadow__::__StEvtSolution, signalLRTot_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("sumDeltaRjp_"), OffsetOf(__shadow__::__StEvtSolution, sumDeltaRjp_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("deltaRB_"), OffsetOf(__shadow__::__StEvtSolution, deltaRB_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("deltaRL_"), OffsetOf(__shadow__::__StEvtSolution, deltaRL_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("changeBL_"), OffsetOf(__shadow__::__StEvtSolution, changeBL_), ::Reflex::PRIVATE)
  .AddDataMember(type_1798, Reflex::Literal("bestSol_"), OffsetOf(__shadow__::__StEvtSolution, bestSol_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class StEvtSolution -------------------
void __StEvtSolution_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getBottom"), method_10027, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getLight"), method_10028, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12913), Reflex::Literal("getMuon"), method_10029, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12981), Reflex::Literal("getElectron"), method_10030, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12916), Reflex::Literal("getNeutrino"), method_10031, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getLepW"), method_10032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getLept"), method_10033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47411), Reflex::Literal("getGenEvent"), method_10034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenBottom"), method_10035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenLepton"), method_10036, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenNeutrino"), method_10037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenLepW"), method_10038, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenLept"), method_10039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecBottom"), method_10040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecLight"), method_10041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12913), Reflex::Literal("getRecMuon"), method_10042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12981), Reflex::Literal("getRecElectron"), method_10043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12916), Reflex::Literal("getRecNeutrino"), method_10044, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getRecLepW"), method_10045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getRecLept"), method_10046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitBottom"), method_10047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitLight"), method_10048, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitLepton"), method_10049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitNeutrino"), method_10050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getFitLepW"), method_10051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getFitLept"), method_10052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2978), Reflex::Literal("getDecay"), method_10053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3597), Reflex::Literal("getScanValues"), method_10054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getChi2Prob"), method_10055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getPtrueCombExist"), method_10056, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getPtrueBJetSel"), method_10057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getPtrueBhadrSel"), method_10058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getPtrueJetComb"), method_10059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getSignalPur"), method_10060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getSignalLRTot"), method_10061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getSumDeltaRjp"), method_10062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getDeltaRB"), method_10063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getDeltaRL"), method_10064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getChangeBL"), method_10065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("getBestSol"), method_10066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TtHadEvtSolution -------------------------------
static  void operator_10319( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TtHadEvtSolution*)o)->operator=)(*(const ::TtHadEvtSolution*)arg[0]);
  else   (((::TtHadEvtSolution*)o)->operator=)(*(const ::TtHadEvtSolution*)arg[0]);
}

static void constructor_10320( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtHadEvtSolution(*(const ::TtHadEvtSolution*)arg[0]);
  else ::new(mem) ::TtHadEvtSolution(*(const ::TtHadEvtSolution*)arg[0]);
}

static void constructor_10321( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtHadEvtSolution();
  else ::new(mem) ::TtHadEvtSolution();
}

static void destructor_10322(void*, void * o, const std::vector<void*>&, void *) {
(((::TtHadEvtSolution*)o)->::TtHadEvtSolution::~TtHadEvtSolution)();
}
static  void method_10323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getHadb)());
  else   (((const ::TtHadEvtSolution*)o)->getHadb)();
}

static  void method_10324( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getHadp)());
  else   (((const ::TtHadEvtSolution*)o)->getHadp)();
}

static  void method_10325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getHadq)());
  else   (((const ::TtHadEvtSolution*)o)->getHadq)();
}

static  void method_10326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getHadbbar)());
  else   (((const ::TtHadEvtSolution*)o)->getHadbbar)();
}

static  void method_10327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getHadj)());
  else   (((const ::TtHadEvtSolution*)o)->getHadj)();
}

static  void method_10328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getHadk)());
  else   (((const ::TtHadEvtSolution*)o)->getHadk)();
}

static  void method_10329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::TtHadEvtSolution*)o)->getGenEvent)();
  else   (((const ::TtHadEvtSolution*)o)->getGenEvent)();
}

static  void method_10330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtHadEvtSolution*)o)->getGenHadb)());
  else   (((const ::TtHadEvtSolution*)o)->getGenHadb)();
}

static  void method_10331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtHadEvtSolution*)o)->getGenHadbbar)());
  else   (((const ::TtHadEvtSolution*)o)->getGenHadbbar)();
}

static  void method_10332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtHadEvtSolution*)o)->getGenHadp)());
  else   (((const ::TtHadEvtSolution*)o)->getGenHadp)();
}

static  void method_10333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtHadEvtSolution*)o)->getGenHadq)());
  else   (((const ::TtHadEvtSolution*)o)->getGenHadq)();
}

static  void method_10334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtHadEvtSolution*)o)->getGenHadj)());
  else   (((const ::TtHadEvtSolution*)o)->getGenHadj)();
}

static  void method_10335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtHadEvtSolution*)o)->getGenHadk)());
  else   (((const ::TtHadEvtSolution*)o)->getGenHadk)();
}

static  void method_10336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtHadEvtSolution*)o)->getRecHadt)());
  else   (((const ::TtHadEvtSolution*)o)->getRecHadt)();
}

static  void method_10337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtHadEvtSolution*)o)->getRecHadtbar)());
  else   (((const ::TtHadEvtSolution*)o)->getRecHadtbar)();
}

static  void method_10338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtHadEvtSolution*)o)->getRecHadW_plus)());
  else   (((const ::TtHadEvtSolution*)o)->getRecHadW_plus)();
}

static  void method_10339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtHadEvtSolution*)o)->getRecHadW_minus)());
  else   (((const ::TtHadEvtSolution*)o)->getRecHadW_minus)();
}

static  void method_10340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getRecHadb)());
  else   (((const ::TtHadEvtSolution*)o)->getRecHadb)();
}

static  void method_10341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getRecHadbbar)());
  else   (((const ::TtHadEvtSolution*)o)->getRecHadbbar)();
}

static  void method_10342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getRecHadp)());
  else   (((const ::TtHadEvtSolution*)o)->getRecHadp)();
}

static  void method_10343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getRecHadq)());
  else   (((const ::TtHadEvtSolution*)o)->getRecHadq)();
}

static  void method_10344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getRecHadj)());
  else   (((const ::TtHadEvtSolution*)o)->getRecHadj)();
}

static  void method_10345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getRecHadk)());
  else   (((const ::TtHadEvtSolution*)o)->getRecHadk)();
}

static  void method_10346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtHadEvtSolution*)o)->getCalHadt)());
  else   (((const ::TtHadEvtSolution*)o)->getCalHadt)();
}

static  void method_10347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtHadEvtSolution*)o)->getCalHadtbar)());
  else   (((const ::TtHadEvtSolution*)o)->getCalHadtbar)();
}

static  void method_10348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtHadEvtSolution*)o)->getCalHadW_plus)());
  else   (((const ::TtHadEvtSolution*)o)->getCalHadW_plus)();
}

static  void method_10349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtHadEvtSolution*)o)->getCalHadW_minus)());
  else   (((const ::TtHadEvtSolution*)o)->getCalHadW_minus)();
}

static  void method_10350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getCalHadb)());
  else   (((const ::TtHadEvtSolution*)o)->getCalHadb)();
}

static  void method_10351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getCalHadbbar)());
  else   (((const ::TtHadEvtSolution*)o)->getCalHadbbar)();
}

static  void method_10352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getCalHadp)());
  else   (((const ::TtHadEvtSolution*)o)->getCalHadp)();
}

static  void method_10353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getCalHadq)());
  else   (((const ::TtHadEvtSolution*)o)->getCalHadq)();
}

static  void method_10354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getCalHadj)());
  else   (((const ::TtHadEvtSolution*)o)->getCalHadj)();
}

static  void method_10355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtHadEvtSolution*)o)->getCalHadk)());
  else   (((const ::TtHadEvtSolution*)o)->getCalHadk)();
}

static  void method_10356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtHadEvtSolution*)o)->getFitHadt)());
  else   (((const ::TtHadEvtSolution*)o)->getFitHadt)();
}

static  void method_10357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtHadEvtSolution*)o)->getFitHadtbar)());
  else   (((const ::TtHadEvtSolution*)o)->getFitHadtbar)();
}

static  void method_10358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtHadEvtSolution*)o)->getFitHadW_plus)());
  else   (((const ::TtHadEvtSolution*)o)->getFitHadW_plus)();
}

static  void method_10359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtHadEvtSolution*)o)->getFitHadW_minus)());
  else   (((const ::TtHadEvtSolution*)o)->getFitHadW_minus)();
}

static  void method_10360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::TtHadEvtSolution*)o)->getFitHadb)());
  else   (((const ::TtHadEvtSolution*)o)->getFitHadb)();
}

static  void method_10361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::TtHadEvtSolution*)o)->getFitHadbbar)());
  else   (((const ::TtHadEvtSolution*)o)->getFitHadbbar)();
}

static  void method_10362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::TtHadEvtSolution*)o)->getFitHadp)());
  else   (((const ::TtHadEvtSolution*)o)->getFitHadp)();
}

static  void method_10363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::TtHadEvtSolution*)o)->getFitHadq)());
  else   (((const ::TtHadEvtSolution*)o)->getFitHadq)();
}

static  void method_10364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::TtHadEvtSolution*)o)->getFitHadj)());
  else   (((const ::TtHadEvtSolution*)o)->getFitHadj)();
}

static  void method_10365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Particle)((((const ::TtHadEvtSolution*)o)->getFitHadk)());
  else   (((const ::TtHadEvtSolution*)o)->getFitHadk)();
}

static  void method_10366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TtHadEvtSolution*)o)->getDecay)());
  else   (((const ::TtHadEvtSolution*)o)->getDecay)();
}

static  void method_10367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getMCBestSumAngles)());
  else   (((const ::TtHadEvtSolution*)o)->getMCBestSumAngles)();
}

static  void method_10368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getMCBestAngleHadp)());
  else   (((const ::TtHadEvtSolution*)o)->getMCBestAngleHadp)();
}

static  void method_10369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getMCBestAngleHadq)());
  else   (((const ::TtHadEvtSolution*)o)->getMCBestAngleHadq)();
}

static  void method_10370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getMCBestAngleHadj)());
  else   (((const ::TtHadEvtSolution*)o)->getMCBestAngleHadj)();
}

static  void method_10371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getMCBestAngleHadk)());
  else   (((const ::TtHadEvtSolution*)o)->getMCBestAngleHadk)();
}

static  void method_10372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getMCBestAngleHadb)());
  else   (((const ::TtHadEvtSolution*)o)->getMCBestAngleHadb)();
}

static  void method_10373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getMCBestAngleHadbbar)());
  else   (((const ::TtHadEvtSolution*)o)->getMCBestAngleHadbbar)();
}

static  void method_10374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtHadEvtSolution*)o)->getMCChangeW1Q)());
  else   (((const ::TtHadEvtSolution*)o)->getMCChangeW1Q)();
}

static  void method_10375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtHadEvtSolution*)o)->getMCChangeW2Q)());
  else   (((const ::TtHadEvtSolution*)o)->getMCChangeW2Q)();
}

static  void method_10376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtHadEvtSolution*)o)->getJetParametrisation)());
  else   (((const ::TtHadEvtSolution*)o)->getJetParametrisation)();
}

static  void method_10377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getProbChi2)());
  else   (((const ::TtHadEvtSolution*)o)->getProbChi2)();
}

static  void method_10378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getLRSignalEvtObsVal)(*(unsigned int*)arg[0]));
  else   (((const ::TtHadEvtSolution*)o)->getLRSignalEvtObsVal)(*(unsigned int*)arg[0]);
}

static  void method_10379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getLRSignalEvtLRval)());
  else   (((const ::TtHadEvtSolution*)o)->getLRSignalEvtLRval)();
}

static  void method_10380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getLRSignalEvtProb)());
  else   (((const ::TtHadEvtSolution*)o)->getLRSignalEvtProb)();
}

static  void method_10381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtHadEvtSolution*)o)->getMCBestJetComb)());
  else   (((const ::TtHadEvtSolution*)o)->getMCBestJetComb)();
}

static  void method_10382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtHadEvtSolution*)o)->getSimpleBestJetComb)());
  else   (((const ::TtHadEvtSolution*)o)->getSimpleBestJetComb)();
}

static  void method_10383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtHadEvtSolution*)o)->getLRBestJetComb)());
  else   (((const ::TtHadEvtSolution*)o)->getLRBestJetComb)();
}

static  void method_10384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getLRJetCombObsVal)(*(unsigned int*)arg[0]));
  else   (((const ::TtHadEvtSolution*)o)->getLRJetCombObsVal)(*(unsigned int*)arg[0]);
}

static  void method_10385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getLRJetCombLRval)());
  else   (((const ::TtHadEvtSolution*)o)->getLRJetCombLRval)();
}

static  void method_10386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtHadEvtSolution*)o)->getLRJetCombProb)());
  else   (((const ::TtHadEvtSolution*)o)->getLRJetCombProb)();
}

static  void method_10387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setGenEvt)(*(const ::edm::Handle<TtGenEvent>*)arg[0]);
}

static  void method_10388( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setJetCorrectionScheme)(*(int*)arg[0]);
}

static  void method_10389( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setHadp)(*(const ::edm::Handle<std::vector<pat::Jet> >*)arg[0],
    *(int*)arg[1]);
}

static  void method_10390( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setHadq)(*(const ::edm::Handle<std::vector<pat::Jet> >*)arg[0],
    *(int*)arg[1]);
}

static  void method_10391( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setHadj)(*(const ::edm::Handle<std::vector<pat::Jet> >*)arg[0],
    *(int*)arg[1]);
}

static  void method_10392( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setHadk)(*(const ::edm::Handle<std::vector<pat::Jet> >*)arg[0],
    *(int*)arg[1]);
}

static  void method_10393( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setHadb)(*(const ::edm::Handle<std::vector<pat::Jet> >*)arg[0],
    *(int*)arg[1]);
}

static  void method_10394( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setHadbbar)(*(const ::edm::Handle<std::vector<pat::Jet> >*)arg[0],
    *(int*)arg[1]);
}

static  void method_10395( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setFitHadp)(*(const ::pat::Particle*)arg[0]);
}

static  void method_10396( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setFitHadq)(*(const ::pat::Particle*)arg[0]);
}

static  void method_10397( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setFitHadj)(*(const ::pat::Particle*)arg[0]);
}

static  void method_10398( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setFitHadk)(*(const ::pat::Particle*)arg[0]);
}

static  void method_10399( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setFitHadb)(*(const ::pat::Particle*)arg[0]);
}

static  void method_10400( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setFitHadbbar)(*(const ::pat::Particle*)arg[0]);
}

static  void method_10401( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setMCBestSumAngles)(*(double*)arg[0]);
}

static  void method_10402( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setMCBestAngleHadp)(*(double*)arg[0]);
}

static  void method_10403( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setMCBestAngleHadq)(*(double*)arg[0]);
}

static  void method_10404( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setMCBestAngleHadj)(*(double*)arg[0]);
}

static  void method_10405( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setMCBestAngleHadk)(*(double*)arg[0]);
}

static  void method_10406( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setMCBestAngleHadb)(*(double*)arg[0]);
}

static  void method_10407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setMCBestAngleHadbbar)(*(double*)arg[0]);
}

static  void method_10408( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setMCChangeW1Q)(*(int*)arg[0]);
}

static  void method_10409( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setMCChangeW2Q)(*(int*)arg[0]);
}

static  void method_10410( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setJetParametrisation)(*(int*)arg[0]);
}

static  void method_10411( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setProbChi2)(*(double*)arg[0]);
}

static  void method_10412( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setMCBestJetComb)(*(int*)arg[0]);
}

static  void method_10413( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setSimpleBestJetComb)(*(int*)arg[0]);
}

static  void method_10414( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setLRBestJetComb)(*(int*)arg[0]);
}

static  void method_10415( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setLRJetCombObservables)(*(::std::vector<std::pair<unsigned int,double> >*)arg[0]);
}

static  void method_10416( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setLRJetCombLRval)(*(double*)arg[0]);
}

static  void method_10417( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setLRJetCombProb)(*(double*)arg[0]);
}

static  void method_10418( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setLRSignalEvtObservables)(*(::std::vector<std::pair<unsigned int,double> >*)arg[0]);
}

static  void method_10419( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setLRSignalEvtLRval)(*(double*)arg[0]);
}

static  void method_10420( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtHadEvtSolution*)o)->setLRSignalEvtProb)(*(double*)arg[0]);
}

static void method_newdel_1805( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TtHadEvtSolution >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TtHadEvtSolution >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TtHadEvtSolution >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TtHadEvtSolution >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TtHadEvtSolution >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TtHadEvtSolution -------------------------------
void __TtHadEvtSolution_db_datamem(Reflex::Class*);
void __TtHadEvtSolution_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TtHadEvtSolution_datamem_bld(&__TtHadEvtSolution_db_datamem);
Reflex::GenreflexMemberBuilder __TtHadEvtSolution_funcmem_bld(&__TtHadEvtSolution_db_funcmem);
void __TtHadEvtSolution_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TtHadEvtSolution"), typeid(::TtHadEvtSolution), sizeof(::TtHadEvtSolution), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20622, type_20624), Reflex::Literal("operator="), operator_10319, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20624), Reflex::Literal("TtHadEvtSolution"), constructor_10320, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TtHadEvtSolution"), constructor_10321, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TtHadEvtSolution"), destructor_10322, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1805, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TtHadEvtSolution_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TtHadEvtSolution_funcmem_bld);
}

//------Delayed data member builder for class TtHadEvtSolution -------------------
void __TtHadEvtSolution_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6625, Reflex::Literal("theGenEvt_"), OffsetOf(__shadow__::__TtHadEvtSolution, theGenEvt_), ::Reflex::PRIVATE)
  .AddDataMember(type_6745, Reflex::Literal("hadb_"), OffsetOf(__shadow__::__TtHadEvtSolution, hadb_), ::Reflex::PRIVATE)
  .AddDataMember(type_6745, Reflex::Literal("hadp_"), OffsetOf(__shadow__::__TtHadEvtSolution, hadp_), ::Reflex::PRIVATE)
  .AddDataMember(type_6745, Reflex::Literal("hadq_"), OffsetOf(__shadow__::__TtHadEvtSolution, hadq_), ::Reflex::PRIVATE)
  .AddDataMember(type_6745, Reflex::Literal("hadbbar_"), OffsetOf(__shadow__::__TtHadEvtSolution, hadbbar_), ::Reflex::PRIVATE)
  .AddDataMember(type_6745, Reflex::Literal("hadj_"), OffsetOf(__shadow__::__TtHadEvtSolution, hadj_), ::Reflex::PRIVATE)
  .AddDataMember(type_6745, Reflex::Literal("hadk_"), OffsetOf(__shadow__::__TtHadEvtSolution, hadk_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitHadb_"), OffsetOf(__shadow__::__TtHadEvtSolution, fitHadb_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitHadp_"), OffsetOf(__shadow__::__TtHadEvtSolution, fitHadp_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitHadq_"), OffsetOf(__shadow__::__TtHadEvtSolution, fitHadq_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitHadbbar_"), OffsetOf(__shadow__::__TtHadEvtSolution, fitHadbbar_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitHadj_"), OffsetOf(__shadow__::__TtHadEvtSolution, fitHadj_), ::Reflex::PRIVATE)
  .AddDataMember(type_3561, Reflex::Literal("fitHadk_"), OffsetOf(__shadow__::__TtHadEvtSolution, fitHadk_), ::Reflex::PRIVATE)
  .AddDataMember(type_2978, Reflex::Literal("decay_"), OffsetOf(__shadow__::__TtHadEvtSolution, decay_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("jetCorrScheme_"), OffsetOf(__shadow__::__TtHadEvtSolution, jetCorrScheme_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("sumAnglejp_"), OffsetOf(__shadow__::__TtHadEvtSolution, sumAnglejp_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("angleHadp_"), OffsetOf(__shadow__::__TtHadEvtSolution, angleHadp_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("angleHadq_"), OffsetOf(__shadow__::__TtHadEvtSolution, angleHadq_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("angleHadb_"), OffsetOf(__shadow__::__TtHadEvtSolution, angleHadb_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("angleHadbbar_"), OffsetOf(__shadow__::__TtHadEvtSolution, angleHadbbar_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("angleHadj_"), OffsetOf(__shadow__::__TtHadEvtSolution, angleHadj_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("angleHadk_"), OffsetOf(__shadow__::__TtHadEvtSolution, angleHadk_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("changeW1Q_"), OffsetOf(__shadow__::__TtHadEvtSolution, changeW1Q_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("changeW2Q_"), OffsetOf(__shadow__::__TtHadEvtSolution, changeW2Q_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("jetParam_"), OffsetOf(__shadow__::__TtHadEvtSolution, jetParam_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("probChi2_"), OffsetOf(__shadow__::__TtHadEvtSolution, probChi2_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("mcBestJetComb_"), OffsetOf(__shadow__::__TtHadEvtSolution, mcBestJetComb_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("simpleBestJetComb_"), OffsetOf(__shadow__::__TtHadEvtSolution, simpleBestJetComb_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("lrBestJetComb_"), OffsetOf(__shadow__::__TtHadEvtSolution, lrBestJetComb_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("lrJetCombLRval_"), OffsetOf(__shadow__::__TtHadEvtSolution, lrJetCombLRval_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("lrJetCombProb_"), OffsetOf(__shadow__::__TtHadEvtSolution, lrJetCombProb_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("lrSignalEvtLRval_"), OffsetOf(__shadow__::__TtHadEvtSolution, lrSignalEvtLRval_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("lrSignalEvtProb_"), OffsetOf(__shadow__::__TtHadEvtSolution, lrSignalEvtProb_), ::Reflex::PRIVATE)
  .AddDataMember(type_3560, Reflex::Literal("lrJetCombVarVal_"), OffsetOf(__shadow__::__TtHadEvtSolution, lrJetCombVarVal_), ::Reflex::PRIVATE)
  .AddDataMember(type_3560, Reflex::Literal("lrSignalEvtVarVal_"), OffsetOf(__shadow__::__TtHadEvtSolution, lrSignalEvtVarVal_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TtHadEvtSolution -------------------
void __TtHadEvtSolution_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getHadb"), method_10323, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getHadp"), method_10324, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getHadq"), method_10325, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getHadbbar"), method_10326, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getHadj"), method_10327, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getHadk"), method_10328, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46181), Reflex::Literal("getGenEvent"), method_10329, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenHadb"), method_10330, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenHadbbar"), method_10331, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenHadp"), method_10332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenHadq"), method_10333, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenHadj"), method_10334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenHadk"), method_10335, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getRecHadt"), method_10336, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getRecHadtbar"), method_10337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getRecHadW_plus"), method_10338, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getRecHadW_minus"), method_10339, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecHadb"), method_10340, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecHadbbar"), method_10341, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecHadp"), method_10342, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecHadq"), method_10343, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecHadj"), method_10344, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecHadk"), method_10345, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getCalHadt"), method_10346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getCalHadtbar"), method_10347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getCalHadW_plus"), method_10348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getCalHadW_minus"), method_10349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getCalHadb"), method_10350, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getCalHadbbar"), method_10351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getCalHadp"), method_10352, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getCalHadq"), method_10353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getCalHadj"), method_10354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getCalHadk"), method_10355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getFitHadt"), method_10356, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getFitHadtbar"), method_10357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getFitHadW_plus"), method_10358, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getFitHadW_minus"), method_10359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitHadb"), method_10360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitHadbbar"), method_10361, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitHadp"), method_10362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitHadq"), method_10363, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitHadj"), method_10364, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12943), Reflex::Literal("getFitHadk"), method_10365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2978), Reflex::Literal("getDecay"), method_10366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getMCBestSumAngles"), method_10367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getMCBestAngleHadp"), method_10368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getMCBestAngleHadq"), method_10369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getMCBestAngleHadj"), method_10370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getMCBestAngleHadk"), method_10371, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getMCBestAngleHadb"), method_10372, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getMCBestAngleHadbbar"), method_10373, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getMCChangeW1Q"), method_10374, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getMCChangeW2Q"), method_10375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getJetParametrisation"), method_10376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getProbChi2"), method_10377, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_398), Reflex::Literal("getLRSignalEvtObsVal"), method_10378, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getLRSignalEvtLRval"), method_10379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getLRSignalEvtProb"), method_10380, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getMCBestJetComb"), method_10381, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getSimpleBestJetComb"), method_10382, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74), Reflex::Literal("getLRBestJetComb"), method_10383, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_398), Reflex::Literal("getLRJetCombObsVal"), method_10384, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getLRJetCombLRval"), method_10385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getLRJetCombProb"), method_10386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_46182), Reflex::Literal("setGenEvt"), method_10387, 0, "aGenEvt", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_74), Reflex::Literal("setJetCorrectionScheme"), method_10388, 0, "scheme", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_46183, type_74), Reflex::Literal("setHadp"), method_10389, 0, "jet;i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_46183, type_74), Reflex::Literal("setHadq"), method_10390, 0, "jet;i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_46183, type_74), Reflex::Literal("setHadj"), method_10391, 0, "jet;i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_46183, type_74), Reflex::Literal("setHadk"), method_10392, 0, "jet;i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_46183, type_74), Reflex::Literal("setHadb"), method_10393, 0, "jet;i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_46183, type_74), Reflex::Literal("setHadbbar"), method_10394, 0, "jet;i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_21010), Reflex::Literal("setFitHadp"), method_10395, 0, "aFitHadp", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_21010), Reflex::Literal("setFitHadq"), method_10396, 0, "aFitHadq", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_21010), Reflex::Literal("setFitHadj"), method_10397, 0, "aFitHadj", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_21010), Reflex::Literal("setFitHadk"), method_10398, 0, "aFitHadk", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_21010), Reflex::Literal("setFitHadb"), method_10399, 0, "aFitHadb", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_21010), Reflex::Literal("setFitHadbbar"), method_10400, 0, "aFitHadbbar", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_111), Reflex::Literal("setMCBestSumAngles"), method_10401, 0, "sdr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_111), Reflex::Literal("setMCBestAngleHadp"), method_10402, 0, "adr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_111), Reflex::Literal("setMCBestAngleHadq"), method_10403, 0, "adr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_111), Reflex::Literal("setMCBestAngleHadj"), method_10404, 0, "adr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_111), Reflex::Literal("setMCBestAngleHadk"), method_10405, 0, "adr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_111), Reflex::Literal("setMCBestAngleHadb"), method_10406, 0, "adr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_111), Reflex::Literal("setMCBestAngleHadbbar"), method_10407, 0, "adr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_74), Reflex::Literal("setMCChangeW1Q"), method_10408, 0, "w1q", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_74), Reflex::Literal("setMCChangeW2Q"), method_10409, 0, "w2q", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_74), Reflex::Literal("setJetParametrisation"), method_10410, 0, "jp", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_111), Reflex::Literal("setProbChi2"), method_10411, 0, "c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_74), Reflex::Literal("setMCBestJetComb"), method_10412, 0, "mcbs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_74), Reflex::Literal("setSimpleBestJetComb"), method_10413, 0, "sbs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_74), Reflex::Literal("setLRBestJetComb"), method_10414, 0, "lrbs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3560), Reflex::Literal("setLRJetCombObservables"), method_10415, 0, "varval", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_111), Reflex::Literal("setLRJetCombLRval"), method_10416, 0, "clr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_111), Reflex::Literal("setLRJetCombProb"), method_10417, 0, "plr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3560), Reflex::Literal("setLRSignalEvtObservables"), method_10418, 0, "varval", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_111), Reflex::Literal("setLRSignalEvtLRval"), method_10419, 0, "clr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_111), Reflex::Literal("setLRSignalEvtProb"), method_10420, 0, "plr", ::Reflex::PUBLIC);
}
//------Stub functions for class TtGenEvent -------------------------------
static  void operator_10426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TtGenEvent*)o)->operator=)(*(const ::TtGenEvent*)arg[0]);
  else   (((::TtGenEvent*)o)->operator=)(*(const ::TtGenEvent*)arg[0]);
}

static void constructor_10427( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtGenEvent(*(const ::TtGenEvent*)arg[0]);
  else ::new(mem) ::TtGenEvent(*(const ::TtGenEvent*)arg[0]);
}

static void constructor_10428( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtGenEvent();
  else ::new(mem) ::TtGenEvent();
}

static void constructor_10429( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtGenEvent(*(::reco::GenParticleRefProd*)arg[0],
      *(::reco::GenParticleRefProd*)arg[1]);
  else ::new(mem) ::TtGenEvent(*(::reco::GenParticleRefProd*)arg[0],
      *(::reco::GenParticleRefProd*)arg[1]);
}

static void destructor_10430(void*, void * o, const std::vector<void*>&, void *) {
(((::TtGenEvent*)o)->::TtGenEvent::~TtGenEvent)();
}
static  void method_10431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TtGenEvent*)o)->isTtBar)());
  else   (((const ::TtGenEvent*)o)->isTtBar)();
}

static  void method_10432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TtGenEvent*)o)->fromGluonFusion)());
  else   (((const ::TtGenEvent*)o)->fromGluonFusion)();
}

static  void method_10433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TtGenEvent*)o)->fromQuarkAnnihilation)());
  else   (((const ::TtGenEvent*)o)->fromQuarkAnnihilation)();
}

static  void method_10434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::TtGenEvent*)o)->isFullHadronic)());
    else     (((const ::TtGenEvent*)o)->isFullHadronic)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::TtGenEvent*)o)->isFullHadronic)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->isFullHadronic)(*(bool*)arg[0]);
  }
}

static  void method_10435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::TtGenEvent*)o)->isSemiLeptonic)());
    else     (((const ::TtGenEvent*)o)->isSemiLeptonic)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::TtGenEvent*)o)->isSemiLeptonic)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->isSemiLeptonic)(*(bool*)arg[0]);
  }
}

static  void method_10436( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::TtGenEvent*)o)->isFullLeptonic)());
    else     (((const ::TtGenEvent*)o)->isFullLeptonic)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::TtGenEvent*)o)->isFullLeptonic)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->isFullLeptonic)(*(bool*)arg[0]);
  }
}

static  void method_10437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtGenEvent*)o)->semiLeptonicChannel)());
  else   (((const ::TtGenEvent*)o)->semiLeptonicChannel)();
}

static  void method_10438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TtGenEvent*)o)->isSemiLeptonic)(*(::WDecay::LeptonType*)arg[0]));
  else   (((const ::TtGenEvent*)o)->isSemiLeptonic)(*(::WDecay::LeptonType*)arg[0]);
}

static  void method_10439( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TtGenEvent*)o)->isSemiLeptonic)(*(::WDecay::LeptonType*)arg[0],
    *(::WDecay::LeptonType*)arg[1]));
  else   (((const ::TtGenEvent*)o)->isSemiLeptonic)(*(::WDecay::LeptonType*)arg[0],
    *(::WDecay::LeptonType*)arg[1]);
}

static  void method_10440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::pair<WDecay::LeptonType,WDecay::LeptonType>)((((const ::TtGenEvent*)o)->fullLeptonicChannel)());
  else   (((const ::TtGenEvent*)o)->fullLeptonicChannel)();
}

static  void method_10441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TtGenEvent*)o)->isFullLeptonic)(*(::WDecay::LeptonType*)arg[0],
    *(::WDecay::LeptonType*)arg[1]));
  else   (((const ::TtGenEvent*)o)->isFullLeptonic)(*(::WDecay::LeptonType*)arg[0],
    *(::WDecay::LeptonType*)arg[1]);
}

static  void method_10442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->singleLepton)());
    else     (((const ::TtGenEvent*)o)->singleLepton)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->singleLepton)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->singleLepton)(*(bool*)arg[0]);
  }
}

static  void method_10443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->singleNeutrino)());
    else     (((const ::TtGenEvent*)o)->singleNeutrino)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->singleNeutrino)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->singleNeutrino)(*(bool*)arg[0]);
  }
}

static  void method_10444( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->leptonicDecayW)());
    else     (((const ::TtGenEvent*)o)->leptonicDecayW)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->leptonicDecayW)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->leptonicDecayW)(*(bool*)arg[0]);
  }
}

static  void method_10445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->leptonicDecayB)());
    else     (((const ::TtGenEvent*)o)->leptonicDecayB)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->leptonicDecayB)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->leptonicDecayB)(*(bool*)arg[0]);
  }
}

static  void method_10446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->leptonicDecayTop)());
    else     (((const ::TtGenEvent*)o)->leptonicDecayTop)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->leptonicDecayTop)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->leptonicDecayTop)(*(bool*)arg[0]);
  }
}

static  void method_10447( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->hadronicDecayW)());
    else     (((const ::TtGenEvent*)o)->hadronicDecayW)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->hadronicDecayW)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->hadronicDecayW)(*(bool*)arg[0]);
  }
}

static  void method_10448( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->hadronicDecayB)());
    else     (((const ::TtGenEvent*)o)->hadronicDecayB)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->hadronicDecayB)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->hadronicDecayB)(*(bool*)arg[0]);
  }
}

static  void method_10449( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->hadronicDecayTop)());
    else     (((const ::TtGenEvent*)o)->hadronicDecayTop)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->hadronicDecayTop)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->hadronicDecayTop)(*(bool*)arg[0]);
  }
}

static  void method_10450( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->hadronicDecayQuark)());
    else     (((const ::TtGenEvent*)o)->hadronicDecayQuark)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->hadronicDecayQuark)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->hadronicDecayQuark)(*(bool*)arg[0]);
  }
}

static  void method_10451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->hadronicDecayQuarkBar)());
  else   (((const ::TtGenEvent*)o)->hadronicDecayQuarkBar)();
}

static  void method_10452( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::GenParticle*>)((((const ::TtGenEvent*)o)->leptonicDecayTopRadiation)());
    else     (((const ::TtGenEvent*)o)->leptonicDecayTopRadiation)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::GenParticle*>)((((const ::TtGenEvent*)o)->leptonicDecayTopRadiation)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->leptonicDecayTopRadiation)(*(bool*)arg[0]);
  }
}

static  void method_10453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::GenParticle*>)((((const ::TtGenEvent*)o)->hadronicDecayTopRadiation)());
    else     (((const ::TtGenEvent*)o)->hadronicDecayTopRadiation)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::GenParticle*>)((((const ::TtGenEvent*)o)->hadronicDecayTopRadiation)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->hadronicDecayTopRadiation)(*(bool*)arg[0]);
  }
}

static  void method_10454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->lepton)());
    else     (((const ::TtGenEvent*)o)->lepton)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->lepton)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->lepton)(*(bool*)arg[0]);
  }
}

static  void method_10455( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->leptonBar)());
    else     (((const ::TtGenEvent*)o)->leptonBar)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->leptonBar)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->leptonBar)(*(bool*)arg[0]);
  }
}

static  void method_10456( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->neutrino)());
    else     (((const ::TtGenEvent*)o)->neutrino)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->neutrino)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->neutrino)(*(bool*)arg[0]);
  }
}

static  void method_10457( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->neutrinoBar)());
    else     (((const ::TtGenEvent*)o)->neutrinoBar)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->neutrinoBar)(*(bool*)arg[0]));
    else     (((const ::TtGenEvent*)o)->neutrinoBar)(*(bool*)arg[0]);
  }
}

static  void method_10458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtGenEvent*)o)->topPair)());
  else   (((const ::TtGenEvent*)o)->topPair)();
}

static void method_newdel_1829( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TtGenEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TtGenEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TtGenEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TtGenEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TtGenEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TopGenEvent")), ::Reflex::BaseOffset< ::TtGenEvent,::TopGenEvent >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TtGenEvent -------------------------------
void __TtGenEvent_db_datamem(Reflex::Class*);
void __TtGenEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TtGenEvent_datamem_bld(&__TtGenEvent_db_datamem);
Reflex::GenreflexMemberBuilder __TtGenEvent_funcmem_bld(&__TtGenEvent_db_funcmem);
void __TtGenEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TtGenEvent"), typeid(::TtGenEvent), sizeof(::TtGenEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddBase(type_2227, ::Reflex::BaseOffset< ::TtGenEvent, ::TopGenEvent >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47447, type_47448), Reflex::Literal("operator="), operator_10426, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_47448), Reflex::Literal("TtGenEvent"), constructor_10427, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TtGenEvent"), constructor_10428, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_47449, type_47449), Reflex::Literal("TtGenEvent"), constructor_10429, 0, "decaySubset;initSubset", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TtGenEvent"), destructor_10430, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1829, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TtGenEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TtGenEvent_funcmem_bld);
}

//------Delayed data member builder for class TtGenEvent -------------------
void __TtGenEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9875, Reflex::Literal("topPair_"), OffsetOf(__shadow__::__TtGenEvent, topPair_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TtGenEvent -------------------
void __TtGenEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isTtBar"), method_10431, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("fromGluonFusion"), method_10432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("fromQuarkAnnihilation"), method_10433, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_1798), Reflex::Literal("isFullHadronic"), method_10434, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_1798), Reflex::Literal("isSemiLeptonic"), method_10435, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_1798), Reflex::Literal("isFullLeptonic"), method_10436, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10621), Reflex::Literal("semiLeptonicChannel"), method_10437, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_10621), Reflex::Literal("isSemiLeptonic"), method_10438, 0, "typeA", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_10621, type_10621), Reflex::Literal("isSemiLeptonic"), method_10439, 0, "typeA;typeB", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3462), Reflex::Literal("fullLeptonicChannel"), method_10440, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_10621, type_10621), Reflex::Literal("isFullLeptonic"), method_10441, 0, "typeA;typeB", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("singleLepton"), method_10442, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("singleNeutrino"), method_10443, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("leptonicDecayW"), method_10444, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("leptonicDecayB"), method_10445, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("leptonicDecayTop"), method_10446, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("hadronicDecayW"), method_10447, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("hadronicDecayB"), method_10448, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("hadronicDecayTop"), method_10449, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("hadronicDecayQuark"), method_10450, 0, "invertFlavor=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("hadronicDecayQuarkBar"), method_10451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3634, type_1798), Reflex::Literal("leptonicDecayTopRadiation"), method_10452, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3634, type_1798), Reflex::Literal("hadronicDecayTopRadiation"), method_10453, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("lepton"), method_10454, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("leptonBar"), method_10455, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("neutrino"), method_10456, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("neutrinoBar"), method_10457, 0, "excludeTauLeptons=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47450), Reflex::Literal("topPair"), method_10458, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TtDilepEvtSolution -------------------------------
static  void operator_11112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TtDilepEvtSolution*)o)->operator=)(*(const ::TtDilepEvtSolution*)arg[0]);
  else   (((::TtDilepEvtSolution*)o)->operator=)(*(const ::TtDilepEvtSolution*)arg[0]);
}

static void constructor_11113( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtDilepEvtSolution(*(const ::TtDilepEvtSolution*)arg[0]);
  else ::new(mem) ::TtDilepEvtSolution(*(const ::TtDilepEvtSolution*)arg[0]);
}

static void constructor_11114( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtDilepEvtSolution();
  else ::new(mem) ::TtDilepEvtSolution();
}

static void destructor_11115(void*, void * o, const std::vector<void*>&, void *) {
(((::TtDilepEvtSolution*)o)->::TtDilepEvtSolution::~TtDilepEvtSolution)();
}
static  void method_11116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtDilepEvtSolution*)o)->getJetB)());
  else   (((const ::TtDilepEvtSolution*)o)->getJetB)();
}

static  void method_11117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtDilepEvtSolution*)o)->getJetBbar)());
  else   (((const ::TtDilepEvtSolution*)o)->getJetBbar)();
}

static  void method_11118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Electron)((((const ::TtDilepEvtSolution*)o)->getElectronp)());
  else   (((const ::TtDilepEvtSolution*)o)->getElectronp)();
}

static  void method_11119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Electron)((((const ::TtDilepEvtSolution*)o)->getElectronm)());
  else   (((const ::TtDilepEvtSolution*)o)->getElectronm)();
}

static  void method_11120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Muon)((((const ::TtDilepEvtSolution*)o)->getMuonp)());
  else   (((const ::TtDilepEvtSolution*)o)->getMuonp)();
}

static  void method_11121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Muon)((((const ::TtDilepEvtSolution*)o)->getMuonm)());
  else   (((const ::TtDilepEvtSolution*)o)->getMuonm)();
}

static  void method_11122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Tau)((((const ::TtDilepEvtSolution*)o)->getTaup)());
  else   (((const ::TtDilepEvtSolution*)o)->getTaup)();
}

static  void method_11123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Tau)((((const ::TtDilepEvtSolution*)o)->getTaum)());
  else   (((const ::TtDilepEvtSolution*)o)->getTaum)();
}

static  void method_11124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::MET)((((const ::TtDilepEvtSolution*)o)->getMET)());
  else   (((const ::TtDilepEvtSolution*)o)->getMET)();
}

static  void method_11125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::TtDilepEvtSolution*)o)->getGenEvent)();
  else   (((const ::TtDilepEvtSolution*)o)->getGenEvent)();
}

static  void method_11126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtDilepEvtSolution*)o)->getGenT)());
  else   (((const ::TtDilepEvtSolution*)o)->getGenT)();
}

static  void method_11127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtDilepEvtSolution*)o)->getGenWp)());
  else   (((const ::TtDilepEvtSolution*)o)->getGenWp)();
}

static  void method_11128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtDilepEvtSolution*)o)->getGenB)());
  else   (((const ::TtDilepEvtSolution*)o)->getGenB)();
}

static  void method_11129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtDilepEvtSolution*)o)->getGenLepp)());
  else   (((const ::TtDilepEvtSolution*)o)->getGenLepp)();
}

static  void method_11130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtDilepEvtSolution*)o)->getGenN)());
  else   (((const ::TtDilepEvtSolution*)o)->getGenN)();
}

static  void method_11131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtDilepEvtSolution*)o)->getGenTbar)());
  else   (((const ::TtDilepEvtSolution*)o)->getGenTbar)();
}

static  void method_11132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtDilepEvtSolution*)o)->getGenWm)());
  else   (((const ::TtDilepEvtSolution*)o)->getGenWm)();
}

static  void method_11133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtDilepEvtSolution*)o)->getGenBbar)());
  else   (((const ::TtDilepEvtSolution*)o)->getGenBbar)();
}

static  void method_11134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtDilepEvtSolution*)o)->getGenLepm)());
  else   (((const ::TtDilepEvtSolution*)o)->getGenLepm)();
}

static  void method_11135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtDilepEvtSolution*)o)->getGenNbar)());
  else   (((const ::TtDilepEvtSolution*)o)->getGenNbar)();
}

static  void method_11136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtDilepEvtSolution*)o)->getRecJetB)());
  else   (((const ::TtDilepEvtSolution*)o)->getRecJetB)();
}

static  void method_11137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtDilepEvtSolution*)o)->getCalJetB)());
  else   (((const ::TtDilepEvtSolution*)o)->getCalJetB)();
}

static  void method_11138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtDilepEvtSolution*)o)->getRecJetBbar)());
  else   (((const ::TtDilepEvtSolution*)o)->getRecJetBbar)();
}

static  void method_11139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (pat::Jet)((((const ::TtDilepEvtSolution*)o)->getCalJetBbar)());
  else   (((const ::TtDilepEvtSolution*)o)->getCalJetBbar)();
}

static  void method_11140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TtDilepEvtSolution*)o)->getWpDecay)());
  else   (((const ::TtDilepEvtSolution*)o)->getWpDecay)();
}

static  void method_11141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TtDilepEvtSolution*)o)->getWmDecay)());
  else   (((const ::TtDilepEvtSolution*)o)->getWmDecay)();
}

static  void method_11142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtDilepEvtSolution*)o)->getJetResidual)());
  else   (((const ::TtDilepEvtSolution*)o)->getJetResidual)();
}

static  void method_11143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtDilepEvtSolution*)o)->getLeptonResidual)());
  else   (((const ::TtDilepEvtSolution*)o)->getLeptonResidual)();
}

static  void method_11144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtDilepEvtSolution*)o)->getFullResidual)());
  else   (((const ::TtDilepEvtSolution*)o)->getFullResidual)();
}

static  void method_11145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TtDilepEvtSolution*)o)->getBestSol)());
  else   (((const ::TtDilepEvtSolution*)o)->getBestSol)();
}

static  void method_11146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtDilepEvtSolution*)o)->getRecTopMass)());
  else   (((const ::TtDilepEvtSolution*)o)->getRecTopMass)();
}

static  void method_11147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtDilepEvtSolution*)o)->getRecWeightMax)());
  else   (((const ::TtDilepEvtSolution*)o)->getRecWeightMax)();
}

static  void method_11148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtDilepEvtSolution*)o)->getLeptPos)());
  else   (((const ::TtDilepEvtSolution*)o)->getLeptPos)();
}

static  void method_11149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::Particle)((((const ::TtDilepEvtSolution*)o)->getLeptNeg)());
  else   (((const ::TtDilepEvtSolution*)o)->getLeptNeg)();
}

static  void method_11150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtDilepEvtSolution*)o)->getLRSignalEvtObsVal)(*(unsigned int*)arg[0]));
  else   (((const ::TtDilepEvtSolution*)o)->getLRSignalEvtObsVal)(*(unsigned int*)arg[0]);
}

static  void method_11151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtDilepEvtSolution*)o)->getLRSignalEvtLRval)());
  else   (((const ::TtDilepEvtSolution*)o)->getLRSignalEvtLRval)();
}

static  void method_11152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::TtDilepEvtSolution*)o)->getLRSignalEvtProb)());
  else   (((const ::TtDilepEvtSolution*)o)->getLRSignalEvtProb)();
}

static void method_newdel_2053( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TtDilepEvtSolution >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TtDilepEvtSolution >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TtDilepEvtSolution >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TtDilepEvtSolution >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TtDilepEvtSolution >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TtDilepEvtSolution -------------------------------
void __TtDilepEvtSolution_db_datamem(Reflex::Class*);
void __TtDilepEvtSolution_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TtDilepEvtSolution_datamem_bld(&__TtDilepEvtSolution_db_datamem);
Reflex::GenreflexMemberBuilder __TtDilepEvtSolution_funcmem_bld(&__TtDilepEvtSolution_db_funcmem);
void __TtDilepEvtSolution_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TtDilepEvtSolution"), typeid(::TtDilepEvtSolution), sizeof(::TtDilepEvtSolution), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20752, type_20754), Reflex::Literal("operator="), operator_11112, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20754), Reflex::Literal("TtDilepEvtSolution"), constructor_11113, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TtDilepEvtSolution"), constructor_11114, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TtDilepEvtSolution"), destructor_11115, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2053, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TtDilepEvtSolution_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TtDilepEvtSolution_funcmem_bld);
}

//------Delayed data member builder for class TtDilepEvtSolution -------------------
void __TtDilepEvtSolution_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6625, Reflex::Literal("theGenEvt_"), OffsetOf(__shadow__::__TtDilepEvtSolution, theGenEvt_), ::Reflex::PRIVATE)
  .AddDataMember(type_6747, Reflex::Literal("elecp_"), OffsetOf(__shadow__::__TtDilepEvtSolution, elecp_), ::Reflex::PRIVATE)
  .AddDataMember(type_6747, Reflex::Literal("elecm_"), OffsetOf(__shadow__::__TtDilepEvtSolution, elecm_), ::Reflex::PRIVATE)
  .AddDataMember(type_6749, Reflex::Literal("muonp_"), OffsetOf(__shadow__::__TtDilepEvtSolution, muonp_), ::Reflex::PRIVATE)
  .AddDataMember(type_6749, Reflex::Literal("muonm_"), OffsetOf(__shadow__::__TtDilepEvtSolution, muonm_), ::Reflex::PRIVATE)
  .AddDataMember(type_6748, Reflex::Literal("taup_"), OffsetOf(__shadow__::__TtDilepEvtSolution, taup_), ::Reflex::PRIVATE)
  .AddDataMember(type_6748, Reflex::Literal("taum_"), OffsetOf(__shadow__::__TtDilepEvtSolution, taum_), ::Reflex::PRIVATE)
  .AddDataMember(type_6745, Reflex::Literal("jetB_"), OffsetOf(__shadow__::__TtDilepEvtSolution, jetB_), ::Reflex::PRIVATE)
  .AddDataMember(type_6745, Reflex::Literal("jetBbar_"), OffsetOf(__shadow__::__TtDilepEvtSolution, jetBbar_), ::Reflex::PRIVATE)
  .AddDataMember(type_6746, Reflex::Literal("met_"), OffsetOf(__shadow__::__TtDilepEvtSolution, met_), ::Reflex::PRIVATE)
  .AddDataMember(type_74, Reflex::Literal("jetCorrScheme_"), OffsetOf(__shadow__::__TtDilepEvtSolution, jetCorrScheme_), ::Reflex::PRIVATE)
  .AddDataMember(type_2978, Reflex::Literal("wpDecay_"), OffsetOf(__shadow__::__TtDilepEvtSolution, wpDecay_), ::Reflex::PRIVATE)
  .AddDataMember(type_2978, Reflex::Literal("wmDecay_"), OffsetOf(__shadow__::__TtDilepEvtSolution, wmDecay_), ::Reflex::PRIVATE)
  .AddDataMember(type_1798, Reflex::Literal("bestSol_"), OffsetOf(__shadow__::__TtDilepEvtSolution, bestSol_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("topmass_"), OffsetOf(__shadow__::__TtDilepEvtSolution, topmass_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("weightmax_"), OffsetOf(__shadow__::__TtDilepEvtSolution, weightmax_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("lrSignalEvtLRval_"), OffsetOf(__shadow__::__TtDilepEvtSolution, lrSignalEvtLRval_), ::Reflex::PRIVATE)
  .AddDataMember(type_111, Reflex::Literal("lrSignalEvtProb_"), OffsetOf(__shadow__::__TtDilepEvtSolution, lrSignalEvtProb_), ::Reflex::PRIVATE)
  .AddDataMember(type_3560, Reflex::Literal("lrSignalEvtVarVal_"), OffsetOf(__shadow__::__TtDilepEvtSolution, lrSignalEvtVarVal_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TtDilepEvtSolution -------------------
void __TtDilepEvtSolution_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getJetB"), method_11116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getJetBbar"), method_11117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12981), Reflex::Literal("getElectronp"), method_11118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12981), Reflex::Literal("getElectronm"), method_11119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12913), Reflex::Literal("getMuonp"), method_11120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12913), Reflex::Literal("getMuonm"), method_11121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12983), Reflex::Literal("getTaup"), method_11122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12983), Reflex::Literal("getTaum"), method_11123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12916), Reflex::Literal("getMET"), method_11124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46181), Reflex::Literal("getGenEvent"), method_11125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenT"), method_11126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenWp"), method_11127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenB"), method_11128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenLepp"), method_11129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenN"), method_11130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenTbar"), method_11131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenWm"), method_11132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenBbar"), method_11133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenLepm"), method_11134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("getGenNbar"), method_11135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecJetB"), method_11136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getCalJetB"), method_11137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getRecJetBbar"), method_11138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12929), Reflex::Literal("getCalJetBbar"), method_11139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2978), Reflex::Literal("getWpDecay"), method_11140, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2978), Reflex::Literal("getWmDecay"), method_11141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getJetResidual"), method_11142, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getLeptonResidual"), method_11143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getFullResidual"), method_11144, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("getBestSol"), method_11145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getRecTopMass"), method_11146, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getRecWeightMax"), method_11147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getLeptPos"), method_11148, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11523), Reflex::Literal("getLeptNeg"), method_11149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_398), Reflex::Literal("getLRSignalEvtObsVal"), method_11150, 0, "", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getLRSignalEvtLRval"), method_11151, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111), Reflex::Literal("getLRSignalEvtProb"), method_11152, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TopGenEvent -------------------------------
static  void operator_11726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TopGenEvent*)o)->operator=)(*(const ::TopGenEvent*)arg[0]);
  else   (((::TopGenEvent*)o)->operator=)(*(const ::TopGenEvent*)arg[0]);
}

static void constructor_11727( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TopGenEvent(*(const ::TopGenEvent*)arg[0]);
  else ::new(mem) ::TopGenEvent(*(const ::TopGenEvent*)arg[0]);
}

static void constructor_11728( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TopGenEvent();
  else ::new(mem) ::TopGenEvent();
}

static void constructor_11729( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TopGenEvent(*(::reco::GenParticleRefProd*)arg[0],
      *(::reco::GenParticleRefProd*)arg[1]);
  else ::new(mem) ::TopGenEvent(*(::reco::GenParticleRefProd*)arg[0],
      *(::reco::GenParticleRefProd*)arg[1]);
}

static void destructor_11730(void*, void * o, const std::vector<void*>&, void *) {
(((::TopGenEvent*)o)->::TopGenEvent::~TopGenEvent)();
}
static  void method_11731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::TopGenEvent*)o)->particles)();
  else   (((const ::TopGenEvent*)o)->particles)();
}

static  void method_11732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::TopGenEvent*)o)->initialPartons)();
  else   (((const ::TopGenEvent*)o)->initialPartons)();
}

static  void method_11733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<const reco::GenParticle*>)((((const ::TopGenEvent*)o)->radiatedGluons)(*(int*)arg[0]));
  else   (((const ::TopGenEvent*)o)->radiatedGluons)(*(int*)arg[0]);
}

static  void method_11734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::GenParticle*>)((((const ::TopGenEvent*)o)->lightQuarks)());
    else     (((const ::TopGenEvent*)o)->lightQuarks)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::GenParticle*>)((((const ::TopGenEvent*)o)->lightQuarks)(*(bool*)arg[0]));
    else     (((const ::TopGenEvent*)o)->lightQuarks)(*(bool*)arg[0]);
  }
}

static  void method_11735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (int)((((const ::TopGenEvent*)o)->numberOfLeptons)());
    else     (((const ::TopGenEvent*)o)->numberOfLeptons)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (int)((((const ::TopGenEvent*)o)->numberOfLeptons)(*(bool*)arg[0]));
    else     (((const ::TopGenEvent*)o)->numberOfLeptons)(*(bool*)arg[0]);
  }
}

static  void method_11736( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (int)((((const ::TopGenEvent*)o)->numberOfLeptons)(*(::WDecay::LeptonType*)arg[0]));
    else     (((const ::TopGenEvent*)o)->numberOfLeptons)(*(::WDecay::LeptonType*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (int)((((const ::TopGenEvent*)o)->numberOfLeptons)(*(::WDecay::LeptonType*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::TopGenEvent*)o)->numberOfLeptons)(*(::WDecay::LeptonType*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_11737( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (int)((((const ::TopGenEvent*)o)->numberOfBQuarks)());
    else     (((const ::TopGenEvent*)o)->numberOfBQuarks)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (int)((((const ::TopGenEvent*)o)->numberOfBQuarks)(*(bool*)arg[0]));
    else     (((const ::TopGenEvent*)o)->numberOfBQuarks)(*(bool*)arg[0]);
  }
}

static  void method_11738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<const reco::GenParticle*>)((((const ::TopGenEvent*)o)->topSisters)());
  else   (((const ::TopGenEvent*)o)->topSisters)();
}

static  void method_11739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->daughterQuarkOfTop)());
    else     (((const ::TopGenEvent*)o)->daughterQuarkOfTop)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->daughterQuarkOfTop)(*(bool*)arg[0]));
    else     (((const ::TopGenEvent*)o)->daughterQuarkOfTop)(*(bool*)arg[0]);
  }
}

static  void method_11740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->daughterQuarkOfTopBar)());
  else   (((const ::TopGenEvent*)o)->daughterQuarkOfTopBar)();
}

static  void method_11741( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->daughterQuarkOfWPlus)());
    else     (((const ::TopGenEvent*)o)->daughterQuarkOfWPlus)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->daughterQuarkOfWPlus)(*(bool*)arg[0]));
    else     (((const ::TopGenEvent*)o)->daughterQuarkOfWPlus)(*(bool*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->daughterQuarkOfWPlus)(*(bool*)arg[0],
      *(bool*)arg[1]));
    else     (((const ::TopGenEvent*)o)->daughterQuarkOfWPlus)(*(bool*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_11742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->daughterQuarkOfWMinus)());
  else   (((const ::TopGenEvent*)o)->daughterQuarkOfWMinus)();
}

static  void method_11743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->daughterQuarkBarOfWPlus)());
  else   (((const ::TopGenEvent*)o)->daughterQuarkBarOfWPlus)();
}

static  void method_11744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->daughterQuarkBarOfWMinus)());
  else   (((const ::TopGenEvent*)o)->daughterQuarkBarOfWMinus)();
}

static  void method_11745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->candidate)(*(int*)arg[0]));
    else     (((const ::TopGenEvent*)o)->candidate)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->candidate)(*(int*)arg[0],
      *(unsigned int*)arg[1]));
    else     (((const ::TopGenEvent*)o)->candidate)(*(int*)arg[0],
      *(unsigned int*)arg[1]);
  }
}

static  void method_11746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->eMinus)());
  else   (((const ::TopGenEvent*)o)->eMinus)();
}

static  void method_11747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->ePlus)());
  else   (((const ::TopGenEvent*)o)->ePlus)();
}

static  void method_11748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->muMinus)());
  else   (((const ::TopGenEvent*)o)->muMinus)();
}

static  void method_11749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->muPlus)());
  else   (((const ::TopGenEvent*)o)->muPlus)();
}

static  void method_11750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->tauMinus)());
  else   (((const ::TopGenEvent*)o)->tauMinus)();
}

static  void method_11751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->tauPlus)());
  else   (((const ::TopGenEvent*)o)->tauPlus)();
}

static  void method_11752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->wMinus)());
  else   (((const ::TopGenEvent*)o)->wMinus)();
}

static  void method_11753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->wPlus)());
  else   (((const ::TopGenEvent*)o)->wPlus)();
}

static  void method_11754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->b)());
  else   (((const ::TopGenEvent*)o)->b)();
}

static  void method_11755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->bBar)());
  else   (((const ::TopGenEvent*)o)->bBar)();
}

static  void method_11756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->top)());
  else   (((const ::TopGenEvent*)o)->top)();
}

static  void method_11757( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TopGenEvent*)o)->topBar)());
  else   (((const ::TopGenEvent*)o)->topBar)();
}

static  void method_11758( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::TopGenEvent*)o)->print)();
}

static void method_newdel_2227( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TopGenEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TopGenEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TopGenEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TopGenEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TopGenEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TopGenEvent -------------------------------
void __TopGenEvent_db_datamem(Reflex::Class*);
void __TopGenEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TopGenEvent_datamem_bld(&__TopGenEvent_db_datamem);
Reflex::GenreflexMemberBuilder __TopGenEvent_funcmem_bld(&__TopGenEvent_db_funcmem);
void __TopGenEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TopGenEvent"), typeid(::TopGenEvent), sizeof(::TopGenEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50116, type_50117), Reflex::Literal("operator="), operator_11726, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_50117), Reflex::Literal("TopGenEvent"), constructor_11727, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TopGenEvent"), constructor_11728, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_47449, type_47449), Reflex::Literal("TopGenEvent"), constructor_11729, 0, "decaySubset;iniSubset", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TopGenEvent"), destructor_11730, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2227, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TopGenEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TopGenEvent_funcmem_bld);
}

//------Delayed data member builder for class TopGenEvent -------------------
void __TopGenEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11367, Reflex::Literal("parts_"), OffsetOf(__shadow__::__TopGenEvent, parts_), ::Reflex::PROTECTED)
  .AddDataMember(type_11367, Reflex::Literal("initPartons_"), OffsetOf(__shadow__::__TopGenEvent, initPartons_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TopGenEvent -------------------
void __TopGenEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50118), Reflex::Literal("particles"), method_11731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50118), Reflex::Literal("initialPartons"), method_11732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3634, type_74), Reflex::Literal("radiatedGluons"), method_11733, 0, "pdgId", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3634, type_1798), Reflex::Literal("lightQuarks"), method_11734, 0, "includingBQuarks=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74, type_1798), Reflex::Literal("numberOfLeptons"), method_11735, 0, "fromWBoson=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74, type_10621, type_1798), Reflex::Literal("numberOfLeptons"), method_11736, 0, "type;fromWBoson=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74, type_1798), Reflex::Literal("numberOfBQuarks"), method_11737, 0, "fromTopQuark=true", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3634), Reflex::Literal("topSisters"), method_11738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798), Reflex::Literal("daughterQuarkOfTop"), method_11739, 0, "invertCharge=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("daughterQuarkOfTopBar"), method_11740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_1798, type_1798), Reflex::Literal("daughterQuarkOfWPlus"), method_11741, 0, "invertQuarkCharge=false;invertBosonCharge=false", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("daughterQuarkOfWMinus"), method_11742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("daughterQuarkBarOfWPlus"), method_11743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("daughterQuarkBarOfWMinus"), method_11744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103, type_74, type_398), Reflex::Literal("candidate"), method_11745, 0, "id;parentId=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("eMinus"), method_11746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("ePlus"), method_11747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("muMinus"), method_11748, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("muPlus"), method_11749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("tauMinus"), method_11750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("tauPlus"), method_11751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("wMinus"), method_11752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("wPlus"), method_11753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("b"), method_11754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("bBar"), method_11755, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("top"), method_11756, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("topBar"), method_11757, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("print"), method_11758, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class StGenEvent -------------------------------
static  void operator_12797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::StGenEvent*)o)->operator=)(*(const ::StGenEvent*)arg[0]);
  else   (((::StGenEvent*)o)->operator=)(*(const ::StGenEvent*)arg[0]);
}

static void constructor_12798( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::StGenEvent(*(const ::StGenEvent*)arg[0]);
  else ::new(mem) ::StGenEvent(*(const ::StGenEvent*)arg[0]);
}

static void constructor_12799( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::StGenEvent();
  else ::new(mem) ::StGenEvent();
}

static void constructor_12800( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::StGenEvent(*(::reco::GenParticleRefProd*)arg[0],
      *(::reco::GenParticleRefProd*)arg[1]);
  else ::new(mem) ::StGenEvent(*(::reco::GenParticleRefProd*)arg[0],
      *(::reco::GenParticleRefProd*)arg[1]);
}

static void destructor_12801(void*, void * o, const std::vector<void*>&, void *) {
(((::StGenEvent*)o)->::StGenEvent::~StGenEvent)();
}
static  void method_12802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::StGenEvent*)o)->singleLepton)());
  else   (((const ::StGenEvent*)o)->singleLepton)();
}

static  void method_12803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::StGenEvent*)o)->singleNeutrino)());
  else   (((const ::StGenEvent*)o)->singleNeutrino)();
}

static  void method_12804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::StGenEvent*)o)->singleW)());
  else   (((const ::StGenEvent*)o)->singleW)();
}

static  void method_12805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::StGenEvent*)o)->singleTop)());
  else   (((const ::StGenEvent*)o)->singleTop)();
}

static  void method_12806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::StGenEvent*)o)->decayB)());
  else   (((const ::StGenEvent*)o)->decayB)();
}

static  void method_12807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::StGenEvent*)o)->associatedB)());
  else   (((const ::StGenEvent*)o)->associatedB)();
}

static void method_newdel_2546( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::StGenEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::StGenEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::StGenEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::StGenEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::StGenEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TopGenEvent")), ::Reflex::BaseOffset< ::StGenEvent,::TopGenEvent >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class StGenEvent -------------------------------
void __StGenEvent_db_datamem(Reflex::Class*);
void __StGenEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __StGenEvent_datamem_bld(&__StGenEvent_db_datamem);
Reflex::GenreflexMemberBuilder __StGenEvent_funcmem_bld(&__StGenEvent_db_funcmem);
void __StGenEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("StGenEvent"), typeid(::StGenEvent), sizeof(::StGenEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_2227, ::Reflex::BaseOffset< ::StGenEvent, ::TopGenEvent >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55765, type_55766), Reflex::Literal("operator="), operator_12797, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_55766), Reflex::Literal("StGenEvent"), constructor_12798, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("StGenEvent"), constructor_12799, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_47449, type_47449), Reflex::Literal("StGenEvent"), constructor_12800, 0, ";", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~StGenEvent"), destructor_12801, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2546, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__StGenEvent_funcmem_bld);
}

//------Delayed data member builder for class StGenEvent -------------------
void __StGenEvent_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class StGenEvent -------------------
void __StGenEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("singleLepton"), method_12802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("singleNeutrino"), method_12803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("singleW"), method_12804, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("singleTop"), method_12805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("decayB"), method_12806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("associatedB"), method_12807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TtEvent -------------------------------
static  void operator_13155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TtEvent*)o)->operator=)(*(const ::TtEvent*)arg[0]);
  else   (((::TtEvent*)o)->operator=)(*(const ::TtEvent*)arg[0]);
}

static void constructor_13156( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtEvent(*(const ::TtEvent*)arg[0]);
  else ::new(mem) ::TtEvent(*(const ::TtEvent*)arg[0]);
}

static void constructor_13158( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtEvent();
  else ::new(mem) ::TtEvent();
}

static void destructor_13159(void*, void * o, const std::vector<void*>&, void *) {
(((::TtEvent*)o)->::TtEvent::~TtEvent)();
}
static  void method_13160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::pair<WDecay::LeptonType,WDecay::LeptonType>)((((const ::TtEvent*)o)->lepDecays)());
  else   (((const ::TtEvent*)o)->lepDecays)();
}

static  void method_13161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((const ::TtEvent*)o)->eventHypo)(*(const ::TtEvent::HypoClassKey*)arg[0]);
    else     (((const ::TtEvent*)o)->eventHypo)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((const ::TtEvent*)o)->eventHypo)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
    else     (((const ::TtEvent*)o)->eventHypo)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::TtEvent*)o)->genEvent)();
  else   (((const ::TtEvent*)o)->genEvent)();
}

static  void method_13163( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TtEvent*)o)->isHypoClassAvailable)(*(const ::std::string*)arg[0]));
  else   (((const ::TtEvent*)o)->isHypoClassAvailable)(*(const ::std::string*)arg[0]);
}

static  void method_13164( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TtEvent*)o)->isHypoClassAvailable)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::TtEvent*)o)->isHypoClassAvailable)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_13165( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::TtEvent*)o)->isHypoAvailable)(*(const ::std::string*)arg[0]));
    else     (((const ::TtEvent*)o)->isHypoAvailable)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::TtEvent*)o)->isHypoAvailable)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtEvent*)o)->isHypoAvailable)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::TtEvent*)o)->isHypoAvailable)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtEvent*)o)->isHypoAvailable)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::TtEvent*)o)->isHypoAvailable)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtEvent*)o)->isHypoAvailable)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::TtEvent*)o)->isHypoValid)(*(const ::std::string*)arg[0]));
    else     (((const ::TtEvent*)o)->isHypoValid)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::TtEvent*)o)->isHypoValid)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtEvent*)o)->isHypoValid)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (bool)((((const ::TtEvent*)o)->isHypoValid)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtEvent*)o)->isHypoValid)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::TtEvent*)o)->isHypoValid)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtEvent*)o)->isHypoValid)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::TtEvent*)o)->numberOfAvailableHypoClasses)());
  else   (((const ::TtEvent*)o)->numberOfAvailableHypoClasses)();
}

static  void method_13170( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::TtEvent*)o)->numberOfAvailableHypos)(*(const ::std::string*)arg[0]));
  else   (((const ::TtEvent*)o)->numberOfAvailableHypos)(*(const ::std::string*)arg[0]);
}

static  void method_13171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::TtEvent*)o)->numberOfAvailableHypos)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::TtEvent*)o)->numberOfAvailableHypos)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_13172( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtEvent*)o)->numberOfConsideredJets)(*(const ::std::string*)arg[0]));
  else   (((const ::TtEvent*)o)->numberOfConsideredJets)(*(const ::std::string*)arg[0]);
}

static  void method_13173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtEvent*)o)->numberOfConsideredJets)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::TtEvent*)o)->numberOfConsideredJets)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_13174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<int>)((((const ::TtEvent*)o)->jetLeptonCombination)(*(const ::std::string*)arg[0]));
    else     (((const ::TtEvent*)o)->jetLeptonCombination)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<int>)((((const ::TtEvent*)o)->jetLeptonCombination)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtEvent*)o)->jetLeptonCombination)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13175( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<int>)((((const ::TtEvent*)o)->jetLeptonCombination)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtEvent*)o)->jetLeptonCombination)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<int>)((((const ::TtEvent*)o)->jetLeptonCombination)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtEvent*)o)->jetLeptonCombination)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->genMatchSumPt)());
    else     (((const ::TtEvent*)o)->genMatchSumPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->genMatchSumPt)(*(const unsigned int*)arg[0]));
    else     (((const ::TtEvent*)o)->genMatchSumPt)(*(const unsigned int*)arg[0]);
  }
}

static  void method_13177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->genMatchSumDR)());
    else     (((const ::TtEvent*)o)->genMatchSumDR)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->genMatchSumDR)(*(const unsigned int*)arg[0]));
    else     (((const ::TtEvent*)o)->genMatchSumDR)(*(const unsigned int*)arg[0]);
  }
}

static  void method_13178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::TtEvent*)o)->mvaMethod)());
  else   (((const ::TtEvent*)o)->mvaMethod)();
}

static  void method_13179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->mvaDisc)());
    else     (((const ::TtEvent*)o)->mvaDisc)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->mvaDisc)(*(const unsigned int*)arg[0]));
    else     (((const ::TtEvent*)o)->mvaDisc)(*(const unsigned int*)arg[0]);
  }
}

static  void method_13180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->fitChi2)());
    else     (((const ::TtEvent*)o)->fitChi2)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->fitChi2)(*(const unsigned int*)arg[0]));
    else     (((const ::TtEvent*)o)->fitChi2)(*(const unsigned int*)arg[0]);
  }
}

static  void method_13181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->hitFitChi2)());
    else     (((const ::TtEvent*)o)->hitFitChi2)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->hitFitChi2)(*(const unsigned int*)arg[0]));
    else     (((const ::TtEvent*)o)->hitFitChi2)(*(const unsigned int*)arg[0]);
  }
}

static  void method_13182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->fitProb)());
    else     (((const ::TtEvent*)o)->fitProb)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->fitProb)(*(const unsigned int*)arg[0]));
    else     (((const ::TtEvent*)o)->fitProb)(*(const unsigned int*)arg[0]);
  }
}

static  void method_13183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->hitFitProb)());
    else     (((const ::TtEvent*)o)->hitFitProb)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->hitFitProb)(*(const unsigned int*)arg[0]));
    else     (((const ::TtEvent*)o)->hitFitProb)(*(const unsigned int*)arg[0]);
  }
}

static  void method_13184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->hitFitMT)());
    else     (((const ::TtEvent*)o)->hitFitMT)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->hitFitMT)(*(const unsigned int*)arg[0]));
    else     (((const ::TtEvent*)o)->hitFitMT)(*(const unsigned int*)arg[0]);
  }
}

static  void method_13185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->hitFitSigMT)());
    else     (((const ::TtEvent*)o)->hitFitSigMT)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::TtEvent*)o)->hitFitSigMT)(*(const unsigned int*)arg[0]));
    else     (((const ::TtEvent*)o)->hitFitSigMT)(*(const unsigned int*)arg[0]);
  }
}

static  void method_13186( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtEvent*)o)->correspondingHypo)(*(const ::std::string*)arg[0],
    *(const unsigned int*)arg[1],
    *(const ::std::string*)arg[2]));
  else   (((const ::TtEvent*)o)->correspondingHypo)(*(const ::std::string*)arg[0],
    *(const unsigned int*)arg[1],
    *(const ::std::string*)arg[2]);
}

static  void method_13187( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TtEvent*)o)->correspondingHypo)(*(const ::TtEvent::HypoClassKey*)arg[0],
    *(const unsigned int*)arg[1],
    *(const ::TtEvent::HypoClassKey*)arg[2]));
  else   (((const ::TtEvent*)o)->correspondingHypo)(*(const ::TtEvent::HypoClassKey*)arg[0],
    *(const unsigned int*)arg[1],
    *(const ::TtEvent::HypoClassKey*)arg[2]);
}

static  void method_13188( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtEvent*)o)->topPair)(*(const ::std::string*)arg[0]));
    else     (((const ::TtEvent*)o)->topPair)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtEvent*)o)->topPair)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtEvent*)o)->topPair)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtEvent*)o)->topPair)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtEvent*)o)->topPair)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtEvent*)o)->topPair)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtEvent*)o)->topPair)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtEvent*)o)->topPair)());
  else   (((const ::TtEvent*)o)->topPair)();
}

static  void method_13191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::TtEvent*)o)->printParticle)(*(::edm::LogInfo*)arg[0],
    (const char*)arg[1],
    (const ::reco::Candidate*)arg[2]);
}

static  void method_13192( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setLepDecays)(*(const ::WDecay::LeptonType*)arg[0],
    *(const ::WDecay::LeptonType*)arg[1]);
}

static  void method_13193( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setGenEvent)(*(const ::edm::Handle<TtGenEvent>*)arg[0]);
}

static  void method_13194( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->addEventHypo)(*(const ::TtEvent::HypoClassKey*)arg[0],
    *(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[1]);
}

static  void method_13195( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setNumberOfConsideredJets)(*(const ::TtEvent::HypoClassKey*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_13196( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setGenMatchSumPt)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_13197( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setGenMatchSumDR)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_13198( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setMvaMethod)(*(const ::std::string*)arg[0]);
}

static  void method_13199( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setMvaDiscriminators)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_13200( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setFitChi2)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_13201( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setHitFitChi2)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_13202( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setFitProb)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_13203( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setHitFitProb)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_13204( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setHitFitMT)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_13205( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtEvent*)o)->setHitFitSigMT)(*(const ::std::vector<double>*)arg[0]);
}

static void method_newdel_2674( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TtEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TtEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TtEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TtEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TtEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TtEvent -------------------------------
void __TtEvent_db_datamem(Reflex::Class*);
void __TtEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TtEvent_datamem_bld(&__TtEvent_db_datamem);
Reflex::GenreflexMemberBuilder __TtEvent_funcmem_bld(&__TtEvent_db_funcmem);
void __TtEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TtEvent"), typeid(::TtEvent), sizeof(::TtEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddEnum(Reflex::Literal("TtEvent::HypoClassKey"), Reflex::Literal("kGeom=0;kWMassMaxSumPt=1;kMaxSumPtWMass=2;kGenMatch=3;kMVADisc=4;kKinFit=5;kKinSolution=6;kWMassDeltaTopMass=7;kHitFit=8"), &typeid(TtEvent::HypoClassKey), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_3460, Reflex::Literal("TtEvent::HypoCombPair"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_57484, type_57485), Reflex::Literal("operator="), operator_13155, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_57485), Reflex::Literal("TtEvent"), constructor_13156, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TtEvent"), constructor_13158, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TtEvent"), destructor_13159, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2674, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TtEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TtEvent_funcmem_bld);
}

//------Delayed data member builder for class TtEvent -------------------
void __TtEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3462, Reflex::Literal("lepDecays_"), OffsetOf(__shadow__::__TtEvent, lepDecays_), ::Reflex::PROTECTED)
  .AddDataMember(type_6625, Reflex::Literal("genEvt_"), OffsetOf(__shadow__::__TtEvent, genEvt_), ::Reflex::PROTECTED)
  .AddDataMember(type_3843, Reflex::Literal("evtHyp_"), OffsetOf(__shadow__::__TtEvent, evtHyp_), ::Reflex::PROTECTED)
  .AddDataMember(type_3844, Reflex::Literal("nJetsConsidered_"), OffsetOf(__shadow__::__TtEvent, nJetsConsidered_), ::Reflex::PROTECTED)
  .AddDataMember(type_3597, Reflex::Literal("fitChi2_"), OffsetOf(__shadow__::__TtEvent, fitChi2_), ::Reflex::PROTECTED)
  .AddDataMember(type_3597, Reflex::Literal("hitFitChi2_"), OffsetOf(__shadow__::__TtEvent, hitFitChi2_), ::Reflex::PROTECTED)
  .AddDataMember(type_3597, Reflex::Literal("fitProb_"), OffsetOf(__shadow__::__TtEvent, fitProb_), ::Reflex::PROTECTED)
  .AddDataMember(type_3597, Reflex::Literal("hitFitProb_"), OffsetOf(__shadow__::__TtEvent, hitFitProb_), ::Reflex::PROTECTED)
  .AddDataMember(type_3597, Reflex::Literal("hitFitMT_"), OffsetOf(__shadow__::__TtEvent, hitFitMT_), ::Reflex::PROTECTED)
  .AddDataMember(type_3597, Reflex::Literal("hitFitSigMT_"), OffsetOf(__shadow__::__TtEvent, hitFitSigMT_), ::Reflex::PROTECTED)
  .AddDataMember(type_3597, Reflex::Literal("genMatchSumPt_"), OffsetOf(__shadow__::__TtEvent, genMatchSumPt_), ::Reflex::PROTECTED)
  .AddDataMember(type_3597, Reflex::Literal("genMatchSumDR_"), OffsetOf(__shadow__::__TtEvent, genMatchSumDR_), ::Reflex::PROTECTED)
  .AddDataMember(type_2978, Reflex::Literal("mvaMethod_"), OffsetOf(__shadow__::__TtEvent, mvaMethod_), ::Reflex::PROTECTED)
  .AddDataMember(type_3597, Reflex::Literal("mvaDisc_"), OffsetOf(__shadow__::__TtEvent, mvaDisc_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TtEvent -------------------
void __TtEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3462), Reflex::Literal("lepDecays"), method_13160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28831, type_46455, type_16564), Reflex::Literal("eventHypo"), method_13161, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46181), Reflex::Literal("genEvent"), method_13162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_30186), Reflex::Literal("isHypoClassAvailable"), method_13163, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_46455), Reflex::Literal("isHypoClassAvailable"), method_13164, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_30186, type_16564), Reflex::Literal("isHypoAvailable"), method_13165, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_46455, type_16564), Reflex::Literal("isHypoAvailable"), method_13166, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_30186, type_16564), Reflex::Literal("isHypoValid"), method_13167, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_46455, type_16564), Reflex::Literal("isHypoValid"), method_13168, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_398), Reflex::Literal("numberOfAvailableHypoClasses"), method_13169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_398, type_30186), Reflex::Literal("numberOfAvailableHypos"), method_13170, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_398, type_46455), Reflex::Literal("numberOfAvailableHypos"), method_13171, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74, type_30186), Reflex::Literal("numberOfConsideredJets"), method_13172, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74, type_46455), Reflex::Literal("numberOfConsideredJets"), method_13173, 0, "key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3559, type_30186, type_16564), Reflex::Literal("jetLeptonCombination"), method_13174, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3559, type_46455, type_16564), Reflex::Literal("jetLeptonCombination"), method_13175, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_16564), Reflex::Literal("genMatchSumPt"), method_13176, 0, "cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_16564), Reflex::Literal("genMatchSumDR"), method_13177, 0, "cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2978), Reflex::Literal("mvaMethod"), method_13178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_16564), Reflex::Literal("mvaDisc"), method_13179, 0, "cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_16564), Reflex::Literal("fitChi2"), method_13180, 0, "cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_16564), Reflex::Literal("hitFitChi2"), method_13181, 0, "cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_16564), Reflex::Literal("fitProb"), method_13182, 0, "cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_16564), Reflex::Literal("hitFitProb"), method_13183, 0, "cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_16564), Reflex::Literal("hitFitMT"), method_13184, 0, "cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_16564), Reflex::Literal("hitFitSigMT"), method_13185, 0, "cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74, type_30186, type_16564, type_30186), Reflex::Literal("correspondingHypo"), method_13186, 0, "key1;hyp1;key2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_74, type_46455, type_16564, type_46455), Reflex::Literal("correspondingHypo"), method_13187, 0, "key1;hyp1;key2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("topPair"), method_13188, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("topPair"), method_13189, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47450), Reflex::Literal("topPair"), method_13190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_57486, type_4818, type_46454), Reflex::Literal("printParticle"), method_13191, 0, "log;name;cand", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_57487, type_57487), Reflex::Literal("setLepDecays"), method_13192, 0, "lepDecTop1;lepDecTop2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_46182), Reflex::Literal("setGenEvent"), method_13193, 0, "evt", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_46455, type_3460c), Reflex::Literal("addEventHypo"), method_13194, 0, "key;hyp", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_46455, type_398c), Reflex::Literal("setNumberOfConsideredJets"), method_13195, 0, "key;nJets", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_47413), Reflex::Literal("setGenMatchSumPt"), method_13196, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_47413), Reflex::Literal("setGenMatchSumDR"), method_13197, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_30186), Reflex::Literal("setMvaMethod"), method_13198, 0, "name", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_47413), Reflex::Literal("setMvaDiscriminators"), method_13199, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_47413), Reflex::Literal("setFitChi2"), method_13200, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_47413), Reflex::Literal("setHitFitChi2"), method_13201, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_47413), Reflex::Literal("setFitProb"), method_13202, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_47413), Reflex::Literal("setHitFitProb"), method_13203, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_47413), Reflex::Literal("setHitFitMT"), method_13204, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_47413), Reflex::Literal("setHitFitSigMT"), method_13205, 0, "val", ::Reflex::PUBLIC);
}
//------Stub functions for class TtFullLeptonicEvent -------------------------------
static  void operator_13649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TtFullLeptonicEvent*)o)->operator=)(*(const ::TtFullLeptonicEvent*)arg[0]);
  else   (((::TtFullLeptonicEvent*)o)->operator=)(*(const ::TtFullLeptonicEvent*)arg[0]);
}

static void constructor_13650( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtFullLeptonicEvent(*(const ::TtFullLeptonicEvent*)arg[0]);
  else ::new(mem) ::TtFullLeptonicEvent(*(const ::TtFullLeptonicEvent*)arg[0]);
}

static void constructor_13651( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TtFullLeptonicEvent();
  else ::new(mem) ::TtFullLeptonicEvent();
}

static void destructor_13652(void*, void * o, const std::vector<void*>&, void *) {
(((::TtFullLeptonicEvent*)o)->::TtFullLeptonicEvent::~TtFullLeptonicEvent)();
}
static  void method_13653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->top)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->top)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->top)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->top)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->top)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->top)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->top)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->top)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13655( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->b)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->b)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->b)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->b)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->b)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->b)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->b)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->b)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->wPlus)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->wPlus)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->wPlus)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->wPlus)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13658( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->wPlus)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->wPlus)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->wPlus)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->wPlus)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->leptonBar)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->leptonBar)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->leptonBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->leptonBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->leptonBar)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->leptonBar)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->leptonBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->leptonBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->neutrino)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->neutrino)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->neutrino)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->neutrino)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->neutrino)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->neutrino)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->neutrino)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->neutrino)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->topBar)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->topBar)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->topBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->topBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->topBar)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->topBar)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->topBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->topBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->bBar)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->bBar)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->bBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->bBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->bBar)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->bBar)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->bBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->bBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13667( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->wMinus)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->wMinus)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->wMinus)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->wMinus)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->wMinus)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->wMinus)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->wMinus)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->wMinus)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->lepton)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->lepton)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->lepton)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->lepton)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13670( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->lepton)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->lepton)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->lepton)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->lepton)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13671( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->neutrinoBar)(*(const ::std::string*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->neutrinoBar)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->neutrinoBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->neutrinoBar)(*(const ::std::string*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->neutrinoBar)(*(const ::TtEvent::HypoClassKey*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->neutrinoBar)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->neutrinoBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]));
    else     (((const ::TtFullLeptonicEvent*)o)->neutrinoBar)(*(const ::TtEvent::HypoClassKey*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->genTop)());
  else   (((const ::TtFullLeptonicEvent*)o)->genTop)();
}

static  void method_13674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->genB)());
  else   (((const ::TtFullLeptonicEvent*)o)->genB)();
}

static  void method_13675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->genWPlus)());
  else   (((const ::TtFullLeptonicEvent*)o)->genWPlus)();
}

static  void method_13676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->genLeptonBar)());
  else   (((const ::TtFullLeptonicEvent*)o)->genLeptonBar)();
}

static  void method_13677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->genNeutrino)());
  else   (((const ::TtFullLeptonicEvent*)o)->genNeutrino)();
}

static  void method_13678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->genTopBar)());
  else   (((const ::TtFullLeptonicEvent*)o)->genTopBar)();
}

static  void method_13679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->genBBar)());
  else   (((const ::TtFullLeptonicEvent*)o)->genBBar)();
}

static  void method_13680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->genWMinus)());
  else   (((const ::TtFullLeptonicEvent*)o)->genWMinus)();
}

static  void method_13681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->genLepton)());
  else   (((const ::TtFullLeptonicEvent*)o)->genLepton)();
}

static  void method_13682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::TtFullLeptonicEvent*)o)->genNeutrinoBar)());
  else   (((const ::TtFullLeptonicEvent*)o)->genNeutrinoBar)();
}

static  void method_13683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::TtFullLeptonicEvent*)o)->solWeight)());
    else     (((const ::TtFullLeptonicEvent*)o)->solWeight)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::TtFullLeptonicEvent*)o)->solWeight)(*(const unsigned int*)arg[0]));
    else     (((const ::TtFullLeptonicEvent*)o)->solWeight)(*(const unsigned int*)arg[0]);
  }
}

static  void method_13684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::TtFullLeptonicEvent*)o)->isWrongCharge)());
  else   (((const ::TtFullLeptonicEvent*)o)->isWrongCharge)();
}

static  void method_13685( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtFullLeptonicEvent*)o)->setSolWeight)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_13686( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::TtFullLeptonicEvent*)o)->setWrongCharge)(*(const bool*)arg[0]);
}

static  void method_13687( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((const ::TtFullLeptonicEvent*)o)->print)();
  }
  else if ( arg.size() == 1 ) { 
    (((const ::TtFullLeptonicEvent*)o)->print)(*(const int*)arg[0]);
  }
}

static void method_newdel_2790( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TtFullLeptonicEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TtFullLeptonicEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TtFullLeptonicEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TtFullLeptonicEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TtFullLeptonicEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TtEvent")), ::Reflex::BaseOffset< ::TtFullLeptonicEvent,::TtEvent >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TtFullLeptonicEvent -------------------------------
void __TtFullLeptonicEvent_db_datamem(Reflex::Class*);
void __TtFullLeptonicEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TtFullLeptonicEvent_datamem_bld(&__TtFullLeptonicEvent_db_datamem);
Reflex::GenreflexMemberBuilder __TtFullLeptonicEvent_funcmem_bld(&__TtFullLeptonicEvent_db_funcmem);
void __TtFullLeptonicEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TtFullLeptonicEvent"), typeid(::TtFullLeptonicEvent), sizeof(::TtFullLeptonicEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_2674, ::Reflex::BaseOffset< ::TtFullLeptonicEvent, ::TtEvent >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_57545, type_57546), Reflex::Literal("operator="), operator_13649, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_57546), Reflex::Literal("TtFullLeptonicEvent"), constructor_13650, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TtFullLeptonicEvent"), constructor_13651, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TtFullLeptonicEvent"), destructor_13652, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2790, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TtFullLeptonicEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TtFullLeptonicEvent_funcmem_bld);
}

//------Delayed data member builder for class TtFullLeptonicEvent -------------------
void __TtFullLeptonicEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3597, Reflex::Literal("solWeight_"), OffsetOf(__shadow__::__TtFullLeptonicEvent, solWeight_), ::Reflex::PROTECTED)
  .AddDataMember(type_1798, Reflex::Literal("wrongCharge_"), OffsetOf(__shadow__::__TtFullLeptonicEvent, wrongCharge_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class TtFullLeptonicEvent -------------------
void __TtFullLeptonicEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("top"), method_13653, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("top"), method_13654, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("b"), method_13655, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("b"), method_13656, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("wPlus"), method_13657, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("wPlus"), method_13658, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("leptonBar"), method_13659, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("leptonBar"), method_13660, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("neutrino"), method_13661, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("neutrino"), method_13662, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("topBar"), method_13663, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("topBar"), method_13664, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("bBar"), method_13665, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("bBar"), method_13666, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("wMinus"), method_13667, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("wMinus"), method_13668, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("lepton"), method_13669, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("lepton"), method_13670, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_30186, type_16564), Reflex::Literal("neutrinoBar"), method_13671, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46454, type_46455, type_16564), Reflex::Literal("neutrinoBar"), method_13672, 0, "key;cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("genTop"), method_13673, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("genB"), method_13674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("genWPlus"), method_13675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("genLeptonBar"), method_13676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("genNeutrino"), method_13677, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("genTopBar"), method_13678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("genBBar"), method_13679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("genWMinus"), method_13680, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("genLepton"), method_13681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22103), Reflex::Literal("genNeutrinoBar"), method_13682, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_111, type_16564), Reflex::Literal("solWeight"), method_13683, 0, "cmb=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isWrongCharge"), method_13684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_47413), Reflex::Literal("setSolWeight"), method_13685, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_29960), Reflex::Literal("setWrongCharge"), method_13686, 0, "val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_74c), Reflex::Literal("print"), method_13687, 0, "verbosity=1", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> -------------------------------
static void destructor_20049(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)o)->::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>::~pair)();
}
static  void operator_20050( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)o)->operator=)(*(const ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)arg[0]);
  else   (((::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)o)->operator=)(*(const ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)arg[0]);
}

static void constructor_20051( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>(*(const ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)arg[0]);
  else ::new(mem) ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>(*(const ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>*)arg[0]);
}

static void constructor_20052( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>();
  else ::new(mem) ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>();
}

static void constructor_20053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>(*(const ::edm::RefToBase<reco::Jet>*)arg[0],
      *(const ::reco::CATopJetProperties*)arg[1]);
  else ::new(mem) ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>(*(const ::edm::RefToBase<reco::Jet>*)arg[0],
      *(const ::reco::CATopJetProperties*)arg[1]);
}

static void method_newdel_3458( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> -------------------------------
void __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__db_datamem(Reflex::Class*);
void __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__datamem_bld(&__std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__funcmem_bld(&__std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__db_funcmem);
void __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>"), typeid(::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>), sizeof(::std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_6690, Reflex::Literal("std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>::first_type"))
  .AddTypedef(type_11390, Reflex::Literal("std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_20049, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60050, type_60051), Reflex::Literal("operator="), operator_20050, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60051), Reflex::Literal("pair"), constructor_20051, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_20052, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60052, type_60053), Reflex::Literal("pair"), constructor_20053, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3458, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__datamem_bld);
}

//------Delayed data member builder for class pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> -------------------
void __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6690, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_11390, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> -------------------
void __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<reco::CompositeCandidate,std::vector<int, std::allocator<int> > > -------------------------------
static void destructor_20066(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<reco::CompositeCandidate,std::vector<int> >*)o)->::std::pair<reco::CompositeCandidate,std::vector<int> >::~pair)();
}
static  void operator_20067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<reco::CompositeCandidate,std::vector<int> >*)o)->operator=)(*(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[0]);
  else   (((::std::pair<reco::CompositeCandidate,std::vector<int> >*)o)->operator=)(*(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[0]);
}

static void constructor_20068( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<reco::CompositeCandidate,std::vector<int> >(*(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[0]);
  else ::new(mem) ::std::pair<reco::CompositeCandidate,std::vector<int> >(*(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[0]);
}

static void constructor_20069( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<reco::CompositeCandidate,std::vector<int> >();
  else ::new(mem) ::std::pair<reco::CompositeCandidate,std::vector<int> >();
}

static void constructor_20070( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<reco::CompositeCandidate,std::vector<int> >(*(const ::reco::CompositeCandidate*)arg[0],
      *(const ::std::vector<int>*)arg[1]);
  else ::new(mem) ::std::pair<reco::CompositeCandidate,std::vector<int> >(*(const ::reco::CompositeCandidate*)arg[0],
      *(const ::std::vector<int>*)arg[1]);
}

static void method_newdel_3460( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<reco::CompositeCandidate,std::vector<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<reco::CompositeCandidate,std::vector<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<reco::CompositeCandidate,std::vector<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<reco::CompositeCandidate,std::vector<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<reco::CompositeCandidate,std::vector<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<reco::CompositeCandidate,std::vector<int, std::allocator<int> > > -------------------------------
void __std__pair_reco__CompositeCandidate_std__vector_int_s__db_datamem(Reflex::Class*);
void __std__pair_reco__CompositeCandidate_std__vector_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_reco__CompositeCandidate_std__vector_int_s__datamem_bld(&__std__pair_reco__CompositeCandidate_std__vector_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_reco__CompositeCandidate_std__vector_int_s__funcmem_bld(&__std__pair_reco__CompositeCandidate_std__vector_int_s__db_funcmem);
void __std__pair_reco__CompositeCandidate_std__vector_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<reco::CompositeCandidate,std::vector<int> >"), typeid(::std::pair<reco::CompositeCandidate,std::vector<int> >), sizeof(::std::pair<reco::CompositeCandidate,std::vector<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_11644, Reflex::Literal("std::pair<reco::CompositeCandidate,std::vector<int> >::first_type"))
  .AddTypedef(type_3559, Reflex::Literal("std::pair<reco::CompositeCandidate,std::vector<int> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_20066, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20817, type_20819), Reflex::Literal("operator="), operator_20067, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20819), Reflex::Literal("pair"), constructor_20068, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_20069, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28831, type_46559), Reflex::Literal("pair"), constructor_20070, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3460, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_reco__CompositeCandidate_std__vector_int_s__datamem_bld);
}

//------Delayed data member builder for class pair<reco::CompositeCandidate,std::vector<int, std::allocator<int> > > -------------------
void __std__pair_reco__CompositeCandidate_std__vector_int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11644, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_reco__CompositeCandidate_std__vector_int_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_3559, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_reco__CompositeCandidate_std__vector_int_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<reco::CompositeCandidate,std::vector<int, std::allocator<int> > > -------------------
void __std__pair_reco__CompositeCandidate_std__vector_int_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<WDecay::LeptonType,WDecay::LeptonType> -------------------------------
static void destructor_20083(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<WDecay::LeptonType,WDecay::LeptonType>*)o)->::std::pair<WDecay::LeptonType,WDecay::LeptonType>::~pair)();
}
static  void operator_20084( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<WDecay::LeptonType,WDecay::LeptonType>*)o)->operator=)(*(const ::std::pair<WDecay::LeptonType,WDecay::LeptonType>*)arg[0]);
  else   (((::std::pair<WDecay::LeptonType,WDecay::LeptonType>*)o)->operator=)(*(const ::std::pair<WDecay::LeptonType,WDecay::LeptonType>*)arg[0]);
}

static void constructor_20085( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<WDecay::LeptonType,WDecay::LeptonType>(*(const ::std::pair<WDecay::LeptonType,WDecay::LeptonType>*)arg[0]);
  else ::new(mem) ::std::pair<WDecay::LeptonType,WDecay::LeptonType>(*(const ::std::pair<WDecay::LeptonType,WDecay::LeptonType>*)arg[0]);
}

static void constructor_20086( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<WDecay::LeptonType,WDecay::LeptonType>();
  else ::new(mem) ::std::pair<WDecay::LeptonType,WDecay::LeptonType>();
}

static void constructor_20087( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<WDecay::LeptonType,WDecay::LeptonType>(*(const ::WDecay::LeptonType*)arg[0],
      *(const ::WDecay::LeptonType*)arg[1]);
  else ::new(mem) ::std::pair<WDecay::LeptonType,WDecay::LeptonType>(*(const ::WDecay::LeptonType*)arg[0],
      *(const ::WDecay::LeptonType*)arg[1]);
}

static void method_newdel_3462( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<WDecay::LeptonType,WDecay::LeptonType> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<WDecay::LeptonType,WDecay::LeptonType> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<WDecay::LeptonType,WDecay::LeptonType> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<WDecay::LeptonType,WDecay::LeptonType> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<WDecay::LeptonType,WDecay::LeptonType> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<WDecay::LeptonType,WDecay::LeptonType> -------------------------------
void __std__pair_WDecay__LeptonType_WDecay__LeptonType__db_datamem(Reflex::Class*);
void __std__pair_WDecay__LeptonType_WDecay__LeptonType__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_WDecay__LeptonType_WDecay__LeptonType__datamem_bld(&__std__pair_WDecay__LeptonType_WDecay__LeptonType__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_WDecay__LeptonType_WDecay__LeptonType__funcmem_bld(&__std__pair_WDecay__LeptonType_WDecay__LeptonType__db_funcmem);
void __std__pair_WDecay__LeptonType_WDecay__LeptonType__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<WDecay::LeptonType,WDecay::LeptonType>"), typeid(::std::pair<WDecay::LeptonType,WDecay::LeptonType>), sizeof(::std::pair<WDecay::LeptonType,WDecay::LeptonType>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_10621, Reflex::Literal("std::pair<WDecay::LeptonType,WDecay::LeptonType>::first_type"))
  .AddTypedef(type_10621, Reflex::Literal("std::pair<WDecay::LeptonType,WDecay::LeptonType>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_20083, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60056, type_60057), Reflex::Literal("operator="), operator_20084, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60057), Reflex::Literal("pair"), constructor_20085, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_20086, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_57487, type_57487), Reflex::Literal("pair"), constructor_20087, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3462, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_WDecay__LeptonType_WDecay__LeptonType__datamem_bld);
}

//------Delayed data member builder for class pair<WDecay::LeptonType,WDecay::LeptonType> -------------------
void __std__pair_WDecay__LeptonType_WDecay__LeptonType__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10621, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_WDecay__LeptonType_WDecay__LeptonType_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_10621, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_WDecay__LeptonType_WDecay__LeptonType_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<WDecay::LeptonType,WDecay::LeptonType> -------------------
void __std__pair_WDecay__LeptonType_WDecay__LeptonType__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<StEvtSolution,std::allocator<StEvtSolution> > -------------------------------
static void constructor_20568( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<StEvtSolution>();
  else ::new(mem) ::std::vector<StEvtSolution>();
}

static void constructor_20569( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<StEvtSolution>(*(const ::std::allocator<StEvtSolution>*)arg[0]);
  else ::new(mem) ::std::vector<StEvtSolution>(*(const ::std::allocator<StEvtSolution>*)arg[0]);
}

static void constructor_20570( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<StEvtSolution>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<StEvtSolution>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<StEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::StEvtSolution*)arg[1]);
  else ::new(mem) ::std::vector<StEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::StEvtSolution*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<StEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::StEvtSolution*)arg[1],
      *(const ::std::allocator<StEvtSolution>*)arg[2]);
  else ::new(mem) ::std::vector<StEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::StEvtSolution*)arg[1],
      *(const ::std::allocator<StEvtSolution>*)arg[2]);
  }
}

static void constructor_20571( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<StEvtSolution>(*(const ::std::vector<StEvtSolution>*)arg[0]);
  else ::new(mem) ::std::vector<StEvtSolution>(*(const ::std::vector<StEvtSolution>*)arg[0]);
}

static void destructor_20572(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<StEvtSolution>*)o)->::std::vector<StEvtSolution>::~vector)();
}
static  void operator_20573( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<StEvtSolution>*)o)->operator=)(*(const ::std::vector<StEvtSolution>*)arg[0]);
  else   (((::std::vector<StEvtSolution>*)o)->operator=)(*(const ::std::vector<StEvtSolution>*)arg[0]);
}

static  void method_20574( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<StEvtSolution>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::StEvtSolution*)arg[1]);
}

static  void method_20575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >)((((::std::vector<StEvtSolution>*)o)->begin)());
  else   (((::std::vector<StEvtSolution>*)o)->begin)();
}

static  void method_20576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const StEvtSolution*,std::vector<StEvtSolution> >)((((const ::std::vector<StEvtSolution>*)o)->begin)());
  else   (((const ::std::vector<StEvtSolution>*)o)->begin)();
}

static  void method_20577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >)((((::std::vector<StEvtSolution>*)o)->end)());
  else   (((::std::vector<StEvtSolution>*)o)->end)();
}

static  void method_20578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const StEvtSolution*,std::vector<StEvtSolution> >)((((const ::std::vector<StEvtSolution>*)o)->end)());
  else   (((const ::std::vector<StEvtSolution>*)o)->end)();
}

static  void method_20583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<StEvtSolution>*)o)->size)());
  else   (((const ::std::vector<StEvtSolution>*)o)->size)();
}

static  void method_20584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<StEvtSolution>*)o)->max_size)());
  else   (((const ::std::vector<StEvtSolution>*)o)->max_size)();
}

static  void method_20585( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<StEvtSolution>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<StEvtSolution>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::StEvtSolution*)arg[1]);
  }
}

static  void method_20586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<StEvtSolution>*)o)->capacity)());
  else   (((const ::std::vector<StEvtSolution>*)o)->capacity)();
}

static  void method_20587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<StEvtSolution>*)o)->empty)());
  else   (((const ::std::vector<StEvtSolution>*)o)->empty)();
}

static  void method_20588( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<StEvtSolution>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<StEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<StEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<StEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<StEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20592( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<StEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<StEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20593( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<StEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<StEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<StEvtSolution>*)o)->front)();
  else   (((::std::vector<StEvtSolution>*)o)->front)();
}

static  void method_20595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<StEvtSolution>*)o)->front)();
  else   (((const ::std::vector<StEvtSolution>*)o)->front)();
}

static  void method_20596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<StEvtSolution>*)o)->back)();
  else   (((::std::vector<StEvtSolution>*)o)->back)();
}

static  void method_20597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<StEvtSolution>*)o)->back)();
  else   (((const ::std::vector<StEvtSolution>*)o)->back)();
}

static  void method_20598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<StEvtSolution>*)o)->data)());
  else   (((::std::vector<StEvtSolution>*)o)->data)();
}

static  void method_20599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<StEvtSolution>*)o)->data)());
  else   (((const ::std::vector<StEvtSolution>*)o)->data)();
}

static  void method_20600( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<StEvtSolution>*)o)->push_back)(*(const ::StEvtSolution*)arg[0]);
}

static  void method_20601( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<StEvtSolution>*)o)->pop_back)();
}

static  void method_20602( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >)((((::std::vector<StEvtSolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >*)arg[0],
    *(const ::StEvtSolution*)arg[1]));
  else   (((::std::vector<StEvtSolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >*)arg[0],
    *(const ::StEvtSolution*)arg[1]);
}

static  void method_20603( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<StEvtSolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::StEvtSolution*)arg[2]);
}

static  void method_20604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >)((((::std::vector<StEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >*)arg[0]));
  else   (((::std::vector<StEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >*)arg[0]);
}

static  void method_20605( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >)((((::std::vector<StEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >*)arg[1]));
  else   (((::std::vector<StEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<StEvtSolution*,std::vector<StEvtSolution> >*)arg[1]);
}

static  void method_20606( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<StEvtSolution>*)o)->swap)(*(::std::vector<StEvtSolution>*)arg[0]);
}

static  void method_20607( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<StEvtSolution>*)o)->clear)();
}

static void method_newdel_3554( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<StEvtSolution> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<StEvtSolution> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<StEvtSolution> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<StEvtSolution> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<StEvtSolution> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<StEvtSolution,std::allocator<StEvtSolution> >")), ::Reflex::BaseOffset< ::std::vector<StEvtSolution>,::std::_Vector_base<StEvtSolution,std::allocator<StEvtSolution> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<StEvtSolution> >::Generate();
  else ::Reflex::Proxy< ::std::vector<StEvtSolution> >::Generate();
}

//------Dictionary for class vector<StEvtSolution,std::allocator<StEvtSolution> > -------------------------------
void __std__vector_StEvtSolution__db_datamem(Reflex::Class*);
void __std__vector_StEvtSolution__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_StEvtSolution__datamem_bld(&__std__vector_StEvtSolution__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_StEvtSolution__funcmem_bld(&__std__vector_StEvtSolution__db_funcmem);
void __std__vector_StEvtSolution__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<StEvtSolution>"), typeid(::std::vector<StEvtSolution>), sizeof(::std::vector<StEvtSolution>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2817, ::Reflex::BaseOffset< ::std::vector<StEvtSolution>, ::std::_Vector_base<StEvtSolution,std::allocator<StEvtSolution> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1709, Reflex::Literal("std::vector<StEvtSolution>::_Alloc_value_type"))
  .AddTypedef(type_2817, Reflex::Literal("std::vector<StEvtSolution>::_Base"))
  .AddTypedef(type_3978, Reflex::Literal("std::vector<StEvtSolution>::_Tp_alloc_type"))
  .AddTypedef(type_1709, Reflex::Literal("std::vector<StEvtSolution>::value_type"))
  .AddTypedef(type_20553, Reflex::Literal("std::vector<StEvtSolution>::pointer"))
  .AddTypedef(type_20555, Reflex::Literal("std::vector<StEvtSolution>::const_pointer"))
  .AddTypedef(type_20557, Reflex::Literal("std::vector<StEvtSolution>::reference"))
  .AddTypedef(type_20559, Reflex::Literal("std::vector<StEvtSolution>::const_reference"))
  .AddTypedef(type_11880, Reflex::Literal("std::vector<StEvtSolution>::iterator"))
  .AddTypedef(type_11881, Reflex::Literal("std::vector<StEvtSolution>::const_iterator"))
  .AddTypedef(type_4425, Reflex::Literal("std::vector<StEvtSolution>::const_reverse_iterator"))
  .AddTypedef(type_4426, Reflex::Literal("std::vector<StEvtSolution>::reverse_iterator"))
  .AddTypedef(type_3954, Reflex::Literal("std::vector<StEvtSolution>::size_type"))
  .AddTypedef(type_3818, Reflex::Literal("std::vector<StEvtSolution>::difference_type"))
  .AddTypedef(type_3978, Reflex::Literal("std::vector<StEvtSolution>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20568, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_57580), Reflex::Literal("vector"), constructor_20569, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3954, type_20559, type_57580), Reflex::Literal("vector"), constructor_20570, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60094), Reflex::Literal("vector"), constructor_20571, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20572, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3554, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_StEvtSolution__funcmem_bld);
}

//------Delayed data member builder for class vector<StEvtSolution,std::allocator<StEvtSolution> > -------------------
void __std__vector_StEvtSolution__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<StEvtSolution,std::allocator<StEvtSolution> > -------------------
void __std__vector_StEvtSolution__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60095, type_60094), Reflex::Literal("operator="), operator_20573, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954, type_20559), Reflex::Literal("assign"), method_20574, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11880), Reflex::Literal("begin"), method_20575, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11881), Reflex::Literal("begin"), method_20576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11880), Reflex::Literal("end"), method_20577, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11881), Reflex::Literal("end"), method_20578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("size"), method_20583, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("max_size"), method_20584, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954, type_1709), Reflex::Literal("resize"), method_20585, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("capacity"), method_20586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("empty"), method_20587, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954), Reflex::Literal("reserve"), method_20588, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20557, type_3954), Reflex::Literal("operator[]"), operator_20589, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20559, type_3954), Reflex::Literal("operator[]"), operator_20590, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20557, type_3954), Reflex::Literal("at"), method_20592, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20559, type_3954), Reflex::Literal("at"), method_20593, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20557), Reflex::Literal("front"), method_20594, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20559), Reflex::Literal("front"), method_20595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20557), Reflex::Literal("back"), method_20596, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20559), Reflex::Literal("back"), method_20597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20553), Reflex::Literal("data"), method_20598, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20555), Reflex::Literal("data"), method_20599, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_20559), Reflex::Literal("push_back"), method_20600, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("pop_back"), method_20601, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11880, type_11880, type_20559), Reflex::Literal("insert"), method_20602, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_11880, type_3954, type_20559), Reflex::Literal("insert"), method_20603, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11880, type_11880), Reflex::Literal("erase"), method_20604, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11880, type_11880, type_11880), Reflex::Literal("erase"), method_20605, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_60095), Reflex::Literal("swap"), method_20606, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("clear"), method_20607, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<TtHadEvtSolution,std::allocator<TtHadEvtSolution> > -------------------------------
static void constructor_20633( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtHadEvtSolution>();
  else ::new(mem) ::std::vector<TtHadEvtSolution>();
}

static void constructor_20634( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtHadEvtSolution>(*(const ::std::allocator<TtHadEvtSolution>*)arg[0]);
  else ::new(mem) ::std::vector<TtHadEvtSolution>(*(const ::std::allocator<TtHadEvtSolution>*)arg[0]);
}

static void constructor_20635( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtHadEvtSolution>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TtHadEvtSolution>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtHadEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::TtHadEvtSolution*)arg[1]);
  else ::new(mem) ::std::vector<TtHadEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::TtHadEvtSolution*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtHadEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::TtHadEvtSolution*)arg[1],
      *(const ::std::allocator<TtHadEvtSolution>*)arg[2]);
  else ::new(mem) ::std::vector<TtHadEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::TtHadEvtSolution*)arg[1],
      *(const ::std::allocator<TtHadEvtSolution>*)arg[2]);
  }
}

static void constructor_20636( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtHadEvtSolution>(*(const ::std::vector<TtHadEvtSolution>*)arg[0]);
  else ::new(mem) ::std::vector<TtHadEvtSolution>(*(const ::std::vector<TtHadEvtSolution>*)arg[0]);
}

static void destructor_20637(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TtHadEvtSolution>*)o)->::std::vector<TtHadEvtSolution>::~vector)();
}
static  void operator_20638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtHadEvtSolution>*)o)->operator=)(*(const ::std::vector<TtHadEvtSolution>*)arg[0]);
  else   (((::std::vector<TtHadEvtSolution>*)o)->operator=)(*(const ::std::vector<TtHadEvtSolution>*)arg[0]);
}

static  void method_20639( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtHadEvtSolution>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::TtHadEvtSolution*)arg[1]);
}

static  void method_20640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >)((((::std::vector<TtHadEvtSolution>*)o)->begin)());
  else   (((::std::vector<TtHadEvtSolution>*)o)->begin)();
}

static  void method_20641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TtHadEvtSolution*,std::vector<TtHadEvtSolution> >)((((const ::std::vector<TtHadEvtSolution>*)o)->begin)());
  else   (((const ::std::vector<TtHadEvtSolution>*)o)->begin)();
}

static  void method_20642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >)((((::std::vector<TtHadEvtSolution>*)o)->end)());
  else   (((::std::vector<TtHadEvtSolution>*)o)->end)();
}

static  void method_20643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TtHadEvtSolution*,std::vector<TtHadEvtSolution> >)((((const ::std::vector<TtHadEvtSolution>*)o)->end)());
  else   (((const ::std::vector<TtHadEvtSolution>*)o)->end)();
}

static  void method_20648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TtHadEvtSolution>*)o)->size)());
  else   (((const ::std::vector<TtHadEvtSolution>*)o)->size)();
}

static  void method_20649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TtHadEvtSolution>*)o)->max_size)());
  else   (((const ::std::vector<TtHadEvtSolution>*)o)->max_size)();
}

static  void method_20650( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TtHadEvtSolution>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TtHadEvtSolution>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::TtHadEvtSolution*)arg[1]);
  }
}

static  void method_20651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TtHadEvtSolution>*)o)->capacity)());
  else   (((const ::std::vector<TtHadEvtSolution>*)o)->capacity)();
}

static  void method_20652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TtHadEvtSolution>*)o)->empty)());
  else   (((const ::std::vector<TtHadEvtSolution>*)o)->empty)();
}

static  void method_20653( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtHadEvtSolution>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtHadEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TtHadEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20655( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TtHadEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TtHadEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtHadEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TtHadEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20658( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TtHadEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TtHadEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtHadEvtSolution>*)o)->front)();
  else   (((::std::vector<TtHadEvtSolution>*)o)->front)();
}

static  void method_20660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TtHadEvtSolution>*)o)->front)();
  else   (((const ::std::vector<TtHadEvtSolution>*)o)->front)();
}

static  void method_20661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtHadEvtSolution>*)o)->back)();
  else   (((::std::vector<TtHadEvtSolution>*)o)->back)();
}

static  void method_20662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TtHadEvtSolution>*)o)->back)();
  else   (((const ::std::vector<TtHadEvtSolution>*)o)->back)();
}

static  void method_20663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TtHadEvtSolution>*)o)->data)());
  else   (((::std::vector<TtHadEvtSolution>*)o)->data)();
}

static  void method_20664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TtHadEvtSolution>*)o)->data)());
  else   (((const ::std::vector<TtHadEvtSolution>*)o)->data)();
}

static  void method_20665( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtHadEvtSolution>*)o)->push_back)(*(const ::TtHadEvtSolution*)arg[0]);
}

static  void method_20666( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TtHadEvtSolution>*)o)->pop_back)();
}

static  void method_20667( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >)((((::std::vector<TtHadEvtSolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >*)arg[0],
    *(const ::TtHadEvtSolution*)arg[1]));
  else   (((::std::vector<TtHadEvtSolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >*)arg[0],
    *(const ::TtHadEvtSolution*)arg[1]);
}

static  void method_20668( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtHadEvtSolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::TtHadEvtSolution*)arg[2]);
}

static  void method_20669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >)((((::std::vector<TtHadEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >*)arg[0]));
  else   (((::std::vector<TtHadEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >*)arg[0]);
}

static  void method_20670( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >)((((::std::vector<TtHadEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >*)arg[1]));
  else   (((::std::vector<TtHadEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TtHadEvtSolution*,std::vector<TtHadEvtSolution> >*)arg[1]);
}

static  void method_20671( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtHadEvtSolution>*)o)->swap)(*(::std::vector<TtHadEvtSolution>*)arg[0]);
}

static  void method_20672( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TtHadEvtSolution>*)o)->clear)();
}

static void method_newdel_3555( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TtHadEvtSolution> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TtHadEvtSolution> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TtHadEvtSolution> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TtHadEvtSolution> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TtHadEvtSolution> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TtHadEvtSolution,std::allocator<TtHadEvtSolution> >")), ::Reflex::BaseOffset< ::std::vector<TtHadEvtSolution>,::std::_Vector_base<TtHadEvtSolution,std::allocator<TtHadEvtSolution> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TtHadEvtSolution> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TtHadEvtSolution> >::Generate();
}

//------Dictionary for class vector<TtHadEvtSolution,std::allocator<TtHadEvtSolution> > -------------------------------
void __std__vector_TtHadEvtSolution__db_datamem(Reflex::Class*);
void __std__vector_TtHadEvtSolution__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TtHadEvtSolution__datamem_bld(&__std__vector_TtHadEvtSolution__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TtHadEvtSolution__funcmem_bld(&__std__vector_TtHadEvtSolution__db_funcmem);
void __std__vector_TtHadEvtSolution__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TtHadEvtSolution>"), typeid(::std::vector<TtHadEvtSolution>), sizeof(::std::vector<TtHadEvtSolution>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2818, ::Reflex::BaseOffset< ::std::vector<TtHadEvtSolution>, ::std::_Vector_base<TtHadEvtSolution,std::allocator<TtHadEvtSolution> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1805, Reflex::Literal("std::vector<TtHadEvtSolution>::_Alloc_value_type"))
  .AddTypedef(type_2818, Reflex::Literal("std::vector<TtHadEvtSolution>::_Base"))
  .AddTypedef(type_3979, Reflex::Literal("std::vector<TtHadEvtSolution>::_Tp_alloc_type"))
  .AddTypedef(type_1805, Reflex::Literal("std::vector<TtHadEvtSolution>::value_type"))
  .AddTypedef(type_20618, Reflex::Literal("std::vector<TtHadEvtSolution>::pointer"))
  .AddTypedef(type_20620, Reflex::Literal("std::vector<TtHadEvtSolution>::const_pointer"))
  .AddTypedef(type_20622, Reflex::Literal("std::vector<TtHadEvtSolution>::reference"))
  .AddTypedef(type_20624, Reflex::Literal("std::vector<TtHadEvtSolution>::const_reference"))
  .AddTypedef(type_11882, Reflex::Literal("std::vector<TtHadEvtSolution>::iterator"))
  .AddTypedef(type_11883, Reflex::Literal("std::vector<TtHadEvtSolution>::const_iterator"))
  .AddTypedef(type_4427, Reflex::Literal("std::vector<TtHadEvtSolution>::const_reverse_iterator"))
  .AddTypedef(type_4428, Reflex::Literal("std::vector<TtHadEvtSolution>::reverse_iterator"))
  .AddTypedef(type_3954, Reflex::Literal("std::vector<TtHadEvtSolution>::size_type"))
  .AddTypedef(type_3818, Reflex::Literal("std::vector<TtHadEvtSolution>::difference_type"))
  .AddTypedef(type_3979, Reflex::Literal("std::vector<TtHadEvtSolution>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20633, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_57592), Reflex::Literal("vector"), constructor_20634, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3954, type_20624, type_57592), Reflex::Literal("vector"), constructor_20635, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60097), Reflex::Literal("vector"), constructor_20636, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20637, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3555, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TtHadEvtSolution__funcmem_bld);
}

//------Delayed data member builder for class vector<TtHadEvtSolution,std::allocator<TtHadEvtSolution> > -------------------
void __std__vector_TtHadEvtSolution__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TtHadEvtSolution,std::allocator<TtHadEvtSolution> > -------------------
void __std__vector_TtHadEvtSolution__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60098, type_60097), Reflex::Literal("operator="), operator_20638, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954, type_20624), Reflex::Literal("assign"), method_20639, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11882), Reflex::Literal("begin"), method_20640, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11883), Reflex::Literal("begin"), method_20641, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11882), Reflex::Literal("end"), method_20642, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11883), Reflex::Literal("end"), method_20643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("size"), method_20648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("max_size"), method_20649, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954, type_1805), Reflex::Literal("resize"), method_20650, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("capacity"), method_20651, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("empty"), method_20652, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954), Reflex::Literal("reserve"), method_20653, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20622, type_3954), Reflex::Literal("operator[]"), operator_20654, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20624, type_3954), Reflex::Literal("operator[]"), operator_20655, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20622, type_3954), Reflex::Literal("at"), method_20657, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20624, type_3954), Reflex::Literal("at"), method_20658, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20622), Reflex::Literal("front"), method_20659, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20624), Reflex::Literal("front"), method_20660, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20622), Reflex::Literal("back"), method_20661, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20624), Reflex::Literal("back"), method_20662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20618), Reflex::Literal("data"), method_20663, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20620), Reflex::Literal("data"), method_20664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_20624), Reflex::Literal("push_back"), method_20665, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("pop_back"), method_20666, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11882, type_11882, type_20624), Reflex::Literal("insert"), method_20667, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_11882, type_3954, type_20624), Reflex::Literal("insert"), method_20668, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11882, type_11882), Reflex::Literal("erase"), method_20669, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11882, type_11882, type_11882), Reflex::Literal("erase"), method_20670, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_60098), Reflex::Literal("swap"), method_20671, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("clear"), method_20672, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<TtSemiEvtSolution,std::allocator<TtSemiEvtSolution> > -------------------------------
static void constructor_20698( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtSemiEvtSolution>();
  else ::new(mem) ::std::vector<TtSemiEvtSolution>();
}

static void constructor_20699( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtSemiEvtSolution>(*(const ::std::allocator<TtSemiEvtSolution>*)arg[0]);
  else ::new(mem) ::std::vector<TtSemiEvtSolution>(*(const ::std::allocator<TtSemiEvtSolution>*)arg[0]);
}

static void constructor_20700( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtSemiEvtSolution>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TtSemiEvtSolution>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtSemiEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::TtSemiEvtSolution*)arg[1]);
  else ::new(mem) ::std::vector<TtSemiEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::TtSemiEvtSolution*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtSemiEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::TtSemiEvtSolution*)arg[1],
      *(const ::std::allocator<TtSemiEvtSolution>*)arg[2]);
  else ::new(mem) ::std::vector<TtSemiEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::TtSemiEvtSolution*)arg[1],
      *(const ::std::allocator<TtSemiEvtSolution>*)arg[2]);
  }
}

static void constructor_20701( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtSemiEvtSolution>(*(const ::std::vector<TtSemiEvtSolution>*)arg[0]);
  else ::new(mem) ::std::vector<TtSemiEvtSolution>(*(const ::std::vector<TtSemiEvtSolution>*)arg[0]);
}

static void destructor_20702(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TtSemiEvtSolution>*)o)->::std::vector<TtSemiEvtSolution>::~vector)();
}
static  void operator_20703( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtSemiEvtSolution>*)o)->operator=)(*(const ::std::vector<TtSemiEvtSolution>*)arg[0]);
  else   (((::std::vector<TtSemiEvtSolution>*)o)->operator=)(*(const ::std::vector<TtSemiEvtSolution>*)arg[0]);
}

static  void method_20704( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtSemiEvtSolution>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::TtSemiEvtSolution*)arg[1]);
}

static  void method_20705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >)((((::std::vector<TtSemiEvtSolution>*)o)->begin)());
  else   (((::std::vector<TtSemiEvtSolution>*)o)->begin)();
}

static  void method_20706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >)((((const ::std::vector<TtSemiEvtSolution>*)o)->begin)());
  else   (((const ::std::vector<TtSemiEvtSolution>*)o)->begin)();
}

static  void method_20707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >)((((::std::vector<TtSemiEvtSolution>*)o)->end)());
  else   (((::std::vector<TtSemiEvtSolution>*)o)->end)();
}

static  void method_20708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >)((((const ::std::vector<TtSemiEvtSolution>*)o)->end)());
  else   (((const ::std::vector<TtSemiEvtSolution>*)o)->end)();
}

static  void method_20713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TtSemiEvtSolution>*)o)->size)());
  else   (((const ::std::vector<TtSemiEvtSolution>*)o)->size)();
}

static  void method_20714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TtSemiEvtSolution>*)o)->max_size)());
  else   (((const ::std::vector<TtSemiEvtSolution>*)o)->max_size)();
}

static  void method_20715( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TtSemiEvtSolution>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TtSemiEvtSolution>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::TtSemiEvtSolution*)arg[1]);
  }
}

static  void method_20716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TtSemiEvtSolution>*)o)->capacity)());
  else   (((const ::std::vector<TtSemiEvtSolution>*)o)->capacity)();
}

static  void method_20717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TtSemiEvtSolution>*)o)->empty)());
  else   (((const ::std::vector<TtSemiEvtSolution>*)o)->empty)();
}

static  void method_20718( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtSemiEvtSolution>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtSemiEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TtSemiEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TtSemiEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TtSemiEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtSemiEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TtSemiEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TtSemiEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TtSemiEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtSemiEvtSolution>*)o)->front)();
  else   (((::std::vector<TtSemiEvtSolution>*)o)->front)();
}

static  void method_20725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TtSemiEvtSolution>*)o)->front)();
  else   (((const ::std::vector<TtSemiEvtSolution>*)o)->front)();
}

static  void method_20726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtSemiEvtSolution>*)o)->back)();
  else   (((::std::vector<TtSemiEvtSolution>*)o)->back)();
}

static  void method_20727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TtSemiEvtSolution>*)o)->back)();
  else   (((const ::std::vector<TtSemiEvtSolution>*)o)->back)();
}

static  void method_20728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TtSemiEvtSolution>*)o)->data)());
  else   (((::std::vector<TtSemiEvtSolution>*)o)->data)();
}

static  void method_20729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TtSemiEvtSolution>*)o)->data)());
  else   (((const ::std::vector<TtSemiEvtSolution>*)o)->data)();
}

static  void method_20730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtSemiEvtSolution>*)o)->push_back)(*(const ::TtSemiEvtSolution*)arg[0]);
}

static  void method_20731( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TtSemiEvtSolution>*)o)->pop_back)();
}

static  void method_20732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >)((((::std::vector<TtSemiEvtSolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >*)arg[0],
    *(const ::TtSemiEvtSolution*)arg[1]));
  else   (((::std::vector<TtSemiEvtSolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >*)arg[0],
    *(const ::TtSemiEvtSolution*)arg[1]);
}

static  void method_20733( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtSemiEvtSolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::TtSemiEvtSolution*)arg[2]);
}

static  void method_20734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >)((((::std::vector<TtSemiEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >*)arg[0]));
  else   (((::std::vector<TtSemiEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >*)arg[0]);
}

static  void method_20735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >)((((::std::vector<TtSemiEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >*)arg[1]));
  else   (((::std::vector<TtSemiEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TtSemiEvtSolution*,std::vector<TtSemiEvtSolution> >*)arg[1]);
}

static  void method_20736( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtSemiEvtSolution>*)o)->swap)(*(::std::vector<TtSemiEvtSolution>*)arg[0]);
}

static  void method_20737( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TtSemiEvtSolution>*)o)->clear)();
}

static void method_newdel_3556( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TtSemiEvtSolution> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TtSemiEvtSolution> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TtSemiEvtSolution> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TtSemiEvtSolution> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TtSemiEvtSolution> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TtSemiEvtSolution,std::allocator<TtSemiEvtSolution> >")), ::Reflex::BaseOffset< ::std::vector<TtSemiEvtSolution>,::std::_Vector_base<TtSemiEvtSolution,std::allocator<TtSemiEvtSolution> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TtSemiEvtSolution> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TtSemiEvtSolution> >::Generate();
}

//------Dictionary for class vector<TtSemiEvtSolution,std::allocator<TtSemiEvtSolution> > -------------------------------
void __std__vector_TtSemiEvtSolution__db_datamem(Reflex::Class*);
void __std__vector_TtSemiEvtSolution__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TtSemiEvtSolution__datamem_bld(&__std__vector_TtSemiEvtSolution__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TtSemiEvtSolution__funcmem_bld(&__std__vector_TtSemiEvtSolution__db_funcmem);
void __std__vector_TtSemiEvtSolution__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TtSemiEvtSolution>"), typeid(::std::vector<TtSemiEvtSolution>), sizeof(::std::vector<TtSemiEvtSolution>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2819, ::Reflex::BaseOffset< ::std::vector<TtSemiEvtSolution>, ::std::_Vector_base<TtSemiEvtSolution,std::allocator<TtSemiEvtSolution> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_977, Reflex::Literal("std::vector<TtSemiEvtSolution>::_Alloc_value_type"))
  .AddTypedef(type_2819, Reflex::Literal("std::vector<TtSemiEvtSolution>::_Base"))
  .AddTypedef(type_3980, Reflex::Literal("std::vector<TtSemiEvtSolution>::_Tp_alloc_type"))
  .AddTypedef(type_977, Reflex::Literal("std::vector<TtSemiEvtSolution>::value_type"))
  .AddTypedef(type_20683, Reflex::Literal("std::vector<TtSemiEvtSolution>::pointer"))
  .AddTypedef(type_20685, Reflex::Literal("std::vector<TtSemiEvtSolution>::const_pointer"))
  .AddTypedef(type_20687, Reflex::Literal("std::vector<TtSemiEvtSolution>::reference"))
  .AddTypedef(type_20689, Reflex::Literal("std::vector<TtSemiEvtSolution>::const_reference"))
  .AddTypedef(type_11884, Reflex::Literal("std::vector<TtSemiEvtSolution>::iterator"))
  .AddTypedef(type_11885, Reflex::Literal("std::vector<TtSemiEvtSolution>::const_iterator"))
  .AddTypedef(type_4429, Reflex::Literal("std::vector<TtSemiEvtSolution>::const_reverse_iterator"))
  .AddTypedef(type_4430, Reflex::Literal("std::vector<TtSemiEvtSolution>::reverse_iterator"))
  .AddTypedef(type_3954, Reflex::Literal("std::vector<TtSemiEvtSolution>::size_type"))
  .AddTypedef(type_3818, Reflex::Literal("std::vector<TtSemiEvtSolution>::difference_type"))
  .AddTypedef(type_3980, Reflex::Literal("std::vector<TtSemiEvtSolution>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20698, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_57604), Reflex::Literal("vector"), constructor_20699, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3954, type_20689, type_57604), Reflex::Literal("vector"), constructor_20700, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60100), Reflex::Literal("vector"), constructor_20701, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20702, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3556, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TtSemiEvtSolution__funcmem_bld);
}

//------Delayed data member builder for class vector<TtSemiEvtSolution,std::allocator<TtSemiEvtSolution> > -------------------
void __std__vector_TtSemiEvtSolution__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TtSemiEvtSolution,std::allocator<TtSemiEvtSolution> > -------------------
void __std__vector_TtSemiEvtSolution__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60101, type_60100), Reflex::Literal("operator="), operator_20703, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954, type_20689), Reflex::Literal("assign"), method_20704, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11884), Reflex::Literal("begin"), method_20705, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11885), Reflex::Literal("begin"), method_20706, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11884), Reflex::Literal("end"), method_20707, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11885), Reflex::Literal("end"), method_20708, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("size"), method_20713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("max_size"), method_20714, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954, type_977), Reflex::Literal("resize"), method_20715, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("capacity"), method_20716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("empty"), method_20717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954), Reflex::Literal("reserve"), method_20718, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20687, type_3954), Reflex::Literal("operator[]"), operator_20719, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20689, type_3954), Reflex::Literal("operator[]"), operator_20720, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20687, type_3954), Reflex::Literal("at"), method_20722, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20689, type_3954), Reflex::Literal("at"), method_20723, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20687), Reflex::Literal("front"), method_20724, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20689), Reflex::Literal("front"), method_20725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20687), Reflex::Literal("back"), method_20726, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20689), Reflex::Literal("back"), method_20727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20683), Reflex::Literal("data"), method_20728, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20685), Reflex::Literal("data"), method_20729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_20689), Reflex::Literal("push_back"), method_20730, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("pop_back"), method_20731, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11884, type_11884, type_20689), Reflex::Literal("insert"), method_20732, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_11884, type_3954, type_20689), Reflex::Literal("insert"), method_20733, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11884, type_11884), Reflex::Literal("erase"), method_20734, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11884, type_11884, type_11884), Reflex::Literal("erase"), method_20735, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_60101), Reflex::Literal("swap"), method_20736, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("clear"), method_20737, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<TtDilepEvtSolution,std::allocator<TtDilepEvtSolution> > -------------------------------
static void constructor_20763( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtDilepEvtSolution>();
  else ::new(mem) ::std::vector<TtDilepEvtSolution>();
}

static void constructor_20764( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtDilepEvtSolution>(*(const ::std::allocator<TtDilepEvtSolution>*)arg[0]);
  else ::new(mem) ::std::vector<TtDilepEvtSolution>(*(const ::std::allocator<TtDilepEvtSolution>*)arg[0]);
}

static void constructor_20765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtDilepEvtSolution>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TtDilepEvtSolution>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtDilepEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::TtDilepEvtSolution*)arg[1]);
  else ::new(mem) ::std::vector<TtDilepEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::TtDilepEvtSolution*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtDilepEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::TtDilepEvtSolution*)arg[1],
      *(const ::std::allocator<TtDilepEvtSolution>*)arg[2]);
  else ::new(mem) ::std::vector<TtDilepEvtSolution>(*(::std::size_t*)arg[0],
      *(const ::TtDilepEvtSolution*)arg[1],
      *(const ::std::allocator<TtDilepEvtSolution>*)arg[2]);
  }
}

static void constructor_20766( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TtDilepEvtSolution>(*(const ::std::vector<TtDilepEvtSolution>*)arg[0]);
  else ::new(mem) ::std::vector<TtDilepEvtSolution>(*(const ::std::vector<TtDilepEvtSolution>*)arg[0]);
}

static void destructor_20767(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TtDilepEvtSolution>*)o)->::std::vector<TtDilepEvtSolution>::~vector)();
}
static  void operator_20768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtDilepEvtSolution>*)o)->operator=)(*(const ::std::vector<TtDilepEvtSolution>*)arg[0]);
  else   (((::std::vector<TtDilepEvtSolution>*)o)->operator=)(*(const ::std::vector<TtDilepEvtSolution>*)arg[0]);
}

static  void method_20769( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtDilepEvtSolution>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::TtDilepEvtSolution*)arg[1]);
}

static  void method_20770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >)((((::std::vector<TtDilepEvtSolution>*)o)->begin)());
  else   (((::std::vector<TtDilepEvtSolution>*)o)->begin)();
}

static  void method_20771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >)((((const ::std::vector<TtDilepEvtSolution>*)o)->begin)());
  else   (((const ::std::vector<TtDilepEvtSolution>*)o)->begin)();
}

static  void method_20772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >)((((::std::vector<TtDilepEvtSolution>*)o)->end)());
  else   (((::std::vector<TtDilepEvtSolution>*)o)->end)();
}

static  void method_20773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >)((((const ::std::vector<TtDilepEvtSolution>*)o)->end)());
  else   (((const ::std::vector<TtDilepEvtSolution>*)o)->end)();
}

static  void method_20778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TtDilepEvtSolution>*)o)->size)());
  else   (((const ::std::vector<TtDilepEvtSolution>*)o)->size)();
}

static  void method_20779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TtDilepEvtSolution>*)o)->max_size)());
  else   (((const ::std::vector<TtDilepEvtSolution>*)o)->max_size)();
}

static  void method_20780( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TtDilepEvtSolution>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TtDilepEvtSolution>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::TtDilepEvtSolution*)arg[1]);
  }
}

static  void method_20781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TtDilepEvtSolution>*)o)->capacity)());
  else   (((const ::std::vector<TtDilepEvtSolution>*)o)->capacity)();
}

static  void method_20782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TtDilepEvtSolution>*)o)->empty)());
  else   (((const ::std::vector<TtDilepEvtSolution>*)o)->empty)();
}

static  void method_20783( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtDilepEvtSolution>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20784( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtDilepEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TtDilepEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20785( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TtDilepEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TtDilepEvtSolution>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20787( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtDilepEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TtDilepEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TtDilepEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TtDilepEvtSolution>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtDilepEvtSolution>*)o)->front)();
  else   (((::std::vector<TtDilepEvtSolution>*)o)->front)();
}

static  void method_20790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TtDilepEvtSolution>*)o)->front)();
  else   (((const ::std::vector<TtDilepEvtSolution>*)o)->front)();
}

static  void method_20791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TtDilepEvtSolution>*)o)->back)();
  else   (((::std::vector<TtDilepEvtSolution>*)o)->back)();
}

static  void method_20792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TtDilepEvtSolution>*)o)->back)();
  else   (((const ::std::vector<TtDilepEvtSolution>*)o)->back)();
}

static  void method_20793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TtDilepEvtSolution>*)o)->data)());
  else   (((::std::vector<TtDilepEvtSolution>*)o)->data)();
}

static  void method_20794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TtDilepEvtSolution>*)o)->data)());
  else   (((const ::std::vector<TtDilepEvtSolution>*)o)->data)();
}

static  void method_20795( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtDilepEvtSolution>*)o)->push_back)(*(const ::TtDilepEvtSolution*)arg[0]);
}

static  void method_20796( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TtDilepEvtSolution>*)o)->pop_back)();
}

static  void method_20797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >)((((::std::vector<TtDilepEvtSolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >*)arg[0],
    *(const ::TtDilepEvtSolution*)arg[1]));
  else   (((::std::vector<TtDilepEvtSolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >*)arg[0],
    *(const ::TtDilepEvtSolution*)arg[1]);
}

static  void method_20798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtDilepEvtSolution>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::TtDilepEvtSolution*)arg[2]);
}

static  void method_20799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >)((((::std::vector<TtDilepEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >*)arg[0]));
  else   (((::std::vector<TtDilepEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >*)arg[0]);
}

static  void method_20800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >)((((::std::vector<TtDilepEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >*)arg[1]));
  else   (((::std::vector<TtDilepEvtSolution>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TtDilepEvtSolution*,std::vector<TtDilepEvtSolution> >*)arg[1]);
}

static  void method_20801( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TtDilepEvtSolution>*)o)->swap)(*(::std::vector<TtDilepEvtSolution>*)arg[0]);
}

static  void method_20802( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TtDilepEvtSolution>*)o)->clear)();
}

static void method_newdel_3557( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TtDilepEvtSolution> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TtDilepEvtSolution> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TtDilepEvtSolution> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TtDilepEvtSolution> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TtDilepEvtSolution> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x29( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TtDilepEvtSolution,std::allocator<TtDilepEvtSolution> >")), ::Reflex::BaseOffset< ::std::vector<TtDilepEvtSolution>,::std::_Vector_base<TtDilepEvtSolution,std::allocator<TtDilepEvtSolution> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TtDilepEvtSolution> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TtDilepEvtSolution> >::Generate();
}

//------Dictionary for class vector<TtDilepEvtSolution,std::allocator<TtDilepEvtSolution> > -------------------------------
void __std__vector_TtDilepEvtSolution__db_datamem(Reflex::Class*);
void __std__vector_TtDilepEvtSolution__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TtDilepEvtSolution__datamem_bld(&__std__vector_TtDilepEvtSolution__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TtDilepEvtSolution__funcmem_bld(&__std__vector_TtDilepEvtSolution__db_funcmem);
void __std__vector_TtDilepEvtSolution__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TtDilepEvtSolution>"), typeid(::std::vector<TtDilepEvtSolution>), sizeof(::std::vector<TtDilepEvtSolution>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2820, ::Reflex::BaseOffset< ::std::vector<TtDilepEvtSolution>, ::std::_Vector_base<TtDilepEvtSolution,std::allocator<TtDilepEvtSolution> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2053, Reflex::Literal("std::vector<TtDilepEvtSolution>::_Alloc_value_type"))
  .AddTypedef(type_2820, Reflex::Literal("std::vector<TtDilepEvtSolution>::_Base"))
  .AddTypedef(type_3981, Reflex::Literal("std::vector<TtDilepEvtSolution>::_Tp_alloc_type"))
  .AddTypedef(type_2053, Reflex::Literal("std::vector<TtDilepEvtSolution>::value_type"))
  .AddTypedef(type_20748, Reflex::Literal("std::vector<TtDilepEvtSolution>::pointer"))
  .AddTypedef(type_20750, Reflex::Literal("std::vector<TtDilepEvtSolution>::const_pointer"))
  .AddTypedef(type_20752, Reflex::Literal("std::vector<TtDilepEvtSolution>::reference"))
  .AddTypedef(type_20754, Reflex::Literal("std::vector<TtDilepEvtSolution>::const_reference"))
  .AddTypedef(type_11886, Reflex::Literal("std::vector<TtDilepEvtSolution>::iterator"))
  .AddTypedef(type_11887, Reflex::Literal("std::vector<TtDilepEvtSolution>::const_iterator"))
  .AddTypedef(type_4431, Reflex::Literal("std::vector<TtDilepEvtSolution>::const_reverse_iterator"))
  .AddTypedef(type_4432, Reflex::Literal("std::vector<TtDilepEvtSolution>::reverse_iterator"))
  .AddTypedef(type_3954, Reflex::Literal("std::vector<TtDilepEvtSolution>::size_type"))
  .AddTypedef(type_3818, Reflex::Literal("std::vector<TtDilepEvtSolution>::difference_type"))
  .AddTypedef(type_3981, Reflex::Literal("std::vector<TtDilepEvtSolution>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20763, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_57616), Reflex::Literal("vector"), constructor_20764, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3954, type_20754, type_57616), Reflex::Literal("vector"), constructor_20765, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60103), Reflex::Literal("vector"), constructor_20766, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20767, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3557, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x29, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TtDilepEvtSolution__funcmem_bld);
}

//------Delayed data member builder for class vector<TtDilepEvtSolution,std::allocator<TtDilepEvtSolution> > -------------------
void __std__vector_TtDilepEvtSolution__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TtDilepEvtSolution,std::allocator<TtDilepEvtSolution> > -------------------
void __std__vector_TtDilepEvtSolution__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60104, type_60103), Reflex::Literal("operator="), operator_20768, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954, type_20754), Reflex::Literal("assign"), method_20769, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11886), Reflex::Literal("begin"), method_20770, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11887), Reflex::Literal("begin"), method_20771, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11886), Reflex::Literal("end"), method_20772, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11887), Reflex::Literal("end"), method_20773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("size"), method_20778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("max_size"), method_20779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954, type_2053), Reflex::Literal("resize"), method_20780, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("capacity"), method_20781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("empty"), method_20782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954), Reflex::Literal("reserve"), method_20783, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20752, type_3954), Reflex::Literal("operator[]"), operator_20784, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20754, type_3954), Reflex::Literal("operator[]"), operator_20785, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20752, type_3954), Reflex::Literal("at"), method_20787, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20754, type_3954), Reflex::Literal("at"), method_20788, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20752), Reflex::Literal("front"), method_20789, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20754), Reflex::Literal("front"), method_20790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20752), Reflex::Literal("back"), method_20791, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20754), Reflex::Literal("back"), method_20792, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20748), Reflex::Literal("data"), method_20793, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20750), Reflex::Literal("data"), method_20794, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_20754), Reflex::Literal("push_back"), method_20795, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("pop_back"), method_20796, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11886, type_11886, type_20754), Reflex::Literal("insert"), method_20797, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_11886, type_3954, type_20754), Reflex::Literal("insert"), method_20798, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11886, type_11886), Reflex::Literal("erase"), method_20799, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11886, type_11886, type_11886), Reflex::Literal("erase"), method_20800, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_60104), Reflex::Literal("swap"), method_20801, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("clear"), method_20802, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >,std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > > -------------------------------
static void constructor_20828( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >();
  else ::new(mem) ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >();
}

static void constructor_20829( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >(*(const ::std::allocator<std::pair<reco::CompositeCandidate,std::vector<int> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >(*(const ::std::allocator<std::pair<reco::CompositeCandidate,std::vector<int> > >*)arg[0]);
}

static void constructor_20830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[1],
      *(const ::std::allocator<std::pair<reco::CompositeCandidate,std::vector<int> > >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[1],
      *(const ::std::allocator<std::pair<reco::CompositeCandidate,std::vector<int> > >*)arg[2]);
  }
}

static void constructor_20831( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >(*(const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >(*(const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)arg[0]);
}

static void destructor_20832(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::~vector)();
}
static  void operator_20833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->operator=)(*(const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)arg[0]);
  else   (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->operator=)(*(const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)arg[0]);
}

static  void method_20834( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[1]);
}

static  void method_20835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >)((((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->begin)());
  else   (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->begin)();
}

static  void method_20836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >)((((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->begin)());
  else   (((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->begin)();
}

static  void method_20837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >)((((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->end)());
  else   (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->end)();
}

static  void method_20838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >)((((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->end)());
  else   (((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->end)();
}

static  void method_20843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->size)());
  else   (((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->size)();
}

static  void method_20844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->max_size)();
}

static  void method_20845( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[1]);
  }
}

static  void method_20846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->capacity)();
}

static  void method_20847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->empty)());
  else   (((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->empty)();
}

static  void method_20848( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20849( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20852( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20853( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->front)();
  else   (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->front)();
}

static  void method_20855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->front)();
  else   (((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->front)();
}

static  void method_20856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->back)();
  else   (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->back)();
}

static  void method_20857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->back)();
  else   (((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->back)();
}

static  void method_20858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->data)());
  else   (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->data)();
}

static  void method_20859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->data)());
  else   (((const ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->data)();
}

static  void method_20860( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->push_back)(*(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[0]);
}

static  void method_20861( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->pop_back)();
}

static  void method_20862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >)((((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0],
    *(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[1]));
  else   (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0],
    *(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[1]);
}

static  void method_20863( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<reco::CompositeCandidate,std::vector<int> >*)arg[2]);
}

static  void method_20864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >)((((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0]));
  else   (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0]);
}

static  void method_20865( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >)((((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[1]));
  else   (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<reco::CompositeCandidate,std::vector<int> >*,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[1]);
}

static  void method_20866( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->swap)(*(::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)arg[0]);
}

static  void method_20867( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)o)->clear)();
}

static void method_newdel_3558( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x32( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<reco::CompositeCandidate,std::vector<int> >,std::allocator<std::pair<reco::CompositeCandidate,std::vector<int> > > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >,::std::_Vector_base<std::pair<reco::CompositeCandidate,std::vector<int> >,std::allocator<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::Generate();
}

//------Dictionary for class vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >,std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > > -------------------------------
void __std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s__datamem_bld(&__std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s__funcmem_bld(&__std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s__db_funcmem);
void __std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >"), typeid(::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >), sizeof(::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2946, ::Reflex::BaseOffset< ::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >, ::std::_Vector_base<std::pair<reco::CompositeCandidate,std::vector<int> >,std::allocator<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3460, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::_Alloc_value_type"))
  .AddTypedef(type_2946, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::_Base"))
  .AddTypedef(type_3983, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::_Tp_alloc_type"))
  .AddTypedef(type_3460, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::value_type"))
  .AddTypedef(type_20813, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::pointer"))
  .AddTypedef(type_20815, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::const_pointer"))
  .AddTypedef(type_20817, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::reference"))
  .AddTypedef(type_20819, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::const_reference"))
  .AddTypedef(type_12121, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::iterator"))
  .AddTypedef(type_12122, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::const_iterator"))
  .AddTypedef(type_4697, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::const_reverse_iterator"))
  .AddTypedef(type_4698, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::reverse_iterator"))
  .AddTypedef(type_3954, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::size_type"))
  .AddTypedef(type_3818, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::difference_type"))
  .AddTypedef(type_3983, Reflex::Literal("std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20828, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59121), Reflex::Literal("vector"), constructor_20829, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3954, type_20819, type_59121), Reflex::Literal("vector"), constructor_20830, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60055), Reflex::Literal("vector"), constructor_20831, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20832, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3558, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x32, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >,std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > > -------------------
void __std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >,std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > > -------------------
void __std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60105, type_60055), Reflex::Literal("operator="), operator_20833, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954, type_20819), Reflex::Literal("assign"), method_20834, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12121), Reflex::Literal("begin"), method_20835, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12122), Reflex::Literal("begin"), method_20836, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12121), Reflex::Literal("end"), method_20837, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12122), Reflex::Literal("end"), method_20838, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("size"), method_20843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("max_size"), method_20844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954, type_3460), Reflex::Literal("resize"), method_20845, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("capacity"), method_20846, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("empty"), method_20847, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954), Reflex::Literal("reserve"), method_20848, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20817, type_3954), Reflex::Literal("operator[]"), operator_20849, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20819, type_3954), Reflex::Literal("operator[]"), operator_20850, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20817, type_3954), Reflex::Literal("at"), method_20852, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20819, type_3954), Reflex::Literal("at"), method_20853, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20817), Reflex::Literal("front"), method_20854, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20819), Reflex::Literal("front"), method_20855, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20817), Reflex::Literal("back"), method_20856, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20819), Reflex::Literal("back"), method_20857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20813), Reflex::Literal("data"), method_20858, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20815), Reflex::Literal("data"), method_20859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_20819), Reflex::Literal("push_back"), method_20860, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("pop_back"), method_20861, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12121, type_12121, type_20819), Reflex::Literal("insert"), method_20862, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_12121, type_3954, type_20819), Reflex::Literal("insert"), method_20863, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12121, type_12121), Reflex::Literal("erase"), method_20864, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12121, type_12121, type_12121), Reflex::Literal("erase"), method_20865, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_60105), Reflex::Literal("swap"), method_20866, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("clear"), method_20867, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >, std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > >,std::less<TtEvent::HypoClassKey>,std::allocator<std::pair<const TtEvent::HypoClassKey, std::vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >, std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > > > > > -------------------------------
static void destructor_30303(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::~map)();
}
static void constructor_30304( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >();
  else ::new(mem) ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >();
}

static void constructor_30305( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >(*(const ::std::less<TtEvent::HypoClassKey>*)arg[0]);
  else ::new(mem) ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >(*(const ::std::less<TtEvent::HypoClassKey>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >(*(const ::std::less<TtEvent::HypoClassKey>*)arg[0],
      *(const ::std::allocator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >*)arg[1]);
  else ::new(mem) ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >(*(const ::std::less<TtEvent::HypoClassKey>*)arg[0],
      *(const ::std::allocator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >*)arg[1]);
  }
}

static void constructor_30306( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >(*(const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0]);
  else ::new(mem) ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >(*(const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0]);
}

static  void operator_30307( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->operator=)(*(const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0]);
  else   (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->operator=)(*(const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0]);
}

static  void method_30308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >)((((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->get_allocator)());
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->get_allocator)();
}

static  void method_30309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >)((((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->begin)());
  else   (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->begin)();
}

static  void method_30310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >)((((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->begin)());
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->begin)();
}

static  void method_30311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >)((((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->end)());
  else   (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->end)();
}

static  void method_30312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >)((((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->end)());
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->end)();
}

static  void method_30317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->empty)());
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->empty)();
}

static  void method_30318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->size)());
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->size)();
}

static  void method_30319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->max_size)());
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->max_size)();
}

static  void operator_30320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->operator[])(*(const ::TtEvent::HypoClassKey*)arg[0]);
  else   (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->operator[])(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->at)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  else   (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->at)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30322( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->at)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->at)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >,bool>)((((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->insert)(*(const ::std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0]));
  else   (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->insert)(*(const ::std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0]);
}

static  void method_30324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >)((((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >*)arg[0],
    *(const ::std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[1]));
  else   (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >*)arg[0],
    *(const ::std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[1]);
}

static  void method_30325( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >*)arg[0]);
}

static  void method_30326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->erase)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->erase)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30327( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >*)arg[1]);
}

static  void method_30328( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->swap)(*(::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0]);
}

static  void method_30329( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->clear)();
}

static  void method_30330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<TtEvent::HypoClassKey>)((((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->key_comp)());
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->key_comp)();
}

static  void method_30332( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >)((((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->find)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->find)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30333( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >)((((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->find)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->find)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30334( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->count)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->count)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >)((((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->lower_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->lower_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30336( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >)((((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->lower_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->lower_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30337( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >)((((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->upper_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->upper_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30338( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >)((((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->upper_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->upper_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30339( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >,std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > > >)((((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->equal_range)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->equal_range)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30340( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >,std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > > >)((((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->equal_range)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->equal_range)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static void method_newdel_3843( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::Generate();
  else ::Reflex::Proxy< ::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::Generate();
}

//------Dictionary for class map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >, std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > >,std::less<TtEvent::HypoClassKey>,std::allocator<std::pair<const TtEvent::HypoClassKey, std::vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >, std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > > > > > -------------------------------
void __std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__db_datamem(Reflex::Class*);
void __std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__datamem_bld(&__std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__funcmem_bld(&__std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__db_funcmem);
void __std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >"), typeid(::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >), sizeof(::std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_13152, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::key_type"))
  .AddTypedef(type_3558, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::mapped_type"))
  .AddTypedef(type_3459, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::value_type"))
  .AddTypedef(type_3126, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::key_compare"))
  .AddTypedef(type_3982, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::allocator_type"))
  .AddTypedef(type_3459, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::_Alloc_value_type"))
  .AddTypedef(type_3982, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::_Pair_alloc_type"))
  .AddTypedef(type_3186, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::_Rep_type"))
  .AddTypedef(type_18360, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::pointer"))
  .AddTypedef(type_18362, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::const_pointer"))
  .AddTypedef(type_18364, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::reference"))
  .AddTypedef(type_18366, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::const_reference"))
  .AddTypedef(type_3787, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::iterator"))
  .AddTypedef(type_3962, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::const_iterator"))
  .AddTypedef(type_3954, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::size_type"))
  .AddTypedef(type_3818, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::difference_type"))
  .AddTypedef(type_4704, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::reverse_iterator"))
  .AddTypedef(type_4703, Reflex::Literal("std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_30303, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_30304, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59694, type_59825), Reflex::Literal("map"), constructor_30305, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60647), Reflex::Literal("map"), constructor_30306, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3843, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >, std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > >,std::less<TtEvent::HypoClassKey>,std::allocator<std::pair<const TtEvent::HypoClassKey, std::vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >, std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > > > > > -------------------
void __std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3186, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >, std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > >,std::less<TtEvent::HypoClassKey>,std::allocator<std::pair<const TtEvent::HypoClassKey, std::vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >, std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > > > > > -------------------
void __std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60648, type_60647), Reflex::Literal("operator="), operator_30307, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3982), Reflex::Literal("get_allocator"), method_30308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3787), Reflex::Literal("begin"), method_30309, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3962), Reflex::Literal("begin"), method_30310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3787), Reflex::Literal("end"), method_30311, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3962), Reflex::Literal("end"), method_30312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("empty"), method_30317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("size"), method_30318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("max_size"), method_30319, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60105, type_46455), Reflex::Literal("operator[]"), operator_30320, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60105, type_46455), Reflex::Literal("at"), method_30321, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60055, type_46455), Reflex::Literal("at"), method_30322, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_18366), Reflex::Literal("insert"), method_30323, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3787, type_3787, type_18366), Reflex::Literal("insert"), method_30324, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3787), Reflex::Literal("erase"), method_30325, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954, type_46455), Reflex::Literal("erase"), method_30326, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3787, type_3787), Reflex::Literal("erase"), method_30327, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_60648), Reflex::Literal("swap"), method_30328, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("clear"), method_30329, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3126), Reflex::Literal("key_comp"), method_30330, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3787, type_46455), Reflex::Literal("find"), method_30332, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3962, type_46455), Reflex::Literal("find"), method_30333, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954, type_46455), Reflex::Literal("count"), method_30334, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3787, type_46455), Reflex::Literal("lower_bound"), method_30335, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3962, type_46455), Reflex::Literal("lower_bound"), method_30336, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3787, type_46455), Reflex::Literal("upper_bound"), method_30337, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3962, type_46455), Reflex::Literal("upper_bound"), method_30338, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3515, type_46455), Reflex::Literal("equal_range"), method_30339, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3514, type_46455), Reflex::Literal("equal_range"), method_30340, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<TtEvent::HypoClassKey,int,std::less<TtEvent::HypoClassKey>,std::allocator<std::pair<const TtEvent::HypoClassKey, int> > > -------------------------------
static void destructor_30361(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<TtEvent::HypoClassKey,int>*)o)->::std::map<TtEvent::HypoClassKey,int>::~map)();
}
static void constructor_30362( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<TtEvent::HypoClassKey,int>();
  else ::new(mem) ::std::map<TtEvent::HypoClassKey,int>();
}

static void constructor_30363( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<TtEvent::HypoClassKey,int>(*(const ::std::less<TtEvent::HypoClassKey>*)arg[0]);
  else ::new(mem) ::std::map<TtEvent::HypoClassKey,int>(*(const ::std::less<TtEvent::HypoClassKey>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<TtEvent::HypoClassKey,int>(*(const ::std::less<TtEvent::HypoClassKey>*)arg[0],
      *(const ::std::allocator<std::pair<const TtEvent::HypoClassKey,int> >*)arg[1]);
  else ::new(mem) ::std::map<TtEvent::HypoClassKey,int>(*(const ::std::less<TtEvent::HypoClassKey>*)arg[0],
      *(const ::std::allocator<std::pair<const TtEvent::HypoClassKey,int> >*)arg[1]);
  }
}

static void constructor_30364( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<TtEvent::HypoClassKey,int>(*(const ::std::map<TtEvent::HypoClassKey,int>*)arg[0]);
  else ::new(mem) ::std::map<TtEvent::HypoClassKey,int>(*(const ::std::map<TtEvent::HypoClassKey,int>*)arg[0]);
}

static  void operator_30365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<TtEvent::HypoClassKey,int>*)o)->operator=)(*(const ::std::map<TtEvent::HypoClassKey,int>*)arg[0]);
  else   (((::std::map<TtEvent::HypoClassKey,int>*)o)->operator=)(*(const ::std::map<TtEvent::HypoClassKey,int>*)arg[0]);
}

static  void method_30366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const TtEvent::HypoClassKey,int> >)((((const ::std::map<TtEvent::HypoClassKey,int>*)o)->get_allocator)());
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->get_allocator)();
}

static  void method_30367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >)((((::std::map<TtEvent::HypoClassKey,int>*)o)->begin)());
  else   (((::std::map<TtEvent::HypoClassKey,int>*)o)->begin)();
}

static  void method_30368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,int> >)((((const ::std::map<TtEvent::HypoClassKey,int>*)o)->begin)());
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->begin)();
}

static  void method_30369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >)((((::std::map<TtEvent::HypoClassKey,int>*)o)->end)());
  else   (((::std::map<TtEvent::HypoClassKey,int>*)o)->end)();
}

static  void method_30370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,int> >)((((const ::std::map<TtEvent::HypoClassKey,int>*)o)->end)());
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->end)();
}

static  void method_30375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<TtEvent::HypoClassKey,int>*)o)->empty)());
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->empty)();
}

static  void method_30376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<TtEvent::HypoClassKey,int>*)o)->size)());
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->size)();
}

static  void method_30377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<TtEvent::HypoClassKey,int>*)o)->max_size)());
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->max_size)();
}

static  void operator_30378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<TtEvent::HypoClassKey,int>*)o)->operator[])(*(const ::TtEvent::HypoClassKey*)arg[0]);
  else   (((::std::map<TtEvent::HypoClassKey,int>*)o)->operator[])(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<TtEvent::HypoClassKey,int>*)o)->at)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  else   (((::std::map<TtEvent::HypoClassKey,int>*)o)->at)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<TtEvent::HypoClassKey,int>*)o)->at)(*(const ::TtEvent::HypoClassKey*)arg[0]);
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->at)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >,bool>)((((::std::map<TtEvent::HypoClassKey,int>*)o)->insert)(*(const ::std::pair<const TtEvent::HypoClassKey,int>*)arg[0]));
  else   (((::std::map<TtEvent::HypoClassKey,int>*)o)->insert)(*(const ::std::pair<const TtEvent::HypoClassKey,int>*)arg[0]);
}

static  void method_30382( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >)((((::std::map<TtEvent::HypoClassKey,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >*)arg[0],
    *(const ::std::pair<const TtEvent::HypoClassKey,int>*)arg[1]));
  else   (((::std::map<TtEvent::HypoClassKey,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >*)arg[0],
    *(const ::std::pair<const TtEvent::HypoClassKey,int>*)arg[1]);
}

static  void method_30383( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<TtEvent::HypoClassKey,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >*)arg[0]);
}

static  void method_30384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<TtEvent::HypoClassKey,int>*)o)->erase)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((::std::map<TtEvent::HypoClassKey,int>*)o)->erase)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30385( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<TtEvent::HypoClassKey,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >*)arg[1]);
}

static  void method_30386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<TtEvent::HypoClassKey,int>*)o)->swap)(*(::std::map<TtEvent::HypoClassKey,int>*)arg[0]);
}

static  void method_30387( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<TtEvent::HypoClassKey,int>*)o)->clear)();
}

static  void method_30388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<TtEvent::HypoClassKey>)((((const ::std::map<TtEvent::HypoClassKey,int>*)o)->key_comp)());
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->key_comp)();
}

static  void method_30390( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >)((((::std::map<TtEvent::HypoClassKey,int>*)o)->find)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((::std::map<TtEvent::HypoClassKey,int>*)o)->find)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,int> >)((((const ::std::map<TtEvent::HypoClassKey,int>*)o)->find)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->find)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30392( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<TtEvent::HypoClassKey,int>*)o)->count)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->count)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30393( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >)((((::std::map<TtEvent::HypoClassKey,int>*)o)->lower_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((::std::map<TtEvent::HypoClassKey,int>*)o)->lower_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30394( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,int> >)((((const ::std::map<TtEvent::HypoClassKey,int>*)o)->lower_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->lower_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30395( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >)((((::std::map<TtEvent::HypoClassKey,int>*)o)->upper_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((::std::map<TtEvent::HypoClassKey,int>*)o)->upper_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,int> >)((((const ::std::map<TtEvent::HypoClassKey,int>*)o)->upper_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->upper_bound)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30397( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> >,std::_Rb_tree_iterator<std::pair<const TtEvent::HypoClassKey,int> > >)((((::std::map<TtEvent::HypoClassKey,int>*)o)->equal_range)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((::std::map<TtEvent::HypoClassKey,int>*)o)->equal_range)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static  void method_30398( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,int> >,std::_Rb_tree_const_iterator<std::pair<const TtEvent::HypoClassKey,int> > >)((((const ::std::map<TtEvent::HypoClassKey,int>*)o)->equal_range)(*(const ::TtEvent::HypoClassKey*)arg[0]));
  else   (((const ::std::map<TtEvent::HypoClassKey,int>*)o)->equal_range)(*(const ::TtEvent::HypoClassKey*)arg[0]);
}

static void method_newdel_3844( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<TtEvent::HypoClassKey,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<TtEvent::HypoClassKey,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<TtEvent::HypoClassKey,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<TtEvent::HypoClassKey,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<TtEvent::HypoClassKey,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<TtEvent::HypoClassKey,int> >::Generate();
  else ::Reflex::Proxy< ::std::map<TtEvent::HypoClassKey,int> >::Generate();
}

//------Dictionary for class map<TtEvent::HypoClassKey,int,std::less<TtEvent::HypoClassKey>,std::allocator<std::pair<const TtEvent::HypoClassKey, int> > > -------------------------------
void __std__map_TtEvent__HypoClassKey_int__db_datamem(Reflex::Class*);
void __std__map_TtEvent__HypoClassKey_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_TtEvent__HypoClassKey_int__datamem_bld(&__std__map_TtEvent__HypoClassKey_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_TtEvent__HypoClassKey_int__funcmem_bld(&__std__map_TtEvent__HypoClassKey_int__db_funcmem);
void __std__map_TtEvent__HypoClassKey_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<TtEvent::HypoClassKey,int>"), typeid(::std::map<TtEvent::HypoClassKey,int>), sizeof(::std::map<TtEvent::HypoClassKey,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_13152, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::key_type"))
  .AddTypedef(type_74, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::mapped_type"))
  .AddTypedef(type_3461, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::value_type"))
  .AddTypedef(type_3126, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::key_compare"))
  .AddTypedef(type_3985, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::allocator_type"))
  .AddTypedef(type_3461, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::_Alloc_value_type"))
  .AddTypedef(type_3985, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::_Pair_alloc_type"))
  .AddTypedef(type_3185, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::_Rep_type"))
  .AddTypedef(type_18255, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::pointer"))
  .AddTypedef(type_18257, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::const_pointer"))
  .AddTypedef(type_18259, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::reference"))
  .AddTypedef(type_18261, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::const_reference"))
  .AddTypedef(type_3786, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::iterator"))
  .AddTypedef(type_3961, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::const_iterator"))
  .AddTypedef(type_3954, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::size_type"))
  .AddTypedef(type_3818, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::difference_type"))
  .AddTypedef(type_4702, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::reverse_iterator"))
  .AddTypedef(type_4701, Reflex::Literal("std::map<TtEvent::HypoClassKey,int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_30361, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_30362, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59694, type_59817), Reflex::Literal("map"), constructor_30363, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60649), Reflex::Literal("map"), constructor_30364, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3844, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_TtEvent__HypoClassKey_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_TtEvent__HypoClassKey_int__funcmem_bld);
}

//------Delayed data member builder for class map<TtEvent::HypoClassKey,int,std::less<TtEvent::HypoClassKey>,std::allocator<std::pair<const TtEvent::HypoClassKey, int> > > -------------------
void __std__map_TtEvent__HypoClassKey_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3185, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_TtEvent__HypoClassKey_int_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<TtEvent::HypoClassKey,int,std::less<TtEvent::HypoClassKey>,std::allocator<std::pair<const TtEvent::HypoClassKey, int> > > -------------------
void __std__map_TtEvent__HypoClassKey_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60650, type_60649), Reflex::Literal("operator="), operator_30365, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3985), Reflex::Literal("get_allocator"), method_30366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3786), Reflex::Literal("begin"), method_30367, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3961), Reflex::Literal("begin"), method_30368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3786), Reflex::Literal("end"), method_30369, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3961), Reflex::Literal("end"), method_30370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("empty"), method_30375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("size"), method_30376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("max_size"), method_30377, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16659, type_46455), Reflex::Literal("operator[]"), operator_30378, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16659, type_46455), Reflex::Literal("at"), method_30379, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16670, type_46455), Reflex::Literal("at"), method_30380, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3513, type_18261), Reflex::Literal("insert"), method_30381, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3786, type_3786, type_18261), Reflex::Literal("insert"), method_30382, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3786), Reflex::Literal("erase"), method_30383, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954, type_46455), Reflex::Literal("erase"), method_30384, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3786, type_3786), Reflex::Literal("erase"), method_30385, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_60650), Reflex::Literal("swap"), method_30386, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("clear"), method_30387, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3126), Reflex::Literal("key_comp"), method_30388, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3786, type_46455), Reflex::Literal("find"), method_30390, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3961, type_46455), Reflex::Literal("find"), method_30391, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954, type_46455), Reflex::Literal("count"), method_30392, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3786, type_46455), Reflex::Literal("lower_bound"), method_30393, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3961, type_46455), Reflex::Literal("lower_bound"), method_30394, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3786, type_46455), Reflex::Literal("upper_bound"), method_30395, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3961, type_46455), Reflex::Literal("upper_bound"), method_30396, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3512, type_46455), Reflex::Literal("equal_range"), method_30397, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3511, type_46455), Reflex::Literal("equal_range"), method_30398, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<StEvtSolution, std::allocator<StEvtSolution> > > -------------------------------
static void constructor_37806( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<StEvtSolution> >();
  else ::new(mem) ::edm::Wrapper<std::vector<StEvtSolution> >();
}

static void constructor_37807( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<StEvtSolution> >(*(::std::auto_ptr<std::vector<StEvtSolution> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<StEvtSolution> >(*(::std::auto_ptr<std::vector<StEvtSolution> >*)arg[0]);
}

static void destructor_37808(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<StEvtSolution> >*)o)->::edm::Wrapper<std::vector<StEvtSolution> >::~Wrapper)();
}
static  void method_37809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->product)();
}

static  void operator_37810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->operator->)();
}

static  void method_37811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<StEvtSolution> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<StEvtSolution> >*)o)->productTypeInfo)();
}

static  void method_37812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<StEvtSolution> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<StEvtSolution> >*)o)->typeInfo)();
}

static void constructor_37813( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<StEvtSolution> >((::std::vector<StEvtSolution>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<StEvtSolution> >((::std::vector<StEvtSolution>*)arg[0]);
}

static  void method_37814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<StEvtSolution> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<StEvtSolution> >*)o)->getInterface)();
}

static  void method_37815( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_37816( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_37817( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_37818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->dynamicTypeInfo)();
}

static  void method_37819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->isPresent)();
}

static  void method_37820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<StEvtSolution> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6256( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<StEvtSolution> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<StEvtSolution> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<StEvtSolution> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<StEvtSolution> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<StEvtSolution> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<StEvtSolution, std::allocator<StEvtSolution> > > -------------------------------
void __edm__Wrapper_std__vector_StEvtSolution_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_StEvtSolution_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_StEvtSolution_s__datamem_bld(&__edm__Wrapper_std__vector_StEvtSolution_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_StEvtSolution_s__funcmem_bld(&__edm__Wrapper_std__vector_StEvtSolution_s__db_funcmem);
void __edm__Wrapper_std__vector_StEvtSolution_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<StEvtSolution> >"), typeid(::edm::Wrapper<std::vector<StEvtSolution> >), sizeof(::edm::Wrapper<std::vector<StEvtSolution> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3554, Reflex::Literal("edm::Wrapper<std::vector<StEvtSolution> >::value_type"))
  .AddTypedef(type_3554, Reflex::Literal("edm::Wrapper<std::vector<StEvtSolution> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_37806, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3242), Reflex::Literal("Wrapper"), constructor_37807, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_37808, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62999), Reflex::Literal("Wrapper"), constructor_37813, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6256, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_StEvtSolution_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_StEvtSolution_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<StEvtSolution, std::allocator<StEvtSolution> > > -------------------
void __edm__Wrapper_std__vector_StEvtSolution_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_StEvtSolution_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3554, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_StEvtSolution_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<StEvtSolution, std::allocator<StEvtSolution> > > -------------------
void __edm__Wrapper_std__vector_StEvtSolution_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62998), Reflex::Literal("product"), method_37809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62998), Reflex::Literal("operator->"), operator_37810, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_37811, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_37812, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63000), Reflex::Literal("getInterface"), method_37814, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_37815, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_37816, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_37817, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_37818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_37819, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_37820, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<TtHadEvtSolution, std::allocator<TtHadEvtSolution> > > -------------------------------
static void constructor_37827( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<TtHadEvtSolution> >();
  else ::new(mem) ::edm::Wrapper<std::vector<TtHadEvtSolution> >();
}

static void constructor_37828( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<TtHadEvtSolution> >(*(::std::auto_ptr<std::vector<TtHadEvtSolution> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<TtHadEvtSolution> >(*(::std::auto_ptr<std::vector<TtHadEvtSolution> >*)arg[0]);
}

static void destructor_37829(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->::edm::Wrapper<std::vector<TtHadEvtSolution> >::~Wrapper)();
}
static  void method_37830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->product)();
}

static  void operator_37831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->operator->)();
}

static  void method_37832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->productTypeInfo)();
}

static  void method_37833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->typeInfo)();
}

static void constructor_37834( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<TtHadEvtSolution> >((::std::vector<TtHadEvtSolution>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<TtHadEvtSolution> >((::std::vector<TtHadEvtSolution>*)arg[0]);
}

static  void method_37835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->getInterface)();
}

static  void method_37836( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_37837( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_37838( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_37839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->dynamicTypeInfo)();
}

static  void method_37840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->isPresent)();
}

static  void method_37841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<TtHadEvtSolution> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6257( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtHadEvtSolution> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtHadEvtSolution> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtHadEvtSolution> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtHadEvtSolution> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtHadEvtSolution> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<TtHadEvtSolution, std::allocator<TtHadEvtSolution> > > -------------------------------
void __edm__Wrapper_std__vector_TtHadEvtSolution_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_TtHadEvtSolution_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_TtHadEvtSolution_s__datamem_bld(&__edm__Wrapper_std__vector_TtHadEvtSolution_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_TtHadEvtSolution_s__funcmem_bld(&__edm__Wrapper_std__vector_TtHadEvtSolution_s__db_funcmem);
void __edm__Wrapper_std__vector_TtHadEvtSolution_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<TtHadEvtSolution> >"), typeid(::edm::Wrapper<std::vector<TtHadEvtSolution> >), sizeof(::edm::Wrapper<std::vector<TtHadEvtSolution> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3555, Reflex::Literal("edm::Wrapper<std::vector<TtHadEvtSolution> >::value_type"))
  .AddTypedef(type_3555, Reflex::Literal("edm::Wrapper<std::vector<TtHadEvtSolution> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_37827, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3243), Reflex::Literal("Wrapper"), constructor_37828, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_37829, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63004), Reflex::Literal("Wrapper"), constructor_37834, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6257, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_TtHadEvtSolution_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_TtHadEvtSolution_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<TtHadEvtSolution, std::allocator<TtHadEvtSolution> > > -------------------
void __edm__Wrapper_std__vector_TtHadEvtSolution_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_TtHadEvtSolution_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3555, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_TtHadEvtSolution_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<TtHadEvtSolution, std::allocator<TtHadEvtSolution> > > -------------------
void __edm__Wrapper_std__vector_TtHadEvtSolution_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63003), Reflex::Literal("product"), method_37830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63003), Reflex::Literal("operator->"), operator_37831, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_37832, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_37833, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63005), Reflex::Literal("getInterface"), method_37835, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_37836, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_37837, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_37838, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_37839, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_37840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_37841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<TtSemiEvtSolution, std::allocator<TtSemiEvtSolution> > > -------------------------------
static void constructor_37848( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<TtSemiEvtSolution> >();
  else ::new(mem) ::edm::Wrapper<std::vector<TtSemiEvtSolution> >();
}

static void constructor_37849( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<TtSemiEvtSolution> >(*(::std::auto_ptr<std::vector<TtSemiEvtSolution> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<TtSemiEvtSolution> >(*(::std::auto_ptr<std::vector<TtSemiEvtSolution> >*)arg[0]);
}

static void destructor_37850(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->::edm::Wrapper<std::vector<TtSemiEvtSolution> >::~Wrapper)();
}
static  void method_37851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->product)();
}

static  void operator_37852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->operator->)();
}

static  void method_37853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->productTypeInfo)();
}

static  void method_37854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->typeInfo)();
}

static void constructor_37855( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<TtSemiEvtSolution> >((::std::vector<TtSemiEvtSolution>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<TtSemiEvtSolution> >((::std::vector<TtSemiEvtSolution>*)arg[0]);
}

static  void method_37856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->getInterface)();
}

static  void method_37857( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_37858( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_37859( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_37860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->dynamicTypeInfo)();
}

static  void method_37861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->isPresent)();
}

static  void method_37862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<TtSemiEvtSolution> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6258( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtSemiEvtSolution> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtSemiEvtSolution> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtSemiEvtSolution> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtSemiEvtSolution> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtSemiEvtSolution> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<TtSemiEvtSolution, std::allocator<TtSemiEvtSolution> > > -------------------------------
void __edm__Wrapper_std__vector_TtSemiEvtSolution_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_TtSemiEvtSolution_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_TtSemiEvtSolution_s__datamem_bld(&__edm__Wrapper_std__vector_TtSemiEvtSolution_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_TtSemiEvtSolution_s__funcmem_bld(&__edm__Wrapper_std__vector_TtSemiEvtSolution_s__db_funcmem);
void __edm__Wrapper_std__vector_TtSemiEvtSolution_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<TtSemiEvtSolution> >"), typeid(::edm::Wrapper<std::vector<TtSemiEvtSolution> >), sizeof(::edm::Wrapper<std::vector<TtSemiEvtSolution> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3556, Reflex::Literal("edm::Wrapper<std::vector<TtSemiEvtSolution> >::value_type"))
  .AddTypedef(type_3556, Reflex::Literal("edm::Wrapper<std::vector<TtSemiEvtSolution> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_37848, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3244), Reflex::Literal("Wrapper"), constructor_37849, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_37850, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63009), Reflex::Literal("Wrapper"), constructor_37855, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6258, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_TtSemiEvtSolution_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_TtSemiEvtSolution_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<TtSemiEvtSolution, std::allocator<TtSemiEvtSolution> > > -------------------
void __edm__Wrapper_std__vector_TtSemiEvtSolution_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_TtSemiEvtSolution_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3556, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_TtSemiEvtSolution_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<TtSemiEvtSolution, std::allocator<TtSemiEvtSolution> > > -------------------
void __edm__Wrapper_std__vector_TtSemiEvtSolution_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63008), Reflex::Literal("product"), method_37851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63008), Reflex::Literal("operator->"), operator_37852, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_37853, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_37854, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63010), Reflex::Literal("getInterface"), method_37856, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_37857, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_37858, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_37859, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_37860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_37861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_37862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<TtDilepEvtSolution, std::allocator<TtDilepEvtSolution> > > -------------------------------
static void constructor_37869( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<TtDilepEvtSolution> >();
  else ::new(mem) ::edm::Wrapper<std::vector<TtDilepEvtSolution> >();
}

static void constructor_37870( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<TtDilepEvtSolution> >(*(::std::auto_ptr<std::vector<TtDilepEvtSolution> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<TtDilepEvtSolution> >(*(::std::auto_ptr<std::vector<TtDilepEvtSolution> >*)arg[0]);
}

static void destructor_37871(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->::edm::Wrapper<std::vector<TtDilepEvtSolution> >::~Wrapper)();
}
static  void method_37872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->product)();
}

static  void operator_37873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->operator->)();
}

static  void method_37874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->productTypeInfo)();
}

static  void method_37875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->typeInfo)();
}

static void constructor_37876( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<TtDilepEvtSolution> >((::std::vector<TtDilepEvtSolution>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<TtDilepEvtSolution> >((::std::vector<TtDilepEvtSolution>*)arg[0]);
}

static  void method_37877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->getInterface)();
}

static  void method_37878( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_37879( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_37880( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_37881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->dynamicTypeInfo)();
}

static  void method_37882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->isPresent)();
}

static  void method_37883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<TtDilepEvtSolution> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6259( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtDilepEvtSolution> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtDilepEvtSolution> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtDilepEvtSolution> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtDilepEvtSolution> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TtDilepEvtSolution> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<TtDilepEvtSolution, std::allocator<TtDilepEvtSolution> > > -------------------------------
void __edm__Wrapper_std__vector_TtDilepEvtSolution_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_TtDilepEvtSolution_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_TtDilepEvtSolution_s__datamem_bld(&__edm__Wrapper_std__vector_TtDilepEvtSolution_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_TtDilepEvtSolution_s__funcmem_bld(&__edm__Wrapper_std__vector_TtDilepEvtSolution_s__db_funcmem);
void __edm__Wrapper_std__vector_TtDilepEvtSolution_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<TtDilepEvtSolution> >"), typeid(::edm::Wrapper<std::vector<TtDilepEvtSolution> >), sizeof(::edm::Wrapper<std::vector<TtDilepEvtSolution> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3557, Reflex::Literal("edm::Wrapper<std::vector<TtDilepEvtSolution> >::value_type"))
  .AddTypedef(type_3557, Reflex::Literal("edm::Wrapper<std::vector<TtDilepEvtSolution> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_37869, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3245), Reflex::Literal("Wrapper"), constructor_37870, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_37871, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63014), Reflex::Literal("Wrapper"), constructor_37876, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6259, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_TtDilepEvtSolution_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_TtDilepEvtSolution_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<TtDilepEvtSolution, std::allocator<TtDilepEvtSolution> > > -------------------
void __edm__Wrapper_std__vector_TtDilepEvtSolution_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_TtDilepEvtSolution_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3557, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_TtDilepEvtSolution_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<TtDilepEvtSolution, std::allocator<TtDilepEvtSolution> > > -------------------
void __edm__Wrapper_std__vector_TtDilepEvtSolution_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63013), Reflex::Literal("product"), method_37872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63013), Reflex::Literal("operator->"), operator_37873, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_37874, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_37875, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63015), Reflex::Literal("getInterface"), method_37877, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_37878, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_37879, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_37880, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_37881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_37882, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_37883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >, std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > > > -------------------------------
static void constructor_37890( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >();
  else ::new(mem) ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >();
}

static void constructor_37891( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >(*(::std::auto_ptr<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >(*(::std::auto_ptr<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)arg[0]);
}

static void destructor_37892(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::~Wrapper)();
}
static  void method_37893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->product)();
}

static  void operator_37894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->operator->)();
}

static  void method_37895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->productTypeInfo)();
}

static  void method_37896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->typeInfo)();
}

static void constructor_37897( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >((::std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > >*)arg[0]);
}

static  void method_37898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->getInterface)();
}

static  void method_37899( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_37900( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_37901( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_37902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->dynamicTypeInfo)();
}

static  void method_37903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->isPresent)();
}

static  void method_37904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6260( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >, std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > > > -------------------------------
void __edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__datamem_bld(&__edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__funcmem_bld(&__edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__db_funcmem);
void __edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >"), typeid(::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >), sizeof(::edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3558, Reflex::Literal("edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::value_type"))
  .AddTypedef(type_3558, Reflex::Literal("edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_37890, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3246), Reflex::Literal("Wrapper"), constructor_37891, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_37892, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63019), Reflex::Literal("Wrapper"), constructor_37897, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6260, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >, std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > > > -------------------
void __edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3558, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > >, std::allocator<std::pair<reco::CompositeCandidate, std::vector<int, std::allocator<int> > > > > > -------------------
void __edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63018), Reflex::Literal("product"), method_37893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63018), Reflex::Literal("operator->"), operator_37894, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_37895, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_37896, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63020), Reflex::Literal("getInterface"), method_37898, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_37899, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_37900, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_37901, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_37902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_37903, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_37904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::CompositeCandidate> -------------------------------
static void constructor_37911( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::CompositeCandidate>();
  else ::new(mem) ::edm::Wrapper<reco::CompositeCandidate>();
}

static void constructor_37912( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::CompositeCandidate>(*(::std::auto_ptr<reco::CompositeCandidate>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::CompositeCandidate>(*(::std::auto_ptr<reco::CompositeCandidate>*)arg[0]);
}

static void destructor_37913(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::CompositeCandidate>*)o)->::edm::Wrapper<reco::CompositeCandidate>::~Wrapper)();
}
static  void method_37914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->product)();
}

static  void operator_37915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->operator->)();
}

static  void method_37916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::CompositeCandidate>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::CompositeCandidate>*)o)->productTypeInfo)();
}

static  void method_37917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::CompositeCandidate>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::CompositeCandidate>*)o)->typeInfo)();
}

static void constructor_37918( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::CompositeCandidate>((::reco::CompositeCandidate*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::CompositeCandidate>((::reco::CompositeCandidate*)arg[0]);
}

static  void method_37919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::CompositeCandidate>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::CompositeCandidate>*)o)->getInterface)();
}

static  void method_37920( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_37921( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_37922( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_37923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->dynamicTypeInfo)();
}

static  void method_37924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->isPresent)();
}

static  void method_37925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::CompositeCandidate>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6261( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CompositeCandidate> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CompositeCandidate> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CompositeCandidate> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CompositeCandidate> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CompositeCandidate> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::CompositeCandidate> -------------------------------
void __edm__Wrapper_reco__CompositeCandidate__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__CompositeCandidate__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__CompositeCandidate__datamem_bld(&__edm__Wrapper_reco__CompositeCandidate__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__CompositeCandidate__funcmem_bld(&__edm__Wrapper_reco__CompositeCandidate__db_funcmem);
void __edm__Wrapper_reco__CompositeCandidate__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::CompositeCandidate>"), typeid(::edm::Wrapper<reco::CompositeCandidate>), sizeof(::edm::Wrapper<reco::CompositeCandidate>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_11644, Reflex::Literal("edm::Wrapper<reco::CompositeCandidate>::value_type"))
  .AddTypedef(type_11644, Reflex::Literal("edm::Wrapper<reco::CompositeCandidate>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_37911, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3247), Reflex::Literal("Wrapper"), constructor_37912, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_37913, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28825), Reflex::Literal("Wrapper"), constructor_37918, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6261, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__CompositeCandidate__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__CompositeCandidate__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::CompositeCandidate> -------------------
void __edm__Wrapper_reco__CompositeCandidate__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__CompositeCandidate_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_11644, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__CompositeCandidate_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::CompositeCandidate> -------------------
void __edm__Wrapper_reco__CompositeCandidate__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28827), Reflex::Literal("product"), method_37914, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28827), Reflex::Literal("operator->"), operator_37915, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_37916, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_37917, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63023), Reflex::Literal("getInterface"), method_37919, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_37920, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_37921, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_37922, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_37923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_37924, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_37925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TtFullHadronicEvent> -------------------------------
static void constructor_37932( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TtFullHadronicEvent>();
  else ::new(mem) ::edm::Wrapper<TtFullHadronicEvent>();
}

static void constructor_37933( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TtFullHadronicEvent>(*(::std::auto_ptr<TtFullHadronicEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TtFullHadronicEvent>(*(::std::auto_ptr<TtFullHadronicEvent>*)arg[0]);
}

static void destructor_37934(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TtFullHadronicEvent>*)o)->::edm::Wrapper<TtFullHadronicEvent>::~Wrapper)();
}
static  void method_37935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->product)();
}

static  void operator_37936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->operator->)();
}

static  void method_37937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TtFullHadronicEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TtFullHadronicEvent>*)o)->productTypeInfo)();
}

static  void method_37938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TtFullHadronicEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<TtFullHadronicEvent>*)o)->typeInfo)();
}

static void constructor_37939( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TtFullHadronicEvent>((::TtFullHadronicEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TtFullHadronicEvent>((::TtFullHadronicEvent*)arg[0]);
}

static  void method_37940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TtFullHadronicEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<TtFullHadronicEvent>*)o)->getInterface)();
}

static  void method_37941( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_37942( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_37943( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_37944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->dynamicTypeInfo)();
}

static  void method_37945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->isPresent)();
}

static  void method_37946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TtFullHadronicEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6262( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtFullHadronicEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtFullHadronicEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtFullHadronicEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtFullHadronicEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtFullHadronicEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TtFullHadronicEvent> -------------------------------
void __edm__Wrapper_TtFullHadronicEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_TtFullHadronicEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TtFullHadronicEvent__datamem_bld(&__edm__Wrapper_TtFullHadronicEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TtFullHadronicEvent__funcmem_bld(&__edm__Wrapper_TtFullHadronicEvent__db_funcmem);
void __edm__Wrapper_TtFullHadronicEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TtFullHadronicEvent>"), typeid(::edm::Wrapper<TtFullHadronicEvent>), sizeof(::edm::Wrapper<TtFullHadronicEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1100, Reflex::Literal("edm::Wrapper<TtFullHadronicEvent>::value_type"))
  .AddTypedef(type_1100, Reflex::Literal("edm::Wrapper<TtFullHadronicEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_37932, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3248), Reflex::Literal("Wrapper"), constructor_37933, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_37934, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63027), Reflex::Literal("Wrapper"), constructor_37939, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6262, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TtFullHadronicEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TtFullHadronicEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TtFullHadronicEvent> -------------------
void __edm__Wrapper_TtFullHadronicEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TtFullHadronicEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1100, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TtFullHadronicEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TtFullHadronicEvent> -------------------
void __edm__Wrapper_TtFullHadronicEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63026), Reflex::Literal("product"), method_37935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63026), Reflex::Literal("operator->"), operator_37936, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_37937, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_37938, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63028), Reflex::Literal("getInterface"), method_37940, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_37941, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_37942, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_37943, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_37944, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_37945, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_37946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TtSemiLeptonicEvent> -------------------------------
static void constructor_37953( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TtSemiLeptonicEvent>();
  else ::new(mem) ::edm::Wrapper<TtSemiLeptonicEvent>();
}

static void constructor_37954( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TtSemiLeptonicEvent>(*(::std::auto_ptr<TtSemiLeptonicEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TtSemiLeptonicEvent>(*(::std::auto_ptr<TtSemiLeptonicEvent>*)arg[0]);
}

static void destructor_37955(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TtSemiLeptonicEvent>*)o)->::edm::Wrapper<TtSemiLeptonicEvent>::~Wrapper)();
}
static  void method_37956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->product)();
}

static  void operator_37957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->operator->)();
}

static  void method_37958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TtSemiLeptonicEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TtSemiLeptonicEvent>*)o)->productTypeInfo)();
}

static  void method_37959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TtSemiLeptonicEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<TtSemiLeptonicEvent>*)o)->typeInfo)();
}

static void constructor_37960( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TtSemiLeptonicEvent>((::TtSemiLeptonicEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TtSemiLeptonicEvent>((::TtSemiLeptonicEvent*)arg[0]);
}

static  void method_37961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TtSemiLeptonicEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<TtSemiLeptonicEvent>*)o)->getInterface)();
}

static  void method_37962( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_37963( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_37964( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_37965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->dynamicTypeInfo)();
}

static  void method_37966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->isPresent)();
}

static  void method_37967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TtSemiLeptonicEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6263( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtSemiLeptonicEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtSemiLeptonicEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtSemiLeptonicEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtSemiLeptonicEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtSemiLeptonicEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TtSemiLeptonicEvent> -------------------------------
void __edm__Wrapper_TtSemiLeptonicEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_TtSemiLeptonicEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TtSemiLeptonicEvent__datamem_bld(&__edm__Wrapper_TtSemiLeptonicEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TtSemiLeptonicEvent__funcmem_bld(&__edm__Wrapper_TtSemiLeptonicEvent__db_funcmem);
void __edm__Wrapper_TtSemiLeptonicEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TtSemiLeptonicEvent>"), typeid(::edm::Wrapper<TtSemiLeptonicEvent>), sizeof(::edm::Wrapper<TtSemiLeptonicEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1227, Reflex::Literal("edm::Wrapper<TtSemiLeptonicEvent>::value_type"))
  .AddTypedef(type_1227, Reflex::Literal("edm::Wrapper<TtSemiLeptonicEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_37953, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3249), Reflex::Literal("Wrapper"), constructor_37954, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_37955, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63032), Reflex::Literal("Wrapper"), constructor_37960, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6263, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TtSemiLeptonicEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TtSemiLeptonicEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TtSemiLeptonicEvent> -------------------
void __edm__Wrapper_TtSemiLeptonicEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TtSemiLeptonicEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1227, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TtSemiLeptonicEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TtSemiLeptonicEvent> -------------------
void __edm__Wrapper_TtSemiLeptonicEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63031), Reflex::Literal("product"), method_37956, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63031), Reflex::Literal("operator->"), operator_37957, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_37958, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_37959, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63033), Reflex::Literal("getInterface"), method_37961, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_37962, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_37963, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_37964, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_37965, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_37966, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_37967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TtFullLeptonicEvent> -------------------------------
static void constructor_37974( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TtFullLeptonicEvent>();
  else ::new(mem) ::edm::Wrapper<TtFullLeptonicEvent>();
}

static void constructor_37975( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TtFullLeptonicEvent>(*(::std::auto_ptr<TtFullLeptonicEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TtFullLeptonicEvent>(*(::std::auto_ptr<TtFullLeptonicEvent>*)arg[0]);
}

static void destructor_37976(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TtFullLeptonicEvent>*)o)->::edm::Wrapper<TtFullLeptonicEvent>::~Wrapper)();
}
static  void method_37977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->product)();
}

static  void operator_37978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->operator->)();
}

static  void method_37979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TtFullLeptonicEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TtFullLeptonicEvent>*)o)->productTypeInfo)();
}

static  void method_37980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TtFullLeptonicEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<TtFullLeptonicEvent>*)o)->typeInfo)();
}

static void constructor_37981( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TtFullLeptonicEvent>((::TtFullLeptonicEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TtFullLeptonicEvent>((::TtFullLeptonicEvent*)arg[0]);
}

static  void method_37982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TtFullLeptonicEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<TtFullLeptonicEvent>*)o)->getInterface)();
}

static  void method_37983( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_37984( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_37985( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_37986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->dynamicTypeInfo)();
}

static  void method_37987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->isPresent)();
}

static  void method_37988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TtFullLeptonicEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6264( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtFullLeptonicEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtFullLeptonicEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtFullLeptonicEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtFullLeptonicEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtFullLeptonicEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TtFullLeptonicEvent> -------------------------------
void __edm__Wrapper_TtFullLeptonicEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_TtFullLeptonicEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TtFullLeptonicEvent__datamem_bld(&__edm__Wrapper_TtFullLeptonicEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TtFullLeptonicEvent__funcmem_bld(&__edm__Wrapper_TtFullLeptonicEvent__db_funcmem);
void __edm__Wrapper_TtFullLeptonicEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TtFullLeptonicEvent>"), typeid(::edm::Wrapper<TtFullLeptonicEvent>), sizeof(::edm::Wrapper<TtFullLeptonicEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2790, Reflex::Literal("edm::Wrapper<TtFullLeptonicEvent>::value_type"))
  .AddTypedef(type_2790, Reflex::Literal("edm::Wrapper<TtFullLeptonicEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_37974, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3250), Reflex::Literal("Wrapper"), constructor_37975, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_37976, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63037), Reflex::Literal("Wrapper"), constructor_37981, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6264, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TtFullLeptonicEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TtFullLeptonicEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TtFullLeptonicEvent> -------------------
void __edm__Wrapper_TtFullLeptonicEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TtFullLeptonicEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2790, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TtFullLeptonicEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TtFullLeptonicEvent> -------------------
void __edm__Wrapper_TtFullLeptonicEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63036), Reflex::Literal("product"), method_37977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63036), Reflex::Literal("operator->"), operator_37978, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_37979, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_37980, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63038), Reflex::Literal("getInterface"), method_37982, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_37983, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_37984, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_37985, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_37986, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_37987, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_37988, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TopGenEvent> -------------------------------
static void constructor_37995( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TopGenEvent>();
  else ::new(mem) ::edm::Wrapper<TopGenEvent>();
}

static void constructor_37996( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TopGenEvent>(*(::std::auto_ptr<TopGenEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TopGenEvent>(*(::std::auto_ptr<TopGenEvent>*)arg[0]);
}

static void destructor_37997(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TopGenEvent>*)o)->::edm::Wrapper<TopGenEvent>::~Wrapper)();
}
static  void method_37998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TopGenEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<TopGenEvent>*)o)->product)();
}

static  void operator_37999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TopGenEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<TopGenEvent>*)o)->operator->)();
}

static  void method_38000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TopGenEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TopGenEvent>*)o)->productTypeInfo)();
}

static  void method_38001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TopGenEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<TopGenEvent>*)o)->typeInfo)();
}

static void constructor_38002( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TopGenEvent>((::TopGenEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TopGenEvent>((::TopGenEvent*)arg[0]);
}

static  void method_38003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TopGenEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<TopGenEvent>*)o)->getInterface)();
}

static  void method_38004( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TopGenEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_38005( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TopGenEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_38006( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TopGenEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_38007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TopGenEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TopGenEvent>*)o)->dynamicTypeInfo)();
}

static  void method_38008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TopGenEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TopGenEvent>*)o)->isPresent)();
}

static  void method_38009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TopGenEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TopGenEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6265( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TopGenEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TopGenEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TopGenEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TopGenEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TopGenEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TopGenEvent> -------------------------------
void __edm__Wrapper_TopGenEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_TopGenEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TopGenEvent__datamem_bld(&__edm__Wrapper_TopGenEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TopGenEvent__funcmem_bld(&__edm__Wrapper_TopGenEvent__db_funcmem);
void __edm__Wrapper_TopGenEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TopGenEvent>"), typeid(::edm::Wrapper<TopGenEvent>), sizeof(::edm::Wrapper<TopGenEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2227, Reflex::Literal("edm::Wrapper<TopGenEvent>::value_type"))
  .AddTypedef(type_2227, Reflex::Literal("edm::Wrapper<TopGenEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_37995, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3251), Reflex::Literal("Wrapper"), constructor_37996, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_37997, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63042), Reflex::Literal("Wrapper"), constructor_38002, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6265, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TopGenEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TopGenEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TopGenEvent> -------------------
void __edm__Wrapper_TopGenEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TopGenEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2227, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TopGenEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TopGenEvent> -------------------
void __edm__Wrapper_TopGenEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63041), Reflex::Literal("product"), method_37998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63041), Reflex::Literal("operator->"), operator_37999, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_38000, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_38001, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63043), Reflex::Literal("getInterface"), method_38003, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_38004, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_38005, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_38006, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_38007, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_38008, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_38009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<StGenEvent> -------------------------------
static void constructor_38016( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<StGenEvent>();
  else ::new(mem) ::edm::Wrapper<StGenEvent>();
}

static void constructor_38017( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<StGenEvent>(*(::std::auto_ptr<StGenEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<StGenEvent>(*(::std::auto_ptr<StGenEvent>*)arg[0]);
}

static void destructor_38018(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<StGenEvent>*)o)->::edm::Wrapper<StGenEvent>::~Wrapper)();
}
static  void method_38019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<StGenEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<StGenEvent>*)o)->product)();
}

static  void operator_38020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<StGenEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<StGenEvent>*)o)->operator->)();
}

static  void method_38021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<StGenEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<StGenEvent>*)o)->productTypeInfo)();
}

static  void method_38022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<StGenEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<StGenEvent>*)o)->typeInfo)();
}

static void constructor_38023( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<StGenEvent>((::StGenEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<StGenEvent>((::StGenEvent*)arg[0]);
}

static  void method_38024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<StGenEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<StGenEvent>*)o)->getInterface)();
}

static  void method_38025( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<StGenEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_38026( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<StGenEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_38027( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<StGenEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_38028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<StGenEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<StGenEvent>*)o)->dynamicTypeInfo)();
}

static  void method_38029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<StGenEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<StGenEvent>*)o)->isPresent)();
}

static  void method_38030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<StGenEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<StGenEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6266( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<StGenEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<StGenEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<StGenEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<StGenEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<StGenEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<StGenEvent> -------------------------------
void __edm__Wrapper_StGenEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_StGenEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_StGenEvent__datamem_bld(&__edm__Wrapper_StGenEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_StGenEvent__funcmem_bld(&__edm__Wrapper_StGenEvent__db_funcmem);
void __edm__Wrapper_StGenEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<StGenEvent>"), typeid(::edm::Wrapper<StGenEvent>), sizeof(::edm::Wrapper<StGenEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2546, Reflex::Literal("edm::Wrapper<StGenEvent>::value_type"))
  .AddTypedef(type_2546, Reflex::Literal("edm::Wrapper<StGenEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_38016, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3252), Reflex::Literal("Wrapper"), constructor_38017, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_38018, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63047), Reflex::Literal("Wrapper"), constructor_38023, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6266, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_StGenEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_StGenEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<StGenEvent> -------------------
void __edm__Wrapper_StGenEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_StGenEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2546, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_StGenEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<StGenEvent> -------------------
void __edm__Wrapper_StGenEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63046), Reflex::Literal("product"), method_38019, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63046), Reflex::Literal("operator->"), operator_38020, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_38021, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_38022, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63048), Reflex::Literal("getInterface"), method_38024, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_38025, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_38026, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_38027, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_38028, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_38029, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_38030, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<TtGenEvent> -------------------------------
static void constructor_38037( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TtGenEvent>();
  else ::new(mem) ::edm::Wrapper<TtGenEvent>();
}

static void constructor_38038( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TtGenEvent>(*(::std::auto_ptr<TtGenEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TtGenEvent>(*(::std::auto_ptr<TtGenEvent>*)arg[0]);
}

static void destructor_38039(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<TtGenEvent>*)o)->::edm::Wrapper<TtGenEvent>::~Wrapper)();
}
static  void method_38040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TtGenEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<TtGenEvent>*)o)->product)();
}

static  void operator_38041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<TtGenEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<TtGenEvent>*)o)->operator->)();
}

static  void method_38042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TtGenEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<TtGenEvent>*)o)->productTypeInfo)();
}

static  void method_38043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<TtGenEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<TtGenEvent>*)o)->typeInfo)();
}

static void constructor_38044( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<TtGenEvent>((::TtGenEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<TtGenEvent>((::TtGenEvent*)arg[0]);
}

static  void method_38045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<TtGenEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<TtGenEvent>*)o)->getInterface)();
}

static  void method_38046( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TtGenEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_38047( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TtGenEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_38048( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<TtGenEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_38049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TtGenEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<TtGenEvent>*)o)->dynamicTypeInfo)();
}

static  void method_38050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<TtGenEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<TtGenEvent>*)o)->isPresent)();
}

static  void method_38051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<TtGenEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<TtGenEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6267( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtGenEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtGenEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtGenEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtGenEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<TtGenEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<TtGenEvent> -------------------------------
void __edm__Wrapper_TtGenEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_TtGenEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TtGenEvent__datamem_bld(&__edm__Wrapper_TtGenEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_TtGenEvent__funcmem_bld(&__edm__Wrapper_TtGenEvent__db_funcmem);
void __edm__Wrapper_TtGenEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<TtGenEvent>"), typeid(::edm::Wrapper<TtGenEvent>), sizeof(::edm::Wrapper<TtGenEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1829, Reflex::Literal("edm::Wrapper<TtGenEvent>::value_type"))
  .AddTypedef(type_1829, Reflex::Literal("edm::Wrapper<TtGenEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_38037, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3253), Reflex::Literal("Wrapper"), constructor_38038, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_38039, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63052), Reflex::Literal("Wrapper"), constructor_38044, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6267, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_TtGenEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_TtGenEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<TtGenEvent> -------------------
void __edm__Wrapper_TtGenEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_TtGenEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1829, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_TtGenEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<TtGenEvent> -------------------
void __edm__Wrapper_TtGenEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63051), Reflex::Literal("product"), method_38040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63051), Reflex::Literal("operator->"), operator_38041, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_38042, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_38043, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63053), Reflex::Literal("getInterface"), method_38045, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_38046, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_38047, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_38048, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_38049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_38050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_38051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefProd<TtFullHadronicEvent> -------------------------------
static  void operator_38873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<TtFullHadronicEvent>*)o)->operator=)(*(const ::edm::RefProd<TtFullHadronicEvent>*)arg[0]);
  else   (((::edm::RefProd<TtFullHadronicEvent>*)o)->operator=)(*(const ::edm::RefProd<TtFullHadronicEvent>*)arg[0]);
}

static void constructor_38874( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullHadronicEvent>(*(const ::edm::RefProd<TtFullHadronicEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtFullHadronicEvent>(*(const ::edm::RefProd<TtFullHadronicEvent>*)arg[0]);
}

static void constructor_38875( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullHadronicEvent>();
  else ::new(mem) ::edm::RefProd<TtFullHadronicEvent>();
}

static void constructor_38876( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullHadronicEvent>(*(const ::edm::Handle<TtFullHadronicEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtFullHadronicEvent>(*(const ::edm::Handle<TtFullHadronicEvent>*)arg[0]);
}

static void constructor_38877( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullHadronicEvent>(*(const ::edm::OrphanHandle<TtFullHadronicEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtFullHadronicEvent>(*(const ::edm::OrphanHandle<TtFullHadronicEvent>*)arg[0]);
}

static void constructor_38878( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullHadronicEvent>((const ::TtFullHadronicEvent*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtFullHadronicEvent>((const ::TtFullHadronicEvent*)arg[0]);
}

static void constructor_38879( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullHadronicEvent>(*(const ::edm::TestHandle<TtFullHadronicEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtFullHadronicEvent>(*(const ::edm::TestHandle<TtFullHadronicEvent>*)arg[0]);
}

static void constructor_38880( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullHadronicEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<TtFullHadronicEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_38881(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<TtFullHadronicEvent>*)o)->::edm::RefProd<TtFullHadronicEvent>::~RefProd)();
}
static  void operator_38882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<TtFullHadronicEvent>*)o)->operator*)();
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->operator*)();
}

static  void operator_38883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtFullHadronicEvent>*)o)->operator->)());
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->operator->)();
}

static  void method_38884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtFullHadronicEvent>*)o)->get)());
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->get)();
}

static  void method_38885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtFullHadronicEvent>*)o)->product)());
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->product)();
}

static  void method_38886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<TtFullHadronicEvent>*)o)->refCore)();
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->refCore)();
}

static  void method_38887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullHadronicEvent>*)o)->isNull)());
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->isNull)();
}

static  void method_38888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullHadronicEvent>*)o)->isNonnull)());
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->isNonnull)();
}

static  void operator_38889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullHadronicEvent>*)o)->operator!)());
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->operator!)();
}

static  void method_38890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<TtFullHadronicEvent>*)o)->id)());
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->id)();
}

static  void method_38891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtFullHadronicEvent>*)o)->productGetter)());
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->productGetter)();
}

static  void method_38892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullHadronicEvent>*)o)->hasCache)());
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->hasCache)();
}

static  void method_38893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullHadronicEvent>*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->hasProductCache)();
}

static  void method_38894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullHadronicEvent>*)o)->isAvailable)());
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->isAvailable)();
}

static  void method_38895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullHadronicEvent>*)o)->isTransient)());
  else   (((const ::edm::RefProd<TtFullHadronicEvent>*)o)->isTransient)();
}

static  void method_38896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<TtFullHadronicEvent>*)o)->swap)(*(::edm::RefProd<TtFullHadronicEvent>*)arg[0]);
}

static  void method_38897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<TtFullHadronicEvent>*)o)->Class_Version)());
  else   (((::edm::RefProd<TtFullHadronicEvent>*)o)->Class_Version)();
}

static void method_newdel_6620( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtFullHadronicEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtFullHadronicEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtFullHadronicEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtFullHadronicEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtFullHadronicEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<TtFullHadronicEvent> -------------------------------
void __edm__RefProd_TtFullHadronicEvent__db_datamem(Reflex::Class*);
void __edm__RefProd_TtFullHadronicEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_TtFullHadronicEvent__datamem_bld(&__edm__RefProd_TtFullHadronicEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_TtFullHadronicEvent__funcmem_bld(&__edm__RefProd_TtFullHadronicEvent__db_funcmem);
void __edm__RefProd_TtFullHadronicEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<TtFullHadronicEvent>"), typeid(::edm::RefProd<TtFullHadronicEvent>), sizeof(::edm::RefProd<TtFullHadronicEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<TtFullHadronicEvent>::Class_Version())
  .AddTypedef(type_1100, Reflex::Literal("edm::RefProd<TtFullHadronicEvent>::product_type"))
  .AddTypedef(type_1100, Reflex::Literal("edm::RefProd<TtFullHadronicEvent>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63349, type_63350), Reflex::Literal("operator="), operator_38873, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63350), Reflex::Literal("RefProd"), constructor_38874, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_38875, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63351), Reflex::Literal("RefProd"), constructor_38876, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63352), Reflex::Literal("RefProd"), constructor_38877, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63026), Reflex::Literal("RefProd"), constructor_38878, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63353), Reflex::Literal("RefProd"), constructor_38879, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35422, type_35539), Reflex::Literal("RefProd"), constructor_38880, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_38881, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6620, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_TtFullHadronicEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_TtFullHadronicEvent__funcmem_bld);
}

//------Delayed data member builder for class RefProd<TtFullHadronicEvent> -------------------
void __edm__RefProd_TtFullHadronicEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6595, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_TtFullHadronicEvent_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<TtFullHadronicEvent> -------------------
void __edm__RefProd_TtFullHadronicEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46453), Reflex::Literal("operator*"), operator_38882, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63026), Reflex::Literal("operator->"), operator_38883, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63026), Reflex::Literal("get"), method_38884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63026), Reflex::Literal("product"), method_38885, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35600), Reflex::Literal("refCore"), method_38886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNull"), method_38887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNonnull"), method_38888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("operator!"), operator_38889, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("id"), method_38890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35539), Reflex::Literal("productGetter"), method_38891, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasCache"), method_38892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasProductCache"), method_38893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isAvailable"), method_38894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isTransient"), method_38895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_63349), Reflex::Literal("swap"), method_38896, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("Class_Version"), method_38897, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<TtSemiLeptonicEvent> -------------------------------
static  void operator_38902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<TtSemiLeptonicEvent>*)o)->operator=)(*(const ::edm::RefProd<TtSemiLeptonicEvent>*)arg[0]);
  else   (((::edm::RefProd<TtSemiLeptonicEvent>*)o)->operator=)(*(const ::edm::RefProd<TtSemiLeptonicEvent>*)arg[0]);
}

static void constructor_38903( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>(*(const ::edm::RefProd<TtSemiLeptonicEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>(*(const ::edm::RefProd<TtSemiLeptonicEvent>*)arg[0]);
}

static void constructor_38904( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>();
  else ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>();
}

static void constructor_38905( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>(*(const ::edm::Handle<TtSemiLeptonicEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>(*(const ::edm::Handle<TtSemiLeptonicEvent>*)arg[0]);
}

static void constructor_38906( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>(*(const ::edm::OrphanHandle<TtSemiLeptonicEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>(*(const ::edm::OrphanHandle<TtSemiLeptonicEvent>*)arg[0]);
}

static void constructor_38907( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>((const ::TtSemiLeptonicEvent*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>((const ::TtSemiLeptonicEvent*)arg[0]);
}

static void constructor_38908( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>(*(const ::edm::TestHandle<TtSemiLeptonicEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>(*(const ::edm::TestHandle<TtSemiLeptonicEvent>*)arg[0]);
}

static void constructor_38909( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<TtSemiLeptonicEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_38910(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<TtSemiLeptonicEvent>*)o)->::edm::RefProd<TtSemiLeptonicEvent>::~RefProd)();
}
static  void operator_38911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->operator*)();
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->operator*)();
}

static  void operator_38912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->operator->)());
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->operator->)();
}

static  void method_38913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->get)());
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->get)();
}

static  void method_38914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->product)());
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->product)();
}

static  void method_38915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->refCore)();
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->refCore)();
}

static  void method_38916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->isNull)());
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->isNull)();
}

static  void method_38917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->isNonnull)());
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->isNonnull)();
}

static  void operator_38918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->operator!)());
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->operator!)();
}

static  void method_38919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->id)());
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->id)();
}

static  void method_38920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->productGetter)());
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->productGetter)();
}

static  void method_38921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->hasCache)());
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->hasCache)();
}

static  void method_38922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->hasProductCache)();
}

static  void method_38923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->isAvailable)());
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->isAvailable)();
}

static  void method_38924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->isTransient)());
  else   (((const ::edm::RefProd<TtSemiLeptonicEvent>*)o)->isTransient)();
}

static  void method_38925( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<TtSemiLeptonicEvent>*)o)->swap)(*(::edm::RefProd<TtSemiLeptonicEvent>*)arg[0]);
}

static  void method_38926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<TtSemiLeptonicEvent>*)o)->Class_Version)());
  else   (((::edm::RefProd<TtSemiLeptonicEvent>*)o)->Class_Version)();
}

static void method_newdel_6621( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtSemiLeptonicEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtSemiLeptonicEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtSemiLeptonicEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtSemiLeptonicEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtSemiLeptonicEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<TtSemiLeptonicEvent> -------------------------------
void __edm__RefProd_TtSemiLeptonicEvent__db_datamem(Reflex::Class*);
void __edm__RefProd_TtSemiLeptonicEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_TtSemiLeptonicEvent__datamem_bld(&__edm__RefProd_TtSemiLeptonicEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_TtSemiLeptonicEvent__funcmem_bld(&__edm__RefProd_TtSemiLeptonicEvent__db_funcmem);
void __edm__RefProd_TtSemiLeptonicEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<TtSemiLeptonicEvent>"), typeid(::edm::RefProd<TtSemiLeptonicEvent>), sizeof(::edm::RefProd<TtSemiLeptonicEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<TtSemiLeptonicEvent>::Class_Version())
  .AddTypedef(type_1227, Reflex::Literal("edm::RefProd<TtSemiLeptonicEvent>::product_type"))
  .AddTypedef(type_1227, Reflex::Literal("edm::RefProd<TtSemiLeptonicEvent>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63354, type_63355), Reflex::Literal("operator="), operator_38902, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63355), Reflex::Literal("RefProd"), constructor_38903, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_38904, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63356), Reflex::Literal("RefProd"), constructor_38905, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63357), Reflex::Literal("RefProd"), constructor_38906, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63031), Reflex::Literal("RefProd"), constructor_38907, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63358), Reflex::Literal("RefProd"), constructor_38908, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35422, type_35539), Reflex::Literal("RefProd"), constructor_38909, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_38910, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6621, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_TtSemiLeptonicEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_TtSemiLeptonicEvent__funcmem_bld);
}

//------Delayed data member builder for class RefProd<TtSemiLeptonicEvent> -------------------
void __edm__RefProd_TtSemiLeptonicEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6595, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_TtSemiLeptonicEvent_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<TtSemiLeptonicEvent> -------------------
void __edm__RefProd_TtSemiLeptonicEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46480), Reflex::Literal("operator*"), operator_38911, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63031), Reflex::Literal("operator->"), operator_38912, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63031), Reflex::Literal("get"), method_38913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63031), Reflex::Literal("product"), method_38914, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35600), Reflex::Literal("refCore"), method_38915, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNull"), method_38916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNonnull"), method_38917, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("operator!"), operator_38918, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("id"), method_38919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35539), Reflex::Literal("productGetter"), method_38920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasCache"), method_38921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasProductCache"), method_38922, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isAvailable"), method_38923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isTransient"), method_38924, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_63354), Reflex::Literal("swap"), method_38925, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("Class_Version"), method_38926, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<TtFullLeptonicEvent> -------------------------------
static  void operator_38931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<TtFullLeptonicEvent>*)o)->operator=)(*(const ::edm::RefProd<TtFullLeptonicEvent>*)arg[0]);
  else   (((::edm::RefProd<TtFullLeptonicEvent>*)o)->operator=)(*(const ::edm::RefProd<TtFullLeptonicEvent>*)arg[0]);
}

static void constructor_38932( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>(*(const ::edm::RefProd<TtFullLeptonicEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>(*(const ::edm::RefProd<TtFullLeptonicEvent>*)arg[0]);
}

static void constructor_38933( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>();
  else ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>();
}

static void constructor_38934( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>(*(const ::edm::Handle<TtFullLeptonicEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>(*(const ::edm::Handle<TtFullLeptonicEvent>*)arg[0]);
}

static void constructor_38935( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>(*(const ::edm::OrphanHandle<TtFullLeptonicEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>(*(const ::edm::OrphanHandle<TtFullLeptonicEvent>*)arg[0]);
}

static void constructor_38936( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>((const ::TtFullLeptonicEvent*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>((const ::TtFullLeptonicEvent*)arg[0]);
}

static void constructor_38937( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>(*(const ::edm::TestHandle<TtFullLeptonicEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>(*(const ::edm::TestHandle<TtFullLeptonicEvent>*)arg[0]);
}

static void constructor_38938( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<TtFullLeptonicEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_38939(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<TtFullLeptonicEvent>*)o)->::edm::RefProd<TtFullLeptonicEvent>::~RefProd)();
}
static  void operator_38940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->operator*)();
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->operator*)();
}

static  void operator_38941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->operator->)());
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->operator->)();
}

static  void method_38942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->get)());
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->get)();
}

static  void method_38943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->product)());
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->product)();
}

static  void method_38944( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->refCore)();
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->refCore)();
}

static  void method_38945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->isNull)());
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->isNull)();
}

static  void method_38946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->isNonnull)());
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->isNonnull)();
}

static  void operator_38947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->operator!)());
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->operator!)();
}

static  void method_38948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->id)());
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->id)();
}

static  void method_38949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->productGetter)());
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->productGetter)();
}

static  void method_38950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->hasCache)());
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->hasCache)();
}

static  void method_38951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->hasProductCache)();
}

static  void method_38952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->isAvailable)());
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->isAvailable)();
}

static  void method_38953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->isTransient)());
  else   (((const ::edm::RefProd<TtFullLeptonicEvent>*)o)->isTransient)();
}

static  void method_38954( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<TtFullLeptonicEvent>*)o)->swap)(*(::edm::RefProd<TtFullLeptonicEvent>*)arg[0]);
}

static  void method_38955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<TtFullLeptonicEvent>*)o)->Class_Version)());
  else   (((::edm::RefProd<TtFullLeptonicEvent>*)o)->Class_Version)();
}

static void method_newdel_6622( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtFullLeptonicEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtFullLeptonicEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtFullLeptonicEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtFullLeptonicEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtFullLeptonicEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<TtFullLeptonicEvent> -------------------------------
void __edm__RefProd_TtFullLeptonicEvent__db_datamem(Reflex::Class*);
void __edm__RefProd_TtFullLeptonicEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_TtFullLeptonicEvent__datamem_bld(&__edm__RefProd_TtFullLeptonicEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_TtFullLeptonicEvent__funcmem_bld(&__edm__RefProd_TtFullLeptonicEvent__db_funcmem);
void __edm__RefProd_TtFullLeptonicEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<TtFullLeptonicEvent>"), typeid(::edm::RefProd<TtFullLeptonicEvent>), sizeof(::edm::RefProd<TtFullLeptonicEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<TtFullLeptonicEvent>::Class_Version())
  .AddTypedef(type_2790, Reflex::Literal("edm::RefProd<TtFullLeptonicEvent>::product_type"))
  .AddTypedef(type_2790, Reflex::Literal("edm::RefProd<TtFullLeptonicEvent>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63359, type_63360), Reflex::Literal("operator="), operator_38931, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63360), Reflex::Literal("RefProd"), constructor_38932, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_38933, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63361), Reflex::Literal("RefProd"), constructor_38934, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63362), Reflex::Literal("RefProd"), constructor_38935, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63036), Reflex::Literal("RefProd"), constructor_38936, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63363), Reflex::Literal("RefProd"), constructor_38937, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35422, type_35539), Reflex::Literal("RefProd"), constructor_38938, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_38939, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6622, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_TtFullLeptonicEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_TtFullLeptonicEvent__funcmem_bld);
}

//------Delayed data member builder for class RefProd<TtFullLeptonicEvent> -------------------
void __edm__RefProd_TtFullLeptonicEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6595, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_TtFullLeptonicEvent_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<TtFullLeptonicEvent> -------------------
void __edm__RefProd_TtFullLeptonicEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_57546), Reflex::Literal("operator*"), operator_38940, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63036), Reflex::Literal("operator->"), operator_38941, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63036), Reflex::Literal("get"), method_38942, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63036), Reflex::Literal("product"), method_38943, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35600), Reflex::Literal("refCore"), method_38944, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNull"), method_38945, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNonnull"), method_38946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("operator!"), operator_38947, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("id"), method_38948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35539), Reflex::Literal("productGetter"), method_38949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasCache"), method_38950, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasProductCache"), method_38951, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isAvailable"), method_38952, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isTransient"), method_38953, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_63359), Reflex::Literal("swap"), method_38954, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("Class_Version"), method_38955, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<TopGenEvent> -------------------------------
static  void operator_38960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<TopGenEvent>*)o)->operator=)(*(const ::edm::RefProd<TopGenEvent>*)arg[0]);
  else   (((::edm::RefProd<TopGenEvent>*)o)->operator=)(*(const ::edm::RefProd<TopGenEvent>*)arg[0]);
}

static void constructor_38961( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TopGenEvent>(*(const ::edm::RefProd<TopGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TopGenEvent>(*(const ::edm::RefProd<TopGenEvent>*)arg[0]);
}

static void constructor_38962( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TopGenEvent>();
  else ::new(mem) ::edm::RefProd<TopGenEvent>();
}

static void constructor_38963( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TopGenEvent>(*(const ::edm::Handle<TopGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TopGenEvent>(*(const ::edm::Handle<TopGenEvent>*)arg[0]);
}

static void constructor_38964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TopGenEvent>(*(const ::edm::OrphanHandle<TopGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TopGenEvent>(*(const ::edm::OrphanHandle<TopGenEvent>*)arg[0]);
}

static void constructor_38965( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TopGenEvent>((const ::TopGenEvent*)arg[0]);
  else ::new(mem) ::edm::RefProd<TopGenEvent>((const ::TopGenEvent*)arg[0]);
}

static void constructor_38966( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TopGenEvent>(*(const ::edm::TestHandle<TopGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TopGenEvent>(*(const ::edm::TestHandle<TopGenEvent>*)arg[0]);
}

static void constructor_38967( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TopGenEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<TopGenEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_38968(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<TopGenEvent>*)o)->::edm::RefProd<TopGenEvent>::~RefProd)();
}
static  void operator_38969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<TopGenEvent>*)o)->operator*)();
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->operator*)();
}

static  void operator_38970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TopGenEvent>*)o)->operator->)());
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->operator->)();
}

static  void method_38971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TopGenEvent>*)o)->get)());
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->get)();
}

static  void method_38972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TopGenEvent>*)o)->product)());
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->product)();
}

static  void method_38973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<TopGenEvent>*)o)->refCore)();
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->refCore)();
}

static  void method_38974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TopGenEvent>*)o)->isNull)());
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->isNull)();
}

static  void method_38975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TopGenEvent>*)o)->isNonnull)());
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->isNonnull)();
}

static  void operator_38976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TopGenEvent>*)o)->operator!)());
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->operator!)();
}

static  void method_38977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<TopGenEvent>*)o)->id)());
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->id)();
}

static  void method_38978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TopGenEvent>*)o)->productGetter)());
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->productGetter)();
}

static  void method_38979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TopGenEvent>*)o)->hasCache)());
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->hasCache)();
}

static  void method_38980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TopGenEvent>*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->hasProductCache)();
}

static  void method_38981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TopGenEvent>*)o)->isAvailable)());
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->isAvailable)();
}

static  void method_38982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TopGenEvent>*)o)->isTransient)());
  else   (((const ::edm::RefProd<TopGenEvent>*)o)->isTransient)();
}

static  void method_38983( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<TopGenEvent>*)o)->swap)(*(::edm::RefProd<TopGenEvent>*)arg[0]);
}

static  void method_38984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<TopGenEvent>*)o)->Class_Version)());
  else   (((::edm::RefProd<TopGenEvent>*)o)->Class_Version)();
}

static void method_newdel_6623( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TopGenEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TopGenEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TopGenEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TopGenEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TopGenEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<TopGenEvent> -------------------------------
void __edm__RefProd_TopGenEvent__db_datamem(Reflex::Class*);
void __edm__RefProd_TopGenEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_TopGenEvent__datamem_bld(&__edm__RefProd_TopGenEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_TopGenEvent__funcmem_bld(&__edm__RefProd_TopGenEvent__db_funcmem);
void __edm__RefProd_TopGenEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<TopGenEvent>"), typeid(::edm::RefProd<TopGenEvent>), sizeof(::edm::RefProd<TopGenEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<TopGenEvent>::Class_Version())
  .AddTypedef(type_2227, Reflex::Literal("edm::RefProd<TopGenEvent>::product_type"))
  .AddTypedef(type_2227, Reflex::Literal("edm::RefProd<TopGenEvent>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63364, type_63365), Reflex::Literal("operator="), operator_38960, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63365), Reflex::Literal("RefProd"), constructor_38961, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_38962, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63366), Reflex::Literal("RefProd"), constructor_38963, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63367), Reflex::Literal("RefProd"), constructor_38964, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63041), Reflex::Literal("RefProd"), constructor_38965, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63368), Reflex::Literal("RefProd"), constructor_38966, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35422, type_35539), Reflex::Literal("RefProd"), constructor_38967, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_38968, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6623, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_TopGenEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_TopGenEvent__funcmem_bld);
}

//------Delayed data member builder for class RefProd<TopGenEvent> -------------------
void __edm__RefProd_TopGenEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6595, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_TopGenEvent_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<TopGenEvent> -------------------
void __edm__RefProd_TopGenEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50117), Reflex::Literal("operator*"), operator_38969, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63041), Reflex::Literal("operator->"), operator_38970, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63041), Reflex::Literal("get"), method_38971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63041), Reflex::Literal("product"), method_38972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35600), Reflex::Literal("refCore"), method_38973, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNull"), method_38974, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNonnull"), method_38975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("operator!"), operator_38976, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("id"), method_38977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35539), Reflex::Literal("productGetter"), method_38978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasCache"), method_38979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasProductCache"), method_38980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isAvailable"), method_38981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isTransient"), method_38982, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_63364), Reflex::Literal("swap"), method_38983, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("Class_Version"), method_38984, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<StGenEvent> -------------------------------
static  void operator_38989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<StGenEvent>*)o)->operator=)(*(const ::edm::RefProd<StGenEvent>*)arg[0]);
  else   (((::edm::RefProd<StGenEvent>*)o)->operator=)(*(const ::edm::RefProd<StGenEvent>*)arg[0]);
}

static void constructor_38990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<StGenEvent>(*(const ::edm::RefProd<StGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<StGenEvent>(*(const ::edm::RefProd<StGenEvent>*)arg[0]);
}

static void constructor_38991( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<StGenEvent>();
  else ::new(mem) ::edm::RefProd<StGenEvent>();
}

static void constructor_38992( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<StGenEvent>(*(const ::edm::Handle<StGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<StGenEvent>(*(const ::edm::Handle<StGenEvent>*)arg[0]);
}

static void constructor_38993( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<StGenEvent>(*(const ::edm::OrphanHandle<StGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<StGenEvent>(*(const ::edm::OrphanHandle<StGenEvent>*)arg[0]);
}

static void constructor_38994( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<StGenEvent>((const ::StGenEvent*)arg[0]);
  else ::new(mem) ::edm::RefProd<StGenEvent>((const ::StGenEvent*)arg[0]);
}

static void constructor_38995( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<StGenEvent>(*(const ::edm::TestHandle<StGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<StGenEvent>(*(const ::edm::TestHandle<StGenEvent>*)arg[0]);
}

static void constructor_38996( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<StGenEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<StGenEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_38997(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<StGenEvent>*)o)->::edm::RefProd<StGenEvent>::~RefProd)();
}
static  void operator_38998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<StGenEvent>*)o)->operator*)();
  else   (((const ::edm::RefProd<StGenEvent>*)o)->operator*)();
}

static  void operator_38999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<StGenEvent>*)o)->operator->)());
  else   (((const ::edm::RefProd<StGenEvent>*)o)->operator->)();
}

static  void method_39000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<StGenEvent>*)o)->get)());
  else   (((const ::edm::RefProd<StGenEvent>*)o)->get)();
}

static  void method_39001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<StGenEvent>*)o)->product)());
  else   (((const ::edm::RefProd<StGenEvent>*)o)->product)();
}

static  void method_39002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<StGenEvent>*)o)->refCore)();
  else   (((const ::edm::RefProd<StGenEvent>*)o)->refCore)();
}

static  void method_39003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<StGenEvent>*)o)->isNull)());
  else   (((const ::edm::RefProd<StGenEvent>*)o)->isNull)();
}

static  void method_39004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<StGenEvent>*)o)->isNonnull)());
  else   (((const ::edm::RefProd<StGenEvent>*)o)->isNonnull)();
}

static  void operator_39005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<StGenEvent>*)o)->operator!)());
  else   (((const ::edm::RefProd<StGenEvent>*)o)->operator!)();
}

static  void method_39006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<StGenEvent>*)o)->id)());
  else   (((const ::edm::RefProd<StGenEvent>*)o)->id)();
}

static  void method_39007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<StGenEvent>*)o)->productGetter)());
  else   (((const ::edm::RefProd<StGenEvent>*)o)->productGetter)();
}

static  void method_39008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<StGenEvent>*)o)->hasCache)());
  else   (((const ::edm::RefProd<StGenEvent>*)o)->hasCache)();
}

static  void method_39009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<StGenEvent>*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<StGenEvent>*)o)->hasProductCache)();
}

static  void method_39010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<StGenEvent>*)o)->isAvailable)());
  else   (((const ::edm::RefProd<StGenEvent>*)o)->isAvailable)();
}

static  void method_39011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<StGenEvent>*)o)->isTransient)());
  else   (((const ::edm::RefProd<StGenEvent>*)o)->isTransient)();
}

static  void method_39012( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<StGenEvent>*)o)->swap)(*(::edm::RefProd<StGenEvent>*)arg[0]);
}

static  void method_39013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<StGenEvent>*)o)->Class_Version)());
  else   (((::edm::RefProd<StGenEvent>*)o)->Class_Version)();
}

static void method_newdel_6624( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<StGenEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<StGenEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<StGenEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<StGenEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<StGenEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<StGenEvent> -------------------------------
void __edm__RefProd_StGenEvent__db_datamem(Reflex::Class*);
void __edm__RefProd_StGenEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_StGenEvent__datamem_bld(&__edm__RefProd_StGenEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_StGenEvent__funcmem_bld(&__edm__RefProd_StGenEvent__db_funcmem);
void __edm__RefProd_StGenEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<StGenEvent>"), typeid(::edm::RefProd<StGenEvent>), sizeof(::edm::RefProd<StGenEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<StGenEvent>::Class_Version())
  .AddTypedef(type_2546, Reflex::Literal("edm::RefProd<StGenEvent>::product_type"))
  .AddTypedef(type_2546, Reflex::Literal("edm::RefProd<StGenEvent>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63369, type_47411), Reflex::Literal("operator="), operator_38989, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_47411), Reflex::Literal("RefProd"), constructor_38990, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_38991, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_47412), Reflex::Literal("RefProd"), constructor_38992, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63276), Reflex::Literal("RefProd"), constructor_38993, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63046), Reflex::Literal("RefProd"), constructor_38994, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63231), Reflex::Literal("RefProd"), constructor_38995, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35422, type_35539), Reflex::Literal("RefProd"), constructor_38996, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_38997, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6624, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_StGenEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_StGenEvent__funcmem_bld);
}

//------Delayed data member builder for class RefProd<StGenEvent> -------------------
void __edm__RefProd_StGenEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6595, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_StGenEvent_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<StGenEvent> -------------------
void __edm__RefProd_StGenEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_55766), Reflex::Literal("operator*"), operator_38998, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63046), Reflex::Literal("operator->"), operator_38999, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63046), Reflex::Literal("get"), method_39000, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63046), Reflex::Literal("product"), method_39001, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35600), Reflex::Literal("refCore"), method_39002, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNull"), method_39003, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNonnull"), method_39004, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("operator!"), operator_39005, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("id"), method_39006, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35539), Reflex::Literal("productGetter"), method_39007, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasCache"), method_39008, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasProductCache"), method_39009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isAvailable"), method_39010, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isTransient"), method_39011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_63369), Reflex::Literal("swap"), method_39012, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("Class_Version"), method_39013, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<TtGenEvent> -------------------------------
static  void operator_39018( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<TtGenEvent>*)o)->operator=)(*(const ::edm::RefProd<TtGenEvent>*)arg[0]);
  else   (((::edm::RefProd<TtGenEvent>*)o)->operator=)(*(const ::edm::RefProd<TtGenEvent>*)arg[0]);
}

static void constructor_39019( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtGenEvent>(*(const ::edm::RefProd<TtGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtGenEvent>(*(const ::edm::RefProd<TtGenEvent>*)arg[0]);
}

static void constructor_39020( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtGenEvent>();
  else ::new(mem) ::edm::RefProd<TtGenEvent>();
}

static void constructor_39021( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtGenEvent>(*(const ::edm::Handle<TtGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtGenEvent>(*(const ::edm::Handle<TtGenEvent>*)arg[0]);
}

static void constructor_39022( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtGenEvent>(*(const ::edm::OrphanHandle<TtGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtGenEvent>(*(const ::edm::OrphanHandle<TtGenEvent>*)arg[0]);
}

static void constructor_39023( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtGenEvent>((const ::TtGenEvent*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtGenEvent>((const ::TtGenEvent*)arg[0]);
}

static void constructor_39024( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtGenEvent>(*(const ::edm::TestHandle<TtGenEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<TtGenEvent>(*(const ::edm::TestHandle<TtGenEvent>*)arg[0]);
}

static void constructor_39025( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<TtGenEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<TtGenEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_39026(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<TtGenEvent>*)o)->::edm::RefProd<TtGenEvent>::~RefProd)();
}
static  void operator_39027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<TtGenEvent>*)o)->operator*)();
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->operator*)();
}

static  void operator_39028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtGenEvent>*)o)->operator->)());
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->operator->)();
}

static  void method_39029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtGenEvent>*)o)->get)());
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->get)();
}

static  void method_39030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtGenEvent>*)o)->product)());
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->product)();
}

static  void method_39031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<TtGenEvent>*)o)->refCore)();
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->refCore)();
}

static  void method_39032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtGenEvent>*)o)->isNull)());
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->isNull)();
}

static  void method_39033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtGenEvent>*)o)->isNonnull)());
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->isNonnull)();
}

static  void operator_39034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtGenEvent>*)o)->operator!)());
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->operator!)();
}

static  void method_39035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<TtGenEvent>*)o)->id)());
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->id)();
}

static  void method_39036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<TtGenEvent>*)o)->productGetter)());
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->productGetter)();
}

static  void method_39037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtGenEvent>*)o)->hasCache)());
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->hasCache)();
}

static  void method_39038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtGenEvent>*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->hasProductCache)();
}

static  void method_39039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtGenEvent>*)o)->isAvailable)());
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->isAvailable)();
}

static  void method_39040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<TtGenEvent>*)o)->isTransient)());
  else   (((const ::edm::RefProd<TtGenEvent>*)o)->isTransient)();
}

static  void method_39041( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<TtGenEvent>*)o)->swap)(*(::edm::RefProd<TtGenEvent>*)arg[0]);
}

static  void method_39042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<TtGenEvent>*)o)->Class_Version)());
  else   (((::edm::RefProd<TtGenEvent>*)o)->Class_Version)();
}

static void method_newdel_6625( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtGenEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtGenEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtGenEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtGenEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<TtGenEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<TtGenEvent> -------------------------------
void __edm__RefProd_TtGenEvent__db_datamem(Reflex::Class*);
void __edm__RefProd_TtGenEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_TtGenEvent__datamem_bld(&__edm__RefProd_TtGenEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_TtGenEvent__funcmem_bld(&__edm__RefProd_TtGenEvent__db_funcmem);
void __edm__RefProd_TtGenEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<TtGenEvent>"), typeid(::edm::RefProd<TtGenEvent>), sizeof(::edm::RefProd<TtGenEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<TtGenEvent>::Class_Version())
  .AddTypedef(type_1829, Reflex::Literal("edm::RefProd<TtGenEvent>::product_type"))
  .AddTypedef(type_1829, Reflex::Literal("edm::RefProd<TtGenEvent>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63370, type_46181), Reflex::Literal("operator="), operator_39018, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_46181), Reflex::Literal("RefProd"), constructor_39019, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_39020, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_46182), Reflex::Literal("RefProd"), constructor_39021, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63278), Reflex::Literal("RefProd"), constructor_39022, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63051), Reflex::Literal("RefProd"), constructor_39023, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63233), Reflex::Literal("RefProd"), constructor_39024, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35422, type_35539), Reflex::Literal("RefProd"), constructor_39025, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_39026, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6625, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_TtGenEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_TtGenEvent__funcmem_bld);
}

//------Delayed data member builder for class RefProd<TtGenEvent> -------------------
void __edm__RefProd_TtGenEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6595, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_TtGenEvent_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<TtGenEvent> -------------------
void __edm__RefProd_TtGenEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47448), Reflex::Literal("operator*"), operator_39027, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63051), Reflex::Literal("operator->"), operator_39028, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63051), Reflex::Literal("get"), method_39029, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63051), Reflex::Literal("product"), method_39030, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35600), Reflex::Literal("refCore"), method_39031, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNull"), method_39032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNonnull"), method_39033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("operator!"), operator_39034, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("id"), method_39035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35539), Reflex::Literal("productGetter"), method_39036, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasCache"), method_39037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasProductCache"), method_39038, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isAvailable"), method_39039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isTransient"), method_39040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_63370), Reflex::Literal("swap"), method_39041, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("Class_Version"), method_39042, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class CATopJetTagInfo -------------------------------
static  void operator_48084( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::CATopJetTagInfo*)o)->operator=)(*(const ::reco::CATopJetTagInfo*)arg[0]);
  else   (((::reco::CATopJetTagInfo*)o)->operator=)(*(const ::reco::CATopJetTagInfo*)arg[0]);
}

static void constructor_48085( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CATopJetTagInfo(*(const ::reco::CATopJetTagInfo*)arg[0]);
  else ::new(mem) ::reco::CATopJetTagInfo(*(const ::reco::CATopJetTagInfo*)arg[0]);
}

static void constructor_48086( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CATopJetTagInfo();
  else ::new(mem) ::reco::CATopJetTagInfo();
}

static void destructor_48087(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::CATopJetTagInfo*)o)->::reco::CATopJetTagInfo::~CATopJetTagInfo)();
}
static  void method_48088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::reco::CATopJetTagInfo*)o)->clone)());
  else   (((const ::reco::CATopJetTagInfo*)o)->clone)();
}

static  void method_48089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::CATopJetTagInfo*)o)->properties)();
  else   (((const ::reco::CATopJetTagInfo*)o)->properties)();
}

static  void method_48090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CATopJetTagInfo*)o)->insert)(*(const ::edm::RefToBase<reco::Jet>*)arg[0],
    *(const ::reco::CATopJetProperties*)arg[1]);
}

static void method_newdel_11359( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::CATopJetTagInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::CATopJetTagInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::CATopJetTagInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::CATopJetTagInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::CATopJetTagInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x57( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::JetTagInfo")), ::Reflex::BaseOffset< ::reco::CATopJetTagInfo,::reco::JetTagInfo >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::BaseTagInfo")), ::Reflex::BaseOffset< ::reco::CATopJetTagInfo,::reco::BaseTagInfo >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class CATopJetTagInfo -------------------------------
void __reco__CATopJetTagInfo_db_datamem(Reflex::Class*);
void __reco__CATopJetTagInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__CATopJetTagInfo_datamem_bld(&__reco__CATopJetTagInfo_db_datamem);
Reflex::GenreflexMemberBuilder __reco__CATopJetTagInfo_funcmem_bld(&__reco__CATopJetTagInfo_db_funcmem);
void __reco__CATopJetTagInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::CATopJetTagInfo"), typeid(::reco::CATopJetTagInfo), sizeof(::reco::CATopJetTagInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_11668, ::Reflex::BaseOffset< ::reco::CATopJetTagInfo, ::reco::JetTagInfo >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6690, Reflex::Literal("reco::CATopJetTagInfo::jet_type"))
  .AddTypedef(type_11390, Reflex::Literal("reco::CATopJetTagInfo::properties_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20492, type_20494), Reflex::Literal("operator="), operator_48084, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20494), Reflex::Literal("CATopJetTagInfo"), constructor_48085, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CATopJetTagInfo"), constructor_48086, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CATopJetTagInfo"), destructor_48087, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11359, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x57, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__CATopJetTagInfo_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__CATopJetTagInfo_funcmem_bld);
}

//------Delayed data member builder for class CATopJetTagInfo -------------------
void __reco__CATopJetTagInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_11390, Reflex::Literal("properties_"), OffsetOf(__shadow__::__reco__CATopJetTagInfo, properties_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class CATopJetTagInfo -------------------
void __reco__CATopJetTagInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20488), Reflex::Literal("clone"), method_48088, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60053), Reflex::Literal("properties"), method_48089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_60052, type_60053), Reflex::Literal("insert"), method_48090, 0, "jet;properties", ::Reflex::PUBLIC);
}
//------Stub functions for class CATopJetProperties -------------------------------
static void destructor_48240(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::CATopJetProperties*)o)->::reco::CATopJetProperties::~CATopJetProperties)();
}
static  void operator_48241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::CATopJetProperties*)o)->operator=)(*(const ::reco::CATopJetProperties*)arg[0]);
  else   (((::reco::CATopJetProperties*)o)->operator=)(*(const ::reco::CATopJetProperties*)arg[0]);
}

static void constructor_48242( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CATopJetProperties(*(const ::reco::CATopJetProperties*)arg[0]);
  else ::new(mem) ::reco::CATopJetProperties(*(const ::reco::CATopJetProperties*)arg[0]);
}

static void constructor_48243( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CATopJetProperties();
  else ::new(mem) ::reco::CATopJetProperties();
}

static void method_newdel_11390( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::CATopJetProperties >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::CATopJetProperties >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::CATopJetProperties >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::CATopJetProperties >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::CATopJetProperties >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CATopJetProperties -------------------------------
void __reco__CATopJetProperties_db_datamem(Reflex::Class*);
void __reco__CATopJetProperties_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__CATopJetProperties_datamem_bld(&__reco__CATopJetProperties_db_datamem);
Reflex::GenreflexMemberBuilder __reco__CATopJetProperties_funcmem_bld(&__reco__CATopJetProperties_db_funcmem);
void __reco__CATopJetProperties_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::CATopJetProperties"), typeid(::reco::CATopJetProperties), sizeof(::reco::CATopJetProperties), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CATopJetProperties"), destructor_48240, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_69936, type_60053), Reflex::Literal("operator="), operator_48241, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60053), Reflex::Literal("CATopJetProperties"), constructor_48242, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CATopJetProperties"), constructor_48243, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11390, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__CATopJetProperties_datamem_bld);
}

//------Delayed data member builder for class CATopJetProperties -------------------
void __reco__CATopJetProperties_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_74, Reflex::Literal("nSubJets"), OffsetOf(__shadow__::__reco__CATopJetProperties, nSubJets), ::Reflex::PUBLIC)
  .AddDataMember(type_111, Reflex::Literal("minMass"), OffsetOf(__shadow__::__reco__CATopJetProperties, minMass), ::Reflex::PUBLIC)
  .AddDataMember(type_111, Reflex::Literal("topMass"), OffsetOf(__shadow__::__reco__CATopJetProperties, topMass), ::Reflex::PUBLIC)
  .AddDataMember(type_111, Reflex::Literal("wMass"), OffsetOf(__shadow__::__reco__CATopJetProperties, wMass), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class CATopJetProperties -------------------
void __reco__CATopJetProperties_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RefVector<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------------------
static void destructor_36569(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::~RefVector)();
}
static void constructor_36570( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >();
  else ::new(mem) ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >();
}

static void constructor_36571( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_36572( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_36573( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void operator_36574( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_36575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_36576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->refVector)();
}

static  void method_36577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->empty)();
}

static  void method_36578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->size)();
}

static  void method_36579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->capacity)();
}

static  void method_36580( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_36581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->begin)();
}

static  void method_36582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->end)();
}

static  void method_36583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->id)();
}

static  void method_36584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->productGetter)();
}

static  void method_36585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNull)();
}

static  void method_36586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNonnull)();
}

static  void operator_36587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator!)();
}

static  void method_36588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->product)();
}

static  void method_36589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isAvailable)();
}

static  void method_36590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isTransient)();
}

static  void method_36591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >)((((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void method_36592( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->clear)();
}

static  void method_36593( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->swap)(*(::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void operator_36594( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void method_36595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->hasProductCache)();
}

static  void method_36596( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_36597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->Class_Version)();
}

static void method_newdel_6001( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------------------
void __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__datamem_bld(&__edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__funcmem_bld(&__edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_funcmem);
void __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >"), typeid(::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >), sizeof(::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::Class_Version())
  .AddTypedef(type_3553, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::collection_type"))
  .AddTypedef(type_11359, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::member_type"))
  .AddTypedef(type_36284, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::finder_type"))
  .AddTypedef(type_5916, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::iterator"))
  .AddTypedef(type_5916, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::const_iterator"))
  .AddTypedef(type_6744, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::value_type"))
  .AddTypedef(type_6744c, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::const_reference"))
  .AddTypedef(type_6744c, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::reference"))
  .AddTypedef(type_398, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::key_type"))
  .AddTypedef(type_3552, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::KeyVec"))
  .AddTypedef(type_3954, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::size_type"))
  .AddTypedef(type_5220, Reflex::Literal("edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_36569, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_36570, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62828), Reflex::Literal("RefVector"), constructor_36571, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35422), Reflex::Literal("RefVector"), constructor_36572, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6001, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------
void __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5220, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------
void __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_62829), Reflex::Literal("push_back"), method_36573, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6744c, type_3954), Reflex::Literal("operator[]"), operator_36574, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6744c, type_3954), Reflex::Literal("at"), method_36575, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35538), Reflex::Literal("refVector"), method_36576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("empty"), method_36577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("size"), method_36578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("capacity"), method_36579, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954), Reflex::Literal("reserve"), method_36580, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5916), Reflex::Literal("begin"), method_36581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5916), Reflex::Literal("end"), method_36582, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("id"), method_36583, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35539), Reflex::Literal("productGetter"), method_36584, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNull"), method_36585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNonnull"), method_36586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("operator!"), operator_36587, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62830), Reflex::Literal("product"), method_36588, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isAvailable"), method_36589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isTransient"), method_36590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5916, type_62831), Reflex::Literal("erase"), method_36591, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("clear"), method_36592, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_62832), Reflex::Literal("swap"), method_36593, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62832, type_62828), Reflex::Literal("operator="), operator_36594, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasProductCache"), method_36595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_35544), Reflex::Literal("fillView"), method_36596, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("Class_Version"), method_36597, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > -------------------------------
static void constructor_20503( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CATopJetTagInfo>();
  else ::new(mem) ::std::vector<reco::CATopJetTagInfo>();
}

static void constructor_20504( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(const ::std::allocator<reco::CATopJetTagInfo>*)arg[0]);
  else ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(const ::std::allocator<reco::CATopJetTagInfo>*)arg[0]);
}

static void constructor_20505( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::CATopJetTagInfo*)arg[1]);
  else ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::CATopJetTagInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::CATopJetTagInfo*)arg[1],
      *(const ::std::allocator<reco::CATopJetTagInfo>*)arg[2]);
  else ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::CATopJetTagInfo*)arg[1],
      *(const ::std::allocator<reco::CATopJetTagInfo>*)arg[2]);
  }
}

static void constructor_20506( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(const ::std::vector<reco::CATopJetTagInfo>*)arg[0]);
  else ::new(mem) ::std::vector<reco::CATopJetTagInfo>(*(const ::std::vector<reco::CATopJetTagInfo>*)arg[0]);
}

static void destructor_20507(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::CATopJetTagInfo>*)o)->::std::vector<reco::CATopJetTagInfo>::~vector)();
}
static  void operator_20508( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CATopJetTagInfo>*)o)->operator=)(*(const ::std::vector<reco::CATopJetTagInfo>*)arg[0]);
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->operator=)(*(const ::std::vector<reco::CATopJetTagInfo>*)arg[0]);
}

static  void method_20509( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::CATopJetTagInfo*)arg[1]);
}

static  void method_20510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((::std::vector<reco::CATopJetTagInfo>*)o)->begin)());
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->begin)();
}

static  void method_20511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((const ::std::vector<reco::CATopJetTagInfo>*)o)->begin)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->begin)();
}

static  void method_20512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((::std::vector<reco::CATopJetTagInfo>*)o)->end)());
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->end)();
}

static  void method_20513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((const ::std::vector<reco::CATopJetTagInfo>*)o)->end)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->end)();
}

static  void method_20518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CATopJetTagInfo>*)o)->size)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->size)();
}

static  void method_20519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CATopJetTagInfo>*)o)->max_size)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->max_size)();
}

static  void method_20520( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::CATopJetTagInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::CATopJetTagInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::CATopJetTagInfo*)arg[1]);
  }
}

static  void method_20521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CATopJetTagInfo>*)o)->capacity)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->capacity)();
}

static  void method_20522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::CATopJetTagInfo>*)o)->empty)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->empty)();
}

static  void method_20523( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CATopJetTagInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20525( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CATopJetTagInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20527( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CATopJetTagInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20528( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CATopJetTagInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CATopJetTagInfo>*)o)->front)();
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->front)();
}

static  void method_20530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CATopJetTagInfo>*)o)->front)();
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->front)();
}

static  void method_20531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CATopJetTagInfo>*)o)->back)();
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->back)();
}

static  void method_20532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CATopJetTagInfo>*)o)->back)();
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->back)();
}

static  void method_20533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::CATopJetTagInfo>*)o)->data)());
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->data)();
}

static  void method_20534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::CATopJetTagInfo>*)o)->data)());
  else   (((const ::std::vector<reco::CATopJetTagInfo>*)o)->data)();
}

static  void method_20535( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->push_back)(*(const ::reco::CATopJetTagInfo*)arg[0]);
}

static  void method_20536( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->pop_back)();
}

static  void method_20537( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((::std::vector<reco::CATopJetTagInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0],
    *(const ::reco::CATopJetTagInfo*)arg[1]));
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0],
    *(const ::reco::CATopJetTagInfo*)arg[1]);
}

static  void method_20538( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::CATopJetTagInfo*)arg[2]);
}

static  void method_20539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((::std::vector<reco::CATopJetTagInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0]));
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static  void method_20540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >)((((::std::vector<reco::CATopJetTagInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[1]));
  else   (((::std::vector<reco::CATopJetTagInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::CATopJetTagInfo*,std::vector<reco::CATopJetTagInfo> >*)arg[1]);
}

static  void method_20541( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->swap)(*(::std::vector<reco::CATopJetTagInfo>*)arg[0]);
}

static  void method_20542( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::CATopJetTagInfo>*)o)->clear)();
}

static void method_newdel_3553( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CATopJetTagInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CATopJetTagInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CATopJetTagInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CATopJetTagInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CATopJetTagInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x61( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> >")), ::Reflex::BaseOffset< ::std::vector<reco::CATopJetTagInfo>,::std::_Vector_base<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x62( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::CATopJetTagInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::CATopJetTagInfo> >::Generate();
}

//------Dictionary for class vector<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > -------------------------------
void __std__vector_reco__CATopJetTagInfo__db_datamem(Reflex::Class*);
void __std__vector_reco__CATopJetTagInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__CATopJetTagInfo__datamem_bld(&__std__vector_reco__CATopJetTagInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__CATopJetTagInfo__funcmem_bld(&__std__vector_reco__CATopJetTagInfo__db_funcmem);
void __std__vector_reco__CATopJetTagInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::CATopJetTagInfo>"), typeid(::std::vector<reco::CATopJetTagInfo>), sizeof(::std::vector<reco::CATopJetTagInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2939, ::Reflex::BaseOffset< ::std::vector<reco::CATopJetTagInfo>, ::std::_Vector_base<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_11359, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::_Alloc_value_type"))
  .AddTypedef(type_2939, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::_Base"))
  .AddTypedef(type_3977, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::_Tp_alloc_type"))
  .AddTypedef(type_11359, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::value_type"))
  .AddTypedef(type_20488, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::pointer"))
  .AddTypedef(type_20490, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::const_pointer"))
  .AddTypedef(type_20492, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::reference"))
  .AddTypedef(type_20494, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::const_reference"))
  .AddTypedef(type_12107, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::iterator"))
  .AddTypedef(type_12108, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::const_iterator"))
  .AddTypedef(type_4683, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::const_reverse_iterator"))
  .AddTypedef(type_4684, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::reverse_iterator"))
  .AddTypedef(type_3954, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::size_type"))
  .AddTypedef(type_3818, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::difference_type"))
  .AddTypedef(type_3977, Reflex::Literal("std::vector<reco::CATopJetTagInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20503, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59037), Reflex::Literal("vector"), constructor_20504, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3954, type_20494, type_59037), Reflex::Literal("vector"), constructor_20505, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_42817), Reflex::Literal("vector"), constructor_20506, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20507, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3553, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x61, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x62, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__CATopJetTagInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > -------------------
void __std__vector_reco__CATopJetTagInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::CATopJetTagInfo,std::allocator<reco::CATopJetTagInfo> > -------------------
void __std__vector_reco__CATopJetTagInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60092, type_42817), Reflex::Literal("operator="), operator_20508, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954, type_20494), Reflex::Literal("assign"), method_20509, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12107), Reflex::Literal("begin"), method_20510, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12108), Reflex::Literal("begin"), method_20511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12107), Reflex::Literal("end"), method_20512, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12108), Reflex::Literal("end"), method_20513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("size"), method_20518, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("max_size"), method_20519, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954, type_11359), Reflex::Literal("resize"), method_20520, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3954), Reflex::Literal("capacity"), method_20521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("empty"), method_20522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_3954), Reflex::Literal("reserve"), method_20523, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20492, type_3954), Reflex::Literal("operator[]"), operator_20524, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20494, type_3954), Reflex::Literal("operator[]"), operator_20525, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20492, type_3954), Reflex::Literal("at"), method_20527, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20494, type_3954), Reflex::Literal("at"), method_20528, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20492), Reflex::Literal("front"), method_20529, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20494), Reflex::Literal("front"), method_20530, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20492), Reflex::Literal("back"), method_20531, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20494), Reflex::Literal("back"), method_20532, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20488), Reflex::Literal("data"), method_20533, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20490), Reflex::Literal("data"), method_20534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_20494), Reflex::Literal("push_back"), method_20535, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("pop_back"), method_20536, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12107, type_12107, type_20494), Reflex::Literal("insert"), method_20537, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_12107, type_3954, type_20494), Reflex::Literal("insert"), method_20538, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12107, type_12107), Reflex::Literal("erase"), method_20539, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12107, type_12107, type_12107), Reflex::Literal("erase"), method_20540, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_60092), Reflex::Literal("swap"), method_20541, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435), Reflex::Literal("clear"), method_20542, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class RefProd<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------------------
static  void operator_38844( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_38845( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_38846( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >();
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >();
}

static void constructor_38847( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::Handle<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::Handle<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_38848( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_38849( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >((const ::std::vector<reco::CATopJetTagInfo>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >((const ::std::vector<reco::CATopJetTagInfo>*)arg[0]);
}

static void constructor_38850( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::TestHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::TestHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_38851( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_38852(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->::edm::RefProd<std::vector<reco::CATopJetTagInfo> >::~RefProd)();
}
static  void operator_38853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator*)();
}

static  void operator_38854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator->)();
}

static  void method_38855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->get)();
}

static  void method_38856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->product)();
}

static  void method_38857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->refCore)();
}

static  void method_38858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isNull)();
}

static  void method_38859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isNonnull)();
}

static  void operator_38860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->operator!)();
}

static  void method_38861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->id)();
}

static  void method_38862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->productGetter)();
}

static  void method_38863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->hasCache)();
}

static  void method_38864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->hasProductCache)();
}

static  void method_38865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isAvailable)();
}

static  void method_38866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->isTransient)();
}

static  void method_38867( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->swap)(*(::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static  void method_38868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)o)->Class_Version)();
}

static void method_newdel_6619( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CATopJetTagInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CATopJetTagInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CATopJetTagInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CATopJetTagInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CATopJetTagInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------------------
void __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__datamem_bld(&__edm__RefProd_std__vector_reco__CATopJetTagInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__funcmem_bld(&__edm__RefProd_std__vector_reco__CATopJetTagInfo_s__db_funcmem);
void __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::CATopJetTagInfo> >"), typeid(::edm::RefProd<std::vector<reco::CATopJetTagInfo> >), sizeof(::edm::RefProd<std::vector<reco::CATopJetTagInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >::Class_Version())
  .AddTypedef(type_3553, Reflex::Literal("edm::RefProd<std::vector<reco::CATopJetTagInfo> >::product_type"))
  .AddTypedef(type_3553, Reflex::Literal("edm::RefProd<std::vector<reco::CATopJetTagInfo> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63344, type_63345), Reflex::Literal("operator="), operator_38844, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63345), Reflex::Literal("RefProd"), constructor_38845, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_38846, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63346), Reflex::Literal("RefProd"), constructor_38847, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63347), Reflex::Literal("RefProd"), constructor_38848, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62830), Reflex::Literal("RefProd"), constructor_38849, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63348), Reflex::Literal("RefProd"), constructor_38850, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35422, type_35539), Reflex::Literal("RefProd"), constructor_38851, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_38852, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6619, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_reco__CATopJetTagInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_reco__CATopJetTagInfo_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------
void __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6595, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_reco__CATopJetTagInfo_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------
void __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_42817), Reflex::Literal("operator*"), operator_38853, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62830), Reflex::Literal("operator->"), operator_38854, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62830), Reflex::Literal("get"), method_38855, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62830), Reflex::Literal("product"), method_38856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35600), Reflex::Literal("refCore"), method_38857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNull"), method_38858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNonnull"), method_38859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("operator!"), operator_38860, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("id"), method_38861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35539), Reflex::Literal("productGetter"), method_38862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasCache"), method_38863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasProductCache"), method_38864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isAvailable"), method_38865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isTransient"), method_38866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_63344), Reflex::Literal("swap"), method_38867, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("Class_Version"), method_38868, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------------------
static  void operator_39986( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
  else   (((::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_39987( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static void constructor_39988( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >();
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >();
}

static void constructor_39989( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::Handle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::Handle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::Handle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::Handle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_39990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::OrphanHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_39991( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_39992( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >((const ::std::vector<reco::CATopJetTagInfo>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >((const ::std::vector<reco::CATopJetTagInfo>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >((const ::std::vector<reco::CATopJetTagInfo>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >((const ::std::vector<reco::CATopJetTagInfo>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_39993( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::TestHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::TestHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::TestHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::TestHandle<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_39994( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_39995( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CATopJetTagInfo*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::CATopJetTagInfo>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CATopJetTagInfo*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::CATopJetTagInfo>*)arg[3]);
}

static void constructor_39996( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_39997( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefProd<std::vector<reco::CATopJetTagInfo> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_39998(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::~Ref)();
}
static  void operator_39999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator*)();
}

static  void operator_40000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator->)();
}

static  void method_40001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->get)();
}

static  void method_40002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNull)();
}

static  void method_40003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isNonnull)();
}

static  void operator_40004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->operator!)();
}

static  void method_40005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->id)();
}

static  void method_40006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->productGetter)();
}

static  void method_40007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->product)();
}

static  void method_40008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->key)();
}

static  void method_40009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->index)();
}

static  void method_40010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->hasProductCache)();
}

static  void method_40011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isAvailable)();
}

static  void method_40012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->isTransient)();
}

static  void method_40013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->refCore)();
}

static  void method_40014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)o)->Class_Version)();
}

static void constructor_40015( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_6744( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------------------
void __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__datamem_bld(&__edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__funcmem_bld(&__edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_funcmem);
void __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >"), typeid(::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >), sizeof(::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::Class_Version())
  .AddTypedef(type_11359, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::T"))
  .AddTypedef(type_36284, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::F"))
  .AddTypedef(type_36199, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::VF"))
  .AddTypedef(type_36198, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::VBF"))
  .AddTypedef(type_3553, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::product_type"))
  .AddTypedef(type_11359, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::value_type"))
  .AddTypedef(type_11359c, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::element_type"))
  .AddTypedef(type_36284, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::finder_type"))
  .AddTypedef(type_398, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::argument_type"))
  .AddTypedef(type_398, Reflex::Literal("edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63472, type_62829), Reflex::Literal("operator="), operator_39986, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62829), Reflex::Literal("Ref"), constructor_39987, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_39988, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63346, type_398, type_1798), Reflex::Literal("Ref"), constructor_39989, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63347, type_398, type_1798), Reflex::Literal("Ref"), constructor_39990, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62828, type_398, type_1798), Reflex::Literal("Ref"), constructor_39991, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62830, type_398, type_1798), Reflex::Literal("Ref"), constructor_39992, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63348, type_398, type_1798), Reflex::Literal("Ref"), constructor_39993, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35422, type_398, type_35539), Reflex::Literal("Ref"), constructor_39994, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35422, type_20490, type_398, type_62830), Reflex::Literal("Ref"), constructor_39995, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35422), Reflex::Literal("Ref"), constructor_39996, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63345, type_398), Reflex::Literal("Ref"), constructor_39997, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_39998, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35600, type_16564), Reflex::Literal("Ref"), constructor_40015, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6744, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------
void __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6828, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > -------------------
void __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20494), Reflex::Literal("operator*"), operator_39999, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20490), Reflex::Literal("operator->"), operator_40000, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20490), Reflex::Literal("get"), method_40001, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNull"), method_40002, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isNonnull"), method_40003, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("operator!"), operator_40004, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("id"), method_40005, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35539), Reflex::Literal("productGetter"), method_40006, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62830), Reflex::Literal("product"), method_40007, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_398), Reflex::Literal("key"), method_40008, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_398), Reflex::Literal("index"), method_40009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasProductCache"), method_40010, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isAvailable"), method_40011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isTransient"), method_40012, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35600), Reflex::Literal("refCore"), method_40013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("Class_Version"), method_40014, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------------------
static void constructor_37785( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >();
}

static void constructor_37786( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >(*(::std::auto_ptr<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >(*(::std::auto_ptr<std::vector<reco::CATopJetTagInfo> >*)arg[0]);
}

static void destructor_37787(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >::~Wrapper)();
}
static  void method_37788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->product)();
}

static  void operator_37789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->operator->)();
}

static  void method_37790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->productTypeInfo)();
}

static  void method_37791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->typeInfo)();
}

static void constructor_37792( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >((::std::vector<reco::CATopJetTagInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >((::std::vector<reco::CATopJetTagInfo>*)arg[0]);
}

static  void method_37793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->getInterface)();
}

static  void method_37794( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_37795( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_37796( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_37797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_37798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->isPresent)();
}

static  void method_37799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_6255( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CATopJetTagInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------------------
void __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__datamem_bld(&__edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::CATopJetTagInfo> >"), typeid(::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >), sizeof(::edm::Wrapper<std::vector<reco::CATopJetTagInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::CATopJetTagInfoCollection>")
  .AddTypedef(type_3553, Reflex::Literal("edm::Wrapper<std::vector<reco::CATopJetTagInfo> >::value_type"))
  .AddTypedef(type_3553, Reflex::Literal("edm::Wrapper<std::vector<reco::CATopJetTagInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_37785, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3241), Reflex::Literal("Wrapper"), constructor_37786, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_37787, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62993), Reflex::Literal("Wrapper"), constructor_37792, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6255, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------
void __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1798, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__CATopJetTagInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3553, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__CATopJetTagInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> > > -------------------
void __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62830), Reflex::Literal("product"), method_37788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62830), Reflex::Literal("operator->"), operator_37789, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("productTypeInfo"), method_37790, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("typeInfo"), method_37791, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62994), Reflex::Literal("getInterface"), method_37793, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_35422, type_35543, type_62995), Reflex::Literal("fillView"), method_37794, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_389, type_16681), Reflex::Literal("setPtr"), method_37795, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_5901, type_35653, type_35543), Reflex::Literal("fillPtrVector"), method_37796, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo"), method_37797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isPresent"), method_37798, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5901), Reflex::Literal("dynamicTypeInfo_"), method_37799, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------------------
static  void operator_63095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
}

static void constructor_63096( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
}

static void constructor_63097( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >();
}

static void constructor_63098( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void method_63099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
}

static void destructor_63100(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::~RefHolder)();
}
static  void method_63101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->clone)();
}

static  void method_63102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->id)();
}

static  void method_63103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->key)();
}

static  void method_63104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_63105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_63106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->getRef)();
}

static  void method_63107( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void method_63108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->makeVectorHolder)();
}

static  void method_63109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->productGetter)();
}

static  void method_63110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->hasProductCache)();
}

static  void method_63111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->product)();
}

static  void method_63112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isAvailable)();
}

static  void method_63113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->Class_Version)();
}

static void method_newdel_38151( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x67( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<reco::CATopJetTagInfoRef>")
  .AddBase(type_19143, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72812, type_72813), Reflex::Literal("operator="), operator_63095, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72813), Reflex::Literal("RefHolder"), constructor_63096, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_63097, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62829), Reflex::Literal("RefHolder"), constructor_63098, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_63100, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_38151, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x67, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6744, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_72812), Reflex::Literal("swap"), method_63099, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38769), Reflex::Literal("clone"), method_63101, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("id"), method_63102, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2394), Reflex::Literal("key"), method_63103, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_71771), Reflex::Literal("isEqualTo"), method_63104, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_38771, type_16743), Reflex::Literal("fillRefIfMyTypeMatches"), method_63105, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62829), Reflex::Literal("getRef"), method_63106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_62829), Reflex::Literal("setRef"), method_63107, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3238), Reflex::Literal("makeVectorHolder"), method_63108, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35539), Reflex::Literal("productGetter"), method_63109, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasProductCache"), method_63110, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5295), Reflex::Literal("product"), method_63111, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isAvailable"), method_63112, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("Class_Version"), method_63113, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------------------
static void constructor_63124( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >();
}

static void constructor_63125( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
}

static void constructor_63126( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >(*(const ::edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> >*)arg[0]);
}

static  void operator_63127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
}

static  void method_63128( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)arg[0]);
}

static void destructor_63129(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::~Holder)();
}
static  void method_63130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->clone)();
}

static  void method_63131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->getPtr)();
}

static  void method_63132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->id)();
}

static  void method_63133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->key)();
}

static  void method_63134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::BaseTagInfo>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::BaseTagInfo>*)arg[0]);
}

static  void method_63135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->getRef)();
}

static  void method_63136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_63137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->holder)();
}

static  void method_63138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::BaseTagInfo> >)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->makeVectorHolder)();
}

static  void method_63139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->makeVectorBaseHolder)();
}

static  void method_63140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->productGetter)();
}

static  void method_63141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->hasProductCache)();
}

static  void method_63142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->product)();
}

static  void method_63143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->isAvailable)();
}

static  void method_63144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >*)o)->Class_Version)();
}

static void method_newdel_38156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x69( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::BaseTagInfo>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >,::edm::reftobase::BaseHolder<reco::BaseTagInfo> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------------------
void __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__datamem_bld(&__edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >"), typeid(::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >), sizeof(::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::Holder<reco::BaseTagInfo, reco::CATopJetTagInfoRef>")
  .AddBase(type_38140, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > >, ::edm::reftobase::BaseHolder<reco::BaseTagInfo> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_63124, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72818), Reflex::Literal("Holder"), constructor_63125, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_62829), Reflex::Literal("Holder"), constructor_63126, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_63129, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_38156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x69, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------
void __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6744, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo, edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo, std::allocator<reco::CATopJetTagInfo> >, reco::CATopJetTagInfo> > > -------------------
void __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72819, type_72818), Reflex::Literal("operator="), operator_63127, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_435, type_72819), Reflex::Literal("swap"), method_63128, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72807), Reflex::Literal("clone"), method_63130, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28634), Reflex::Literal("getPtr"), method_63131, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6592), Reflex::Literal("id"), method_63132, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2394), Reflex::Literal("key"), method_63133, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_72809), Reflex::Literal("isEqualTo"), method_63134, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_62829), Reflex::Literal("getRef"), method_63135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798, type_38771, type_16743), Reflex::Literal("fillRefIfMyTypeMatches"), method_63136, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3240), Reflex::Literal("holder"), method_63137, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3239), Reflex::Literal("makeVectorHolder"), method_63138, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3238), Reflex::Literal("makeVectorBaseHolder"), method_63139, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35539), Reflex::Literal("productGetter"), method_63140, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("hasProductCache"), method_63141, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5295), Reflex::Literal("product"), method_63142, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1798), Reflex::Literal("isAvailable"), method_63143, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_200), Reflex::Literal("Class_Version"), method_63144, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TtSemiEvtSolution_dict(); 
      __TtFullHadronicEvent_dict(); 
      __TtSemiLeptonicEvent_dict(); 
      __StEvtSolution_dict(); 
      __TtHadEvtSolution_dict(); 
      __TtGenEvent_dict(); 
      __TtDilepEvtSolution_dict(); 
      __TopGenEvent_dict(); 
      __StGenEvent_dict(); 
      __TtEvent_dict(); 
      __TtFullLeptonicEvent_dict(); 
      __std__pair_edm__RefToBase_reco__Jet__reco__CATopJetProperties__dict(); 
      __std__pair_reco__CompositeCandidate_std__vector_int_s__dict(); 
      __std__pair_WDecay__LeptonType_WDecay__LeptonType__dict(); 
      __std__vector_StEvtSolution__dict(); 
      __std__vector_TtHadEvtSolution__dict(); 
      __std__vector_TtSemiEvtSolution__dict(); 
      __std__vector_TtDilepEvtSolution__dict(); 
      __std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s__dict(); 
      __std__map_TtEvent__HypoClassKey_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__dict(); 
      __std__map_TtEvent__HypoClassKey_int__dict(); 
      __edm__Wrapper_std__vector_StEvtSolution_s__dict(); 
      __edm__Wrapper_std__vector_TtHadEvtSolution_s__dict(); 
      __edm__Wrapper_std__vector_TtSemiEvtSolution_s__dict(); 
      __edm__Wrapper_std__vector_TtDilepEvtSolution_s__dict(); 
      __edm__Wrapper_std__vector_std__pair_reco__CompositeCandidate_std__vector_int_s_s_s__dict(); 
      __edm__Wrapper_reco__CompositeCandidate__dict(); 
      __edm__Wrapper_TtFullHadronicEvent__dict(); 
      __edm__Wrapper_TtSemiLeptonicEvent__dict(); 
      __edm__Wrapper_TtFullLeptonicEvent__dict(); 
      __edm__Wrapper_TopGenEvent__dict(); 
      __edm__Wrapper_StGenEvent__dict(); 
      __edm__Wrapper_TtGenEvent__dict(); 
      __edm__RefProd_TtFullHadronicEvent__dict(); 
      __edm__RefProd_TtSemiLeptonicEvent__dict(); 
      __edm__RefProd_TtFullLeptonicEvent__dict(); 
      __edm__RefProd_TopGenEvent__dict(); 
      __edm__RefProd_StGenEvent__dict(); 
      __edm__RefProd_TtGenEvent__dict(); 
      __reco__CATopJetTagInfo_dict(); 
      __reco__CATopJetProperties_dict(); 
      __edm__RefVector_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__dict(); 
      __std__vector_reco__CATopJetTagInfo__dict(); 
      __edm__RefProd_std__vector_reco__CATopJetTagInfo_s__dict(); 
      __edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s__dict(); 
      __edm__Wrapper_std__vector_reco__CATopJetTagInfo_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__dict(); 
      __edm__reftobase__Holder_reco__BaseTagInfo_edm__Ref_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_edm__refhelper__FindUsingAdvance_std__vector_reco__CATopJetTagInfo__reco__CATopJetTagInfo_s_s__dict(); 
    }
    ~Dictionaries() {
      type_977.Unload(); // class TtSemiEvtSolution 
      type_1100.Unload(); // class TtFullHadronicEvent 
      type_1227.Unload(); // class TtSemiLeptonicEvent 
      type_1709.Unload(); // class StEvtSolution 
      type_1805.Unload(); // class TtHadEvtSolution 
      type_1829.Unload(); // class TtGenEvent 
      type_2053.Unload(); // class TtDilepEvtSolution 
      type_2227.Unload(); // class TopGenEvent 
      type_2546.Unload(); // class StGenEvent 
      type_2674.Unload(); // class TtEvent 
      type_2790.Unload(); // class TtFullLeptonicEvent 
      type_3458.Unload(); // class std::pair<edm::RefToBase<reco::Jet>,reco::CATopJetProperties> 
      type_3460.Unload(); // class std::pair<reco::CompositeCandidate,std::vector<int> > 
      type_3462.Unload(); // class std::pair<WDecay::LeptonType,WDecay::LeptonType> 
      type_3554.Unload(); // class std::vector<StEvtSolution> 
      type_3555.Unload(); // class std::vector<TtHadEvtSolution> 
      type_3556.Unload(); // class std::vector<TtSemiEvtSolution> 
      type_3557.Unload(); // class std::vector<TtDilepEvtSolution> 
      type_3558.Unload(); // class std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > 
      type_3843.Unload(); // class std::map<TtEvent::HypoClassKey,std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > 
      type_3844.Unload(); // class std::map<TtEvent::HypoClassKey,int> 
      type_6256.Unload(); // class edm::Wrapper<std::vector<StEvtSolution> > 
      type_6257.Unload(); // class edm::Wrapper<std::vector<TtHadEvtSolution> > 
      type_6258.Unload(); // class edm::Wrapper<std::vector<TtSemiEvtSolution> > 
      type_6259.Unload(); // class edm::Wrapper<std::vector<TtDilepEvtSolution> > 
      type_6260.Unload(); // class edm::Wrapper<std::vector<std::pair<reco::CompositeCandidate,std::vector<int> > > > 
      type_6261.Unload(); // class edm::Wrapper<reco::CompositeCandidate> 
      type_6262.Unload(); // class edm::Wrapper<TtFullHadronicEvent> 
      type_6263.Unload(); // class edm::Wrapper<TtSemiLeptonicEvent> 
      type_6264.Unload(); // class edm::Wrapper<TtFullLeptonicEvent> 
      type_6265.Unload(); // class edm::Wrapper<TopGenEvent> 
      type_6266.Unload(); // class edm::Wrapper<StGenEvent> 
      type_6267.Unload(); // class edm::Wrapper<TtGenEvent> 
      type_6620.Unload(); // class edm::RefProd<TtFullHadronicEvent> 
      type_6621.Unload(); // class edm::RefProd<TtSemiLeptonicEvent> 
      type_6622.Unload(); // class edm::RefProd<TtFullLeptonicEvent> 
      type_6623.Unload(); // class edm::RefProd<TopGenEvent> 
      type_6624.Unload(); // class edm::RefProd<StGenEvent> 
      type_6625.Unload(); // class edm::RefProd<TtGenEvent> 
      type_11359.Unload(); // class reco::CATopJetTagInfo 
      type_11390.Unload(); // class reco::CATopJetProperties 
      type_6001.Unload(); // class edm::RefVector<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > 
      type_3553.Unload(); // class std::vector<reco::CATopJetTagInfo> 
      type_6619.Unload(); // class edm::RefProd<std::vector<reco::CATopJetTagInfo> > 
      type_6744.Unload(); // class edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > 
      type_6255.Unload(); // class edm::Wrapper<std::vector<reco::CATopJetTagInfo> > 
      type_38151.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > 
      type_38156.Unload(); // class edm::reftobase::Holder<reco::BaseTagInfo,edm::Ref<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo,edm::refhelper::FindUsingAdvance<std::vector<reco::CATopJetTagInfo>,reco::CATopJetTagInfo> > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
